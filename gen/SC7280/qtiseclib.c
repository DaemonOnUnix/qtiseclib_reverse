/*0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000464 t $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000684 t $d
0000000000000a50 t $d
0000000000000c10 t $d
0000000000000d04 t $d
0000000000000fb8 t $d
0000000000001018 t $d
00000000000011cc t $d
0000000000001578 t $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000008 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000001808 t $d
00000000000019b8 t $d
0000000000001b7c t $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000070 d $d
0000000000000078 d $d
0000000000000030 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000318 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000030 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000320 d $d
0000000000000078 d $d
00000000000000f0 d $d
0000000000000080 d $d
0000000000000038 d $d
00000000000000a8 d $d
0000000000000040 d $d
0000000000000010 d $d
00000000000000c0 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000040 d $d
0000000000000028 d $d
0000000000000020 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000010 d $d
0000000000000010 d $d
0000000000000060 d $d
0000000000000000 d $d
0000000000000008 d $d
0000000000000008 d $d
0000000000000000 d $d
0000000000000020 d $d
0000000000000008 d $d
0000000000000008 d $d
0000000000000000 d $d
0000000000000008 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000330 d $d
0000000000000088 d $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 r $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000001c40 t $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 r $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 b $d
0000000000000000 b $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 d $d
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000538 t $x
0000000000000588 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
00000000000005a8 t $x
0000000000000698 t $x
0000000000000ba0 t $x
0000000000000c28 t $x
0000000000000d10 t $x
0000000000001014 t $x
0000000000001108 t $x
00000000000011d8 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
00000000000016a0 t $x
0000000000001810 t $x
00000000000019c8 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000001b90 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 t $x
0000000000000000 D acc_ctl
0000000000000000 T ac_init
0000000000000000 d aClockGroups
0000000000000000 d aClocks
0000000000000000 r aClockVRegMapping
0000000000000000 T ACQCGetxPUType
0000000000000000 T ACTzTargetConfig
0000000000000000 t add_cmd_set_for_sleep.isra.0.constprop.3
0000000000000000 t add_explicit_cmd_set_for_sleep
0000000000000000 t add_rc_for_sleep
0000000000000000 b addr_trans_segs
0000000000000000 t add_sw_node_request
0000000000000000 d aGCCSourceMap
0000000000000000 t aggregate_sw_node
0000000000000000 d AggreNocMMUAudioTBUPD
0000000000000000 d AggreNocMMUPCIETBUPD
0000000000000000 d AggreNocMMUTBU1PD
0000000000000000 d AggreNocMMUTBU2PD
0000000000000000 b alloc_offset.1210
0000000000000000 B anoc1_mpu_rg_addr
0000000000000000 D anoc1_mpu_rgs
0000000000000000 D anoc2_mpu_rg_addr
0000000000000000 D anoc2_mpu_rgs
0000000000000000 D aoss_cnoc_mpu_rg_addr
0000000000000000 D aoss_cnoc_mpu_rgs
00000000000013f8 t apply_mibu_scid_qos_config
0000000000000000 b apps_branches
0000000000000000 d apps_cx_ret
0000000000000000 d apps_cx_ret_aoss
0000000000000000 b apps_delays
0000000000000000 d apps_pdc_cfg
0000000000000000 d apps_pdc_modes
0000000000000000 d apss_dummy
0000000000000000 d apss_rsc_modes
0000000000000000 d apss_sslpm
0000000000000000 d apss_sslpm_pdc_hs
0000000000000000 d aQUPSEConfig100Mhz
0000000000000000 d aQUPSEConfig120Mhz
0000000000000000 b asAVSRegs
0000000000000000 d aSources
0000000000000000 b atfHeap
0000000000000000 b atfHeapDesc
0000000000000000 d bcm_acv
0000000000000000 b bcm_acv_requests
0000000000000000 d bcm_ce0
0000000000000000 b bcm_ce0_requests
0000000000000000 d bcm_cn0
0000000000000000 b bcm_cn0_requests
0000000000000000 d bcm_cn1
0000000000000000 b bcm_cn1_requests
0000000000000000 d bcm_co0
0000000000000000 b bcm_co0_requests
0000000000000000 d bcm_co3
0000000000000000 b bcm_co3_requests
0000000000000000 d bcm_hk0
0000000000000000 b bcm_hk0_requests
0000000000000000 d bcm_ip0
0000000000000000 b bcm_ip0_requests
0000000000000000 d bcm_mc0
0000000000000000 b bcm_mc0_requests
0000000000000000 d bcm_mm0
0000000000000000 b bcm_mm0_requests
0000000000000000 d bcm_mm1
0000000000000000 b bcm_mm1_requests
0000000000000000 d bcm_pka0
0000000000000000 b bcm_pka0_requests
0000000000000000 d bcm_qup0
0000000000000000 b bcm_qup0_requests
0000000000000000 d bcm_qup1
0000000000000000 b bcm_qup1_requests
0000000000000000 d bcm_sh0
0000000000000000 b bcm_sh0_requests
0000000000000000 d bcm_sh3
0000000000000000 b bcm_sh3_requests
0000000000000000 d bcm_sh4
0000000000000000 b bcm_sh4_requests
0000000000000000 d bcm_sn0
0000000000000000 b bcm_sn0_requests
0000000000000000 d bcm_sn7
0000000000000000 b bcm_sn7_requests
0000000000000000 d bcm_sn8
0000000000000000 b bcm_sn8_requests
0000000000000000 d bIsInit.1181
0000000000000000 b bSSCGDSCPrevEnabled
0000000000000000 T calculate_cpumasks
0000000000000000 T check_dupRegion
0000000000000000 T check_for_events
0000000000000000 T check_overlap
0000000000000090 t clear_mdcr_epmad_reg_exit
0000000000001a68 t clear_mdcr_epmad_reg_exit
0000000000001a54 t clear_mdcr_epmad_reg_start
0000000000000000 D clkdom_cpumasks
0000000000000000 D clkdom_init_status
0000000000000000 T Clock_DisableClock
0000000000000000 T Clock_DisableClockDomain
0000000000000000 T Clock_DisableClockGroup
0000000000000000 t Clock_DisableSource
0000000000000000 d ClockDrvCtxt
0000000000000000 T Clock_EnableClock
0000000000000000 T Clock_EnableClockDomain
0000000000000000 T Clock_EnableClockGroup
0000000000000000 T Clock_EnableDFS
0000000000000000 T Clock_EnableSource
0000000000000000 T Clock_GetClockId
0000000000000000 T Clock_GetFrequencyPlan
0000000000000000 T Clock_GetRPMId
0000000000000000 T Clock_Init
0000000000000000 T Clock_InitImage
0000000000000000 T Clock_InitRPMh
0000000000000000 T Clock_IsBSPSupported
0000000000000000 T Clock_IsClockOn
0000000000000000 T Clock_IsClockPowerDomainOn
0000000000000004 C ClockMutex
0000000000000000 T Clock_PostInitImage
0000000000000000 d clock_reg_addrs
0000000000000000 D clock_reg_vals
0000000000000000 T Clock_RPMRequest
0000000000000000 T Clock_SetClockFrequency
0000000000000000 T Clock_SetCXVoltage
0000000000000000 T Clock_SetRPMAvailable
0000000000000000 D ClockTZBSPConfig
0000000000000000 T Clock_TZInitDone
0000000000000000 t Clock_VoltageRequest
0000000000000000 T Clock_WriteRegRegion
0000000000001b90 T cluster_aarch64_sysini
0000000000000000 T cmd_db_access_done
0000000000000000 B cmd_db_addr
0000000000000000 T cmd_db_conv_str_to_unit64
0000000000000000 T cmd_db_init
0000000000000000 T cmd_db_prep_access
0000000000000000 T cmd_db_query
0000000000000000 T cmd_db_query_addr
0000000000000000 T cmd_db_query_aux_data
0000000000000000 T cmd_db_query_len
0000000000000000 T cmd_db_query_priority
0000000000000000 T cmd_db_query_priority_res_id
0000000000000000 T cmd_db_query_slv_id
0000000000000000 T cmd_db_query_version
0000000000000000 T cmd_db_target_mem_init
0000000000000000 B cmd_db_test_addr
0000000000000000 B cmd_db_test_data
0000000000000000 B cmd_db_test_priority
0000000000000000 T cmd_db_tzbsp_init
0000000000000000 T cmdq_empty
0000000000000000 T cmdq_finish_cmd
0000000000000000 T cmdq_num_in_flight
0000000000000000 b cmd_word_count.1139
0000000000000000 D cnoc2_ss_mpu_rg_addr
0000000000000000 D cnoc2_ss_mpu_rgs
0000000000000000 b commit_queue
0000000000000000 T compare_ch_segments
0000000000000000 d __compound_literal.0
0000000000000318 d __compound_literal.0
0000000000000320 d __compound_literal.0
0000000000000330 d __compound_literal.0
0000000000000000 d __compound_literal.1
0000000000000070 d __compound_literal.1
0000000000000078 d __compound_literal.1
0000000000000088 d __compound_literal.1
0000000000000000 d __compound_literal.10
0000000000000010 d __compound_literal.10
0000000000000000 d __compound_literal.11
0000000000000010 d __compound_literal.11
0000000000000000 d __compound_literal.12
0000000000000060 d __compound_literal.12
0000000000000000 b __compound_literal.13
0000000000000000 d __compound_literal.13
0000000000000000 d __compound_literal.14
0000000000000008 d __compound_literal.14
0000000000000000 d __compound_literal.15
0000000000000008 d __compound_literal.15
0000000000000000 d __compound_literal.16
0000000000000040 d __compound_literal.16
0000000000000000 b __compound_literal.17
0000000000000000 d __compound_literal.17
0000000000000000 d __compound_literal.18
0000000000000008 d __compound_literal.18
0000000000000000 d __compound_literal.19
0000000000000008 d __compound_literal.19
0000000000000000 d __compound_literal.2
0000000000000000 b __compound_literal.2
00000000000000f0 d __compound_literal.2
0000000000000000 d __compound_literal.20
0000000000000028 d __compound_literal.20
0000000000000000 d __compound_literal.21
0000000000000020 d __compound_literal.21
0000000000000000 d __compound_literal.22
0000000000000020 d __compound_literal.22
0000000000000000 b __compound_literal.23
0000000000000000 d __compound_literal.23
0000000000000000 b __compound_literal.24
0000000000000000 d __compound_literal.24
0000000000000000 d __compound_literal.25
0000000000000008 d __compound_literal.25
0000000000000000 d __compound_literal.26
0000000000000000 b __compound_literal.27
0000000000000000 d __compound_literal.28
0000000000000000 d __compound_literal.29
0000000000000000 d __compound_literal.3
0000000000000078 d __compound_literal.3
0000000000000080 d __compound_literal.3
0000000000000000 b __compound_literal.30
0000000000000000 d __compound_literal.31
0000000000000000 d __compound_literal.32
0000000000000000 b __compound_literal.33
0000000000000000 d __compound_literal.34
0000000000000000 d __compound_literal.35
0000000000000000 b __compound_literal.36
0000000000000000 d __compound_literal.37
0000000000000000 d __compound_literal.4
0000000000000030 d __compound_literal.4
0000000000000038 d __compound_literal.4
0000000000000000 d __compound_literal.5
0000000000000000 b __compound_literal.5
00000000000000a8 d __compound_literal.5
0000000000000000 d __compound_literal.6
0000000000000030 d __compound_literal.6
0000000000000040 d __compound_literal.6
0000000000000000 d __compound_literal.7
0000000000000010 d __compound_literal.7
0000000000000000 d __compound_literal.8
00000000000000c0 d __compound_literal.8
0000000000000000 b __compound_literal.9
0000000000000000 d __compound_literal.9
0000000000000000 D configs_kodiak
00000000000019c8 T cortex_a55_aarch64_sysini
0000000000000000 T cortex_a78_aarch64_sysini
00000000000003bc T cortex_a78_amu_disable
00000000000003e4 t cortex_a78_amu_disable_exit
0000000000000390 T cortex_a78_amu_enable
00000000000003b8 t cortex_a78_amu_enable_exit
0000000000000214 t cortex_a78_amu_restore_exit
000000000000022c t cortex_a78_amu_save_exit
0000000000000128 t cortex_a78_mpmm_default
0000000000000120 t cortex_a78_SC7280_mpmm_start
0000000000000000 t CPR11_SVSL1_QUOT_VMIN
0000000000001c18 T cpu_aarch64_sysini
0000000000000000 d cpu_c2d_sequence
0000000000000000 d cpu_c3_sequence
0000000000000000 T cpucp_clkdom_init
0000000000000000 B cpucp_clkdom_init_spinlock
0000000000000000 T cpucp_host_clock_domain_disable
0000000000000000 T cpucp_host_clock_domain_enable
0000000000000000 T cpucp_host_clock_domain_init
0000000000000000 T cpucp_host_configure_shared_data
0000000000000000 T cpucp_host_error_handler
0000000000000000 T cpucp_host_handle_irq
0000000000000000 T cpucp_host_init
0000000000000000 T cpucp_host_recv_message
0000000000000000 T cpucp_host_send_message
0000000000000000 T cpucp_iface_initialize
0000000000000000 T cpucp_load_firmware
0000000000000000 T cpucp_prepare
0000000000000000 T cpucp_scmi_send
0000000000000000 T cpucp_start
0000000000000000 T cpucp_unprepare
0000000000000000 t cpu_init
0000000000000000 t cpu_lpm_entry
0000000000000000 T cpu_lpm_exit
0000000000000000 D cpu_modes
0000000000000000 D cpu_node_ops
0000000000000000 D cpu_pcu_modes
0000000000000000 t cpu_power_on
0000000000000000 t cpu_power_on_finish
0000000000001bc4 T cpuss_aarch64_por_sysini
0000000000000598 T cpuss_dmb
0000000000000590 T cpuss_dsb
00000000000005a0 T cpuss_isb
0000000000000588 T cpuss_read_isr
0000000000000000 T dbg_err_fatal
0000000000000000 t dbg_err_fatal_handler
0000000000000000 D dbg_err_fatal_str
0000000000000000 t dbg_halt_online_cpus
0000000000000000 T dbg_init
0000000000000000 T dbg_is_sdi_enable
0000000000000000 t debugExecute.part.3
0000000000000000 D DrvBaseAddressMapping_array_subsystem
0000000000000000 D DrvBaseAddressMappingTable_subsystem
0000000000000000 R DRV_CONFIG_DATA
0000000000000000 T drv_valid
00000000000001e0 t dummy1
000000000000030c t e_1467580_wa
0000000000000348 t e_1492189_wa
0000000000000268 t e_1503072_wa
0000000000000238 t e_1515634_wa
0000000000000330 t e_1688305_wa
0000000000000378 t e_1821534_wa
0000000000000360 t e_1827429_wa
0000000000000250 t e_1875698_wa
00000000000003e8 t e_1941498_wa
0000000000000400 t e_1951500_wa
00000000000000ec t en_cortex_a78_mpmm_pdp
0000000000000034 t en_dbg_feat
000000000000022c t end_of_function
0000000000000678 t end_of_function
0000000000000a40 t end_of_function
0000000000000c04 t end_of_function
0000000000000cf8 t end_of_function
0000000000000fa8 t end_of_function
00000000000011c0 t end_of_function
0000000000001568 t end_of_function
00000000000017fc t end_of_function
00000000000019ac t end_of_function
0000000000001b70 t end_of_function
0000000000000148 t en_error_records
0000000000000020 t en_vfp
00000000000000c8 t en_wr_clus_pm_reg
00000000000000a4 t en_wr_pwr_ctrl_reg
0000000000000090 t en_wr_pwr_ctrl_reg_s_el1
0000000000000000 d first_time.1190
0000000000000000 b g_apss_pdc
0000000000000000 b g_apss_rsc
00000000000000cc C g_cmd_set
0000000000000000 b g_dbg_svc_lock
0000000000000000 D gemnoc_cnoc_mpu_rg_addr
0000000000000000 D gemnoc_cnoc_mpu_rgs
0000000000000000 d generics
0000000000000000 t get_addr_translation
0000000000000000 t get_cmd_in_progress.isra.1.constprop.3
0000000000000000 t get_device_configuration.isra.0
0000000000000000 t get_finished_amc
0000000000000000 T get_finished_drv
0000000000000000 T get_input_payload_char_at_offset
0000000000000000 T get_input_payload_word_at_offset
0000000000000000 T get_max_cmd_size
0000000000000000 t get_rc
0000000000000000 T get_system_memory_map
0000000000000000 B g_fatal_err_code
0000000000000000 d gHALAVSContext
0000000000000000 b g_int_cpu_interruptible_state
0000000000000000 b g_int_cpu_on_state
0000000000000000 b g_int_svc_cpu_state_lock
0000000000000000 b g_int_svc_fiq_lock
0000000000000000 b g_int_swdog_target
0000000000000000 b g_isrs
0000000000000068 C GlobalRscHalCtxt
0000000000000000 b g_mpidr_map
0000000000000018 C g_msg
0000000000000100 C g_msg_body
0000000000000000 D gold_pll_pcu_modes
0000000000000000 d gold_plus_pll_c4_sequence
0000000000000000 D goldplus_pll_pcu_modes
0000000000000000 d gold_rail_c4_sequence
0000000000000000 D gold_rail_pcu_modes
0000000000000000 R g_pcu_count
0000000000000000 b g_pdc_aoss_base
0000000000000000 D g_pdcGpioInputs
0000000000000000 R g_pdcGPIOInputSize
0000000000000000 D g_pdcGpioMapping
0000000000000000 R g_pdcGPIOMappingSize
0000000000000018 C g_pdcGpios
0000000000000000 D g_pdcInterruptMapping
0000000000000010 C g_pdcInterrupts
0000000000000000 R g_pdcInterruptTableSize
0000000000000000 D g_pdc_resource_data_instances
0000000000000000 D g_pdcResourceList
0000000000000000 B g_pdc_seq_count
0000000000000000 D g_pdc_seq_instance_count
0000000000000000 D g_pdc_seq_instances
0000000000000000 B g_pdc_seqs
0000000000000000 b g_pdc_ss_base
0000000000000000 D g_pdcTCSConfig
0000000000000000 t gpio_findEntry
0000000000000000 D g_psci_asic_nodes
0000000000000000 R g_psci_asic_nodes_count
0000000000000000 b g_psci_sys_cache_active
0000000000000000 d GPUSMMUPowerDomain
0000000000000000 b g_res
0000000000000000 b g_res_count
0000000000000000 D g_rsc_count
0000000000000000 D g_rsc_instances
0000000000000000 B g_rscs
0000000000000000 b g_rsc_ss_base
0000000000000000 D g_sec_wdog_last_pet_time
0000000000000000 R g_vmid_map
0000000000000000 R g_vmid_map_count
0000000000000000 R g_vmidmt_cfg
0000000000000000 R g_vmidmt_cfg_count
0000000000000000 D g_vmidmt_info_cfg
0000000000000000 R g_vmidmt_info_cfg_count
0000000000000000 D g_xpu_base_addr_array
0000000000000000 D g_xpu_base_addr_array_count
0000000000000000 T HAL_avs_BusyWait
0000000000000000 T HAL_avs_Enable
0000000000000000 T HAL_avs_EnableCtl
0000000000000000 T HAL_avs_GetVddSettleTimeUS
0000000000000000 T HAL_avs_Init
0000000000000000 T HAL_avs_Ramp_En
0000000000000000 T HAL_avs_RestoreBootVoltage
0000000000000000 T HAL_avs_SecondaryRailInit
0000000000000000 T HAL_avs_SetClockDivider
0000000000000000 T HAL_avs_SetDelay
0000000000000000 T HAL_avs_SetMaxVoltage
0000000000000000 T HAL_avs_SetMinVoltage
0000000000000000 T HAL_avs_SetPowerMode
0000000000000000 T HAL_avs_SetVoltage
0000000000000000 T HAL_avs_SetVoltageStepSize
0000000000000000 T HAL_avs_SetVoltageWidth
0000000000000000 T HAL_clk_ConfigClockMux
0000000000000000 T HAL_clk_ConfigDFSMux
0000000000000000 T HAL_clk_DisableClock
0000000000000000 T HAL_clk_DisablePowerDomain
0000000000000000 T HAL_clk_DisableSource
0000000000000000 T HAL_clk_EnableClock
0000000000000000 T HAL_clk_EnableDFS
0000000000000000 T HAL_clk_EnablePowerDomain
0000000000000000 T HAL_clk_EnableSource
0000000000000000 t HAL_clk_GenericConfigMuxOffs.part.0
0000000000000000 T HAL_clk_IsClockOn
0000000000000000 T HAL_clk_IsPowerDomainOn
0000000000000000 T HAL_clk_WaitForClockOn
0000000000000000 T HAL_clk_WaitForPowerDomainOn
0000000000000000 t HALInternal_setInterruptState
0000000000000000 T handle_scmi_base_protocol_msg
0000000000000000 T handle_scmi_clk_mgmt_protocol_msg
                 U handle_scmi_perf_dom_mgmt_protocol_msg
                 U handle_scmi_unknown_protocol
                 U handle_scmi_vendor_protocol_msg
0000000000000000 b heapHasInit
0000000000000008 C hmss_pcu_memory_base
0000000000000008 C hmss_pcu_seq_memory
00000000000005a8 T hoya_10_cluster_aarch64_sysini
0000000000000698 T hoya_10_cpuss_aarch64_por_sysini
0000000000000ba0 T hoya_10_interconnect_aarch64_sysini
0000000000000684 T HOYA_10_SYSINI_VERSION_CLUSTER
0000000000000aa4 T HOYA_10_SYSINI_VERSION_CPUSS
0000000000000c10 T HOYA_10_SYSINI_VERSION_INTERCONNECT
0000000000000c28 T hoya_11_cluster_aarch64_sysini
0000000000000d10 T hoya_11_cpuss_aarch64_por_sysini
0000000000000d04 T HOYA_11_SYSINI_VERSION_CLUSTER
0000000000001018 T HOYA_11_SYSINI_VERSION_CPUSS
0000000000001108 T hoya_20_cluster_aarch64_sysini
00000000000011d8 T hoya_20_cpuss_aarch64_por_sysini
0000000000000000 D icbcfg_data_kodiak_v1
0000000000000000 T icbcfg_init
0000000000000000 D icbcfg_prop_kodiak_v1
0000000000000000 b icb_dev_config
0000000000000008 b icb_dev_config
0000000000000000 B icb_dev_config_valid
0000000000000000 T icb_error_init
0000000000000000 T ICB_Get_AllowedMemRegion
0000000000000000 T ICB_Get_MCAddr
0000000000000000 T ICB_Get_Memmap
0000000000000000 d icb_hw_node_list
0000000000000000 d icb_master_list
0000000000000000 d icb_route_list
0000000000000000 d icb_slave_list
0000000000000000 T icbuarb_create_client
0000000000000000 T icbuarb_d4_entry
0000000000000000 T icbuarb_d4_exit
0000000000000000 T icbuarb_destroy_client
0000000000000000 T icbuarb_init
0000000000000000 T icbuarb_issue_request
0000000000000000 T icbuarb_prio_override_disable
0000000000000000 T icbuarb_prio_override_enable
0000000000000000 T icbuarb_target_d4_entry
0000000000000000 T icbuarb_target_d4_exit
0000000000000000 T icbuarb_target_init
0000000000000000 T icbuarb_target_prio_override_disable
0000000000000000 T icbuarb_target_prio_override_enable
0000000000000000 T icbuarb_target_throttle_disable
0000000000000000 T icbuarb_target_throttle_enable
0000000000000000 T icbuarb_throttle_disable
0000000000000000 T icbuarb_throttle_enable
0000000000000000 b info
0000000000000000 b init_done.1195
0000000000000000 d initial_dynmode_id.1266
0000000000000000 b initialized
0000000000000000 t init_system_configuration
0000000000000000 T inq_append
0000000000000000 T inq_create
0000000000000000 T inq_destroy
0000000000000000 T inq_head
0000000000000000 T inq_it_begin
0000000000000000 T inq_it_delete
0000000000000000 T inq_it_deref
0000000000000000 T inq_it_insert
0000000000000000 T inq_it_next
0000000000000000 T inq_pop
0000000000000000 T inq_size
0000000000001bf8 T interconnect_aarch64_sysini
0000000000000000 T interconnect_enable_ns_register_access
0000000000000000 t int_findEntry
0000000000000000 T int_svc_core_pos_to_mpidr
0000000000000000 T int_svc_init
0000000000000000 T int_svc_is_cpu_on
0000000000000000 T int_svc_notify_cpu_state
0000000000000000 T int_svc_register_isr
0000000000000000 T int_svc_unregister_isr
0000000000000000 T is_amc_finished
0000000000000000 T is_amc_free
0000000000000000 T isContextInitialized
0000000000000000 D isr_name
0000000000000000 T is_rpmh_busy
0000000000000000 T is_tcs_stuck
0000000000000000 D kodiak
00000000000016a0 T kryo400_gold_aarch64_config_wa_sysini
00000000000016d8 t kryo400_gold_aarch64_config_wa_sysini_end
00000000000016e0 T kryo400_gold_aarch64_sysini
0000000000001810 T kryo400_silver_aarch64_sysini
00000000000019c8 T kryo500_silver_aarch64_sysini
0000000000000000 d l3_d2d_sequence
0000000000000000 d l3_d4_sequence
0000000000000000 t l3_init
0000000000000000 t l3_lpm_entry
0000000000000000 t l3_lpm_exit
0000000000000000 D l3_modes
0000000000000000 D l3_node_ops
0000000000000000 D l3_pcu_modes
0000000000000954 t l_763985_exit
0000000000000918 t l_763985_start
00000000000008e8 t l_764609_exit
00000000000008c8 t l_764609_start
0000000000001988 t l_798797_exit
0000000000001974 t l_798797_start
0000000000000654 t l_798953_exit
0000000000000640 t l_798953_start
00000000000009a4 t l_876346_exit
0000000000000984 t l_876346_start
00000000000019a8 t l_992657_exit
0000000000001b6c t l_992657_exit
0000000000001994 t l_992657_start
0000000000001b58 t l_992657_start
0000000000000ec0 t l_aux_clk_on_enable_exit
0000000000000ea0 t l_aux_clk_on_enable_start
0000000000000cd4 t l_clusterbusqos_end
000000000000119c t l_clusterbusqos_end
0000000000000cc8 t l_clusterbusqos_start
0000000000001190 t l_clusterbusqos_start
0000000000001158 t l_configure_unique_clean_evict
0000000000001528 t l_disable_MIBU_snoop_counter_begin
0000000000001560 t l_disable_MIBU_snoop_counter_end
0000000000001548 t l_disable_MIBU_snoop_counter_start
00000000000014d0 t l_Enable_Formal_fix_for_MIBU_begin
0000000000001500 t l_Enable_Formal_fix_for_MIBU_end
00000000000014d4 t l_Enable_Formal_fix_for_MIBU_start
0000000000000c90 t l_enable_unique_cleanevict_end
0000000000000c78 t l_enable_unique_cleanevict_start
0000000000000d60 t l_end_config_core0
0000000000000d88 t l_end_config_core1
0000000000000db0 t l_end_config_core2
0000000000000dd8 t l_end_config_core3
0000000000000e00 t l_end_config_core4
0000000000000e28 t l_end_config_core5
0000000000000e50 t l_end_config_core6
0000000000000e78 t l_end_config_core7
00000000000013d8 t l_en_gic_fault_err_intr_exit
000000000000137c t l_en_gic_fault_err_intr_start
00000000000009c4 t l_en_gnoc_ext_access
00000000000009e4 t l_en_gnoc_ext_access_exit
00000000000012a4 t l_fal10_feature_enable_exit
000000000000128c t l_fal10_feature_enable_start
00000000000008a8 t l_late_cancel_enable_exit
0000000000000888 t l_late_cancel_enable_start
0000000000000000 D llcc_mpu_rg_addr
0000000000000000 D llcc_mpu_rgs
0000000000000868 t l_mem_svs_enable_start
0000000000000888 t l_mem_svs_exit
0000000000000000 T lmh_c4_entry
0000000000000000 T lmh_c4_exit
0000000000000000 T lmh_config_init
0000000000000000 T lmh_cpu_boot_config
0000000000000000 d lmh_enable
000000000000000a C lmh_hsr_version
0000000000000000 T lmh_target_config_init
0000000000000000 T lmh_target_cpu_boot_config
0000000000000000 T lookup_drv_index
0000000000000f6c t l_SC7180_spi_cfg_start
000000000000149c t l_SC7280_spi_cfg_start
0000000000000a04 t l_SDM845_spi_cfg_start
000000000000135c t l_set_mibu_qos_ctl_end
0000000000001344 t l_set_mibu_qos_ctl_start
0000000000000a38 t l_spi_cfg_exit
0000000000000fa0 t l_spi_cfg_exit
00000000000014d0 t l_spi_cfg_exit
0000000000001500 t l_TESTBUS_MUX_EN_begin
0000000000001528 t l_TESTBUS_MUX_EN_end
0000000000001510 t l_TESTBUS_MUX_EN_start
0000000000000000 b lvl_buf
0000000000000000 d magic_num
0000000000000000 b magic_num_index_array
0000000000000000 D map_ddr_regions_kodiak
0000000000000000 T mapOS_getGpioTable
0000000000000000 T mapOS_getInterruptTable
0000000000000000 d master_chm_apps
0000000000000000 d master_chm_apps_hw_nodes
0000000000000000 d master_hwkm_core_master
0000000000000000 d master_ipa_core_master
0000000000000000 d master_llcc_mc
0000000000000000 d master_pka_core_master
0000000000000000 d master_qhm_qup0
0000000000000000 d master_qhm_qup1
0000000000000000 d master_qnm_aggre1_noc
0000000000000000 d master_qnm_aggre1_noc_hw_nodes
0000000000000000 d master_qnm_aggre2_noc
0000000000000000 d master_qnm_aggre2_noc_hw_nodes
0000000000000000 d master_qnm_cmpnoc
0000000000000000 d master_qnm_cmpnoc_hw_nodes
0000000000000000 d master_qnm_cnoc3_cnoc2
0000000000000000 d master_qnm_cnoc3_cnoc2_hw_nodes
0000000000000000 d master_qnm_gemnoc_cnoc
0000000000000000 d master_qnm_gemnoc_cnoc_hw_nodes
0000000000000000 d master_qnm_mnoc_hf
0000000000000000 d master_qnm_snoc_sf
0000000000000000 d master_qup0_core_master
0000000000000000 d master_qup1_core_master
0000000000000000 d master_qxm_crypto
0000000000000000 d master_qxm_crypto_hw_nodes
0000000000000000 d master_qxm_mdp0
0000000000000000 d master_qxm_mdp0_hw_nodes
0000000000000000 d master_qxm_nsp
0000000000000004 C max_cmd_size
0000000000000000 T mem_assign
                 U memcpy
0000000000000000 T mem_free
0000000000000000 T mem_get_buffer_size
0000000000000000 t mem_get_next_block
0000000000000000 t mem_heap_enter_crit_sect
0000000000000000 t mem_heap_leave_crit_sect
0000000000000000 t mem_init_block_header.isra.0
0000000000000000 T mem_init_heap
0000000000000000 b mem_magic_number
0000000000000000 T mem_malloc
0000000000000000 T mem_realloc
0000000000000000 d MMNOCMMUTBUHF0PD
0000000000000000 d MMNOCMMUTBUHF1PD
0000000000000000 d MMNOCMMUTBUSF0PD
0000000000000000 b mm_node
0000000000000000 D modem_mpus
0000000000000000 B modem_ms_mpu_rg_addr
0000000000000000 D modem_ms_mpu_rgs
0000000000000000 D msm_mpu_ranges
0000000000000000 R msm_mpu_ranges_count
0000000000000000 D msm_xpu_cfg
0000000000000000 R msm_xpu_cfg_count
0000000000000000 T msm_xpu_isr
0000000000000000 T msm_xpu_print_log
0000000000000000 B mss_nav_mpu_rg_addr
0000000000000000 D mss_nav_mpu_rgs
0000000000000000 D mss_nav_mpus
0000000000000000 D mss_q6_mpu_rg_addr
0000000000000000 D mss_q6_mpu_rgs
0000000000000000 B nMPSSQ6DbgVal
0000000000000000 d NOCERR_cfgdata
0000000000000000 D NOCERR_cfgdata_oem
0000000000000000 T NOC_Error_Handle_Interrupt
0000000000000000 T NOC_Error_Init
0000000000000000 T NOC_Error_Platform_Get_Propdata
0000000000000000 T NOC_Error_Platform_Get_Propdata_OEM
0000000000000000 b NOCERR_propdata
0000000000000000 D NOCERR_propdata
0000000000000000 D NOCERR_propdata_oem
0000000000000000 b NOCInfo
0000000000000000 b NOCInfoOEM
0000000000000000 t nsec_wdt_bite_isr_handler
0000000000000000 b numTcsPerHLOSDrv
0000000000000000 T pcu_config_low_power_mode
0000000000000000 T pcu_config_seq_ctl
0000000000000000 T pcu_get_node
0000000000000000 T pcu_init
0000000000000000 T pcu_node_init
0000000000000000 T pcu_seq_memory_init
0000000000000000 D pcu_sequencer
0000000000000000 T pcu_sequencer_target_init
0000000000000000 T pcu_write_cmds
0000000000000000 T pcu_write_seq_memory
0000000000000000 T pdc_getTriggerConfig
0000000000000000 T pdcGpio_config
0000000000000000 T pdcGpio_disable
0000000000000000 T pdcGpio_enable
0000000000000000 T pdcGpio_unconfig
0000000000000000 T pdcHAL_disable
0000000000000000 T pdcHAL_enable
0000000000000000 T pdcHAL_setGPIOConfig
0000000000000000 T pdcHAL_setOwner
0000000000000000 T pdcHAL_setTriggerConfig
0000000000000000 T pdc_initialize
0000000000000000 T pdcInt_config
0000000000000000 T pdcInt_disable
0000000000000000 T pdcInt_enable
0000000000000000 B PDC_LOCK_NAME
0000000000000000 T pdcMap_getGpioTable
0000000000000000 T pdcMap_getInterruptTable
0000000000000000 T pdcOS_initialize
0000000000000000 T pdc_seq_copy_cmd_seq
0000000000000000 T pdc_seq_count
0000000000000000 T pdc_seq_driver_init
0000000000000000 T pdc_seq_enable
0000000000000000 T pdc_seq_enable_arc_timer
0000000000000000 T pdc_seq_enable_profile_ts
0000000000000000 T pdc_seq_hal_cfg_br_addr
0000000000000000 T pdc_seq_hal_cfg_br_event_override
0000000000000000 T pdc_seq_hal_cfg_delay
0000000000000000 T pdc_seq_hal_cfg_pwr_ctl_override
0000000000000000 T pdc_seq_hal_cfg_start_addr
0000000000000000 T pdc_seq_hal_cfg_start_addr_ex
0000000000000000 T pdc_seq_hal_cfg_wait_event_override
0000000000000000 T pdc_seq_hal_cfg_wakeup_time
0000000000000000 T pdc_seq_hal_cfg_wakeup_time_ex
0000000000000000 T pdc_seq_hal_clk_gate_enable
0000000000000000 T pdc_seq_hal_copy_cmd_seq
0000000000000000 T pdc_seq_hal_enable
0000000000000000 T pdc_seq_hal_enable_arc_timer
0000000000000000 T pdc_seq_hal_enable_profile_ts
0000000000000000 T pdc_seq_hal_profile_ts
0000000000000000 T pdc_seq_hal_profile_ts_count
0000000000000000 T pdc_seq_handle_env_init
0000000000000000 T pdc_seq_handle_init
0000000000000000 T pdc_seq_handle_internal_cfg
0000000000000000 T pdc_seq_handles
0000000000000000 T pdc_seq_handle_target_init
0000000000000000 T pdc_seq_mode_index
0000000000000000 T pdc_seq_profile_ts
0000000000000000 T pdc_seq_profile_ts_count
0000000000000000 T pdc_seq_set_lpm
0000000000000000 T pdc_seq_set_wakeup_time
0000000000000000 T pdc_seq_sys_init
0000000000000000 T pdc_seq_test
0000000000000000 T pdcTarget_postInit
0000000000000000 T pdcTarget_preInit
0000000000000000 T pdcTcs_getAllResourceList
0000000000000000 T pdcTcs_getResources
0000000000000000 T pdcTcs_initialize
0000000000000000 b perm_lock.1439
0000000000000000 D platform_init_functions
0000000000000000 T pm_app_ps_hold_cfg
0000000000000000 T pm_comm_channel_init_internal
0000000000000000 T pm_comm_read_byte
0000000000000000 T pm_comm_read_byte_array
0000000000000000 T pm_comm_read_byte_mask
0000000000000000 T pm_comm_write_byte
0000000000000000 T pm_comm_write_byte_array
0000000000000000 T pm_comm_write_byte_mask
0000000000000000 b pm_device_info_arr
0000000000000000 T pm_get_pmic_model
0000000000000000 T pm_get_slave_id
0000000000000000 T pm_pon_get_reset_config_val
0000000000000000 T pm_pon_gp_reset_cfg
0000000000000000 T pm_pon_init
0000000000000000 b pm_pon_initialized
0000000000000000 T pm_pon_ps_hold_cfg
0000000000000000 r pm_pon_pshold_gp1_reset_cfg_arr
0000000000000000 r pm_pon_pshold_reset_cfg_arr
0000000000000000 T pm_pon_tgt_specific_pshold_cfg
0000000000000000 b pm_primary_slave_id
0000000000000000 T pm_tgt_get_pshold_gp1_reset_cfg
0000000000000000 T pm_tgt_get_pshold_reset_cfg
0000000000000000 T pm_version_detect
0000000000000000 b pm_version_initialized
0000000000000000 d pon_gp1_reg
0000000000000000 d pon_gp2_reg
0000000000000000 b pon_ps_hold_reg
0000000000000218 t power_down_sequence
000000000000065c t power_down_sequence
0000000000000a3c t power_down_sequence
0000000000000c00 t power_down_sequence
0000000000000cdc t power_down_sequence
0000000000000fa4 t power_down_sequence
00000000000011a4 t power_down_sequence
0000000000001564 t power_down_sequence
00000000000017fc t power_down_sequence
00000000000019ac t power_down_sequence
0000000000001b70 t power_down_sequence
0000000000000670 t power_down_sequence_primary_cluster
0000000000000cf0 t power_down_sequence_primary_cluster
00000000000011b8 t power_down_sequence_primary_cluster
0000000000000674 t power_down_sequence_secondary_cluster
0000000000000cf4 t power_down_sequence_secondary_cluster
00000000000011bc t power_down_sequence_secondary_cluster
0000000000000020 t power_up_sequence
00000000000005d0 t power_up_sequence
00000000000006b4 t power_up_sequence
0000000000000bbc t power_up_sequence
0000000000000c50 t power_up_sequence
0000000000000d2c t power_up_sequence
0000000000001130 t power_up_sequence
00000000000011f4 t power_up_sequence
0000000000001700 t power_up_sequence
0000000000001830 t power_up_sequence
00000000000019e8 t power_up_sequence
00000000000005e4 t power_up_sequence_primary_cluster
0000000000000c64 t power_up_sequence_primary_cluster
0000000000001144 t power_up_sequence_primary_cluster
0000000000000658 t power_up_sequence_secondary_cluster
0000000000000cd8 t power_up_sequence_secondary_cluster
00000000000011a0 t power_up_sequence_secondary_cluster
0000000000000000 D pSpmiBlockInfo
0000000000000000 T pwr_utils_hlvl
0000000000000000 T pwr_utils_hlvl_named_resource
0000000000000000 T pwr_utils_lvl_init
0000000000000000 T pwr_utils_lvl_resource_idx
0000000000000000 T pwr_utils_named_resource_lvls_count
0000000000000000 T pwr_utils_resource_lvls_count
0000000000000000 T pwr_utils_vlvl
0000000000000000 T pwr_utils_vlvl_named_resource
0000000000000000 d QNOC_4_0
0000000000000000 d QNOC_POS_4_0
0000000000000000 d QNOC_SB_4_0_2L
0000000000000000 d QNOC_SB_4_0_L
0000000000000000 r qtimer_frames
0000000000000000 T qtisec_assert
0000000000000000 D qtisec_build_string
0000000000000000 T qtisec_free
0000000000000000 T qtiseclib_bl31_platform_setup
                 U qtiseclib_cb_console_flush
                 U qtiseclib_cb_gic_pcpu_init
                 U qtiseclib_cb_ic_raise_sgi
                 U qtiseclib_cb_log
                 U qtiseclib_cb_memcpy
                 U qtiseclib_cb_memmove
                 U qtiseclib_cb_memset
                 U qtiseclib_cb_plat_core_pos_by_mpidr
                 U qtiseclib_cb_plat_my_core_pos
                 U qtiseclib_cb_set_spi_routing
                 U qtiseclib_cb_spin_lock
                 U qtiseclib_cb_spin_unlock
                 U qtiseclib_cb_strcmp
                 U qtiseclib_cb_switch_console_to_crash_state
                 U qtiseclib_cb_udelay
0000000000000538 T qtiseclib_cpuss_reset_asm
0000000000000558 t qtiseclib_cpuss_reset_asm_cmn
0000000000000000 T qtiseclib_invoke_isr
0000000000000000 T qtiseclib_is_debug_enabled_secure_io_access
000000000000056c T qtiseclib_kryo6_gold_reset_asm
0000000000000578 T qtiseclib_kryo6_silver_reset_asm
0000000000000000 T qtiseclib_mem_assign
0000000000000000 T qtiseclib_panic
0000000000000000 T qtiseclib_psci_init
0000000000000000 T qtiseclib_psci_node_on_finish
0000000000000000 T qtiseclib_psci_node_power_off
0000000000000000 T qtiseclib_psci_node_power_on
0000000000000000 T qtiseclib_psci_node_suspend
0000000000000000 T qtiseclib_psci_node_suspend_finish
0000000000000000 T qtiseclib_psci_system_off
0000000000000000 T qtiseclib_psci_system_reset
0000000000000000 T qtisec_malloc
0000000000000000 D qtisec_oem_string
0000000000000000 T qtisec_psci_node_down
0000000000000000 T qtisec_realloc
0000000000000000 D qtisec_variant_string
0000000000000000 D qtisec_version_string
0000000000000000 B query_dev_config_valid
0000000000000000 d QUPV3Wrap0S0Domain
0000000000000000 d QUPV3Wrap0S1Domain
0000000000000000 d QUPV3Wrap0S2Domain
0000000000000000 d QUPV3Wrap0S3Domain
0000000000000000 d QUPV3Wrap0S4Domain
0000000000000000 d QUPV3Wrap0S5Domain
0000000000000000 d QUPV3Wrap0S6Domain
0000000000000000 d QUPV3Wrap0S7Domain
0000000000000000 d QUPV3Wrap1S0Domain
0000000000000000 d QUPV3Wrap1S1Domain
0000000000000000 d QUPV3Wrap1S2Domain
0000000000000000 d QUPV3Wrap1S3Domain
0000000000000000 d QUPV3Wrap1S4Domain
0000000000000000 d QUPV3Wrap1S5Domain
0000000000000000 d QUPV3Wrap1S6Domain
0000000000000000 d QUPV3Wrap1S7Domain
0000000000000000 b rail_on.1712
0000000000000000 t remove_client_requests
0000000000000000 t remove_sw_node_request
0000000000000000 t resource_command_dirty_update.isra.0
0000000000000000 T resource_command_sets_dirty
0000000000000000 R resource_count
0000000000000000 d resource_list
0000000000000000 d route_chm_apps_ebi
0000000000000000 d route_chm_apps_ebi_hops
0000000000000000 d route_chm_apps_qhs_crypto0_cfg
0000000000000000 d route_chm_apps_qhs_crypto0_cfg_hops
0000000000000000 d route_chm_apps_qhs_hwkm
0000000000000000 d route_chm_apps_qhs_hwkm_hops
0000000000000000 d route_chm_apps_qhs_pka_wrapper_cfg
0000000000000000 d route_chm_apps_qhs_pka_wrapper_cfg_hops
0000000000000000 d route_chm_apps_qhs_qup0
0000000000000000 d route_chm_apps_qhs_qup0_hops
0000000000000000 d route_chm_apps_qhs_qup1
0000000000000000 d route_chm_apps_qhs_qup1_hops
0000000000000000 d route_chm_apps_qns_llcc
0000000000000000 d route_chm_apps_qns_llcc_hops
0000000000000000 d route_hwkm_core_master_hwkm_core_slave
0000000000000000 d route_hwkm_core_master_hwkm_core_slave_hops
0000000000000000 d route_ipa_core_master_ipa_core_slave
0000000000000000 d route_ipa_core_master_ipa_core_slave_hops
0000000000000000 d route_llcc_mc_ebi
0000000000000000 d route_llcc_mc_ebi_hops
0000000000000000 d route_pka_core_master_pka_core_slave
0000000000000000 d route_pka_core_master_pka_core_slave_hops
0000000000000000 d route_qhm_qup0_ebi
0000000000000000 d route_qhm_qup0_ebi_hops
0000000000000000 d route_qhm_qup0_qhs_crypto0_cfg
0000000000000000 d route_qhm_qup0_qhs_crypto0_cfg_hops
0000000000000000 d route_qhm_qup0_qhs_hwkm
0000000000000000 d route_qhm_qup0_qhs_hwkm_hops
0000000000000000 d route_qhm_qup0_qhs_pka_wrapper_cfg
0000000000000000 d route_qhm_qup0_qhs_pka_wrapper_cfg_hops
0000000000000000 d route_qhm_qup0_qhs_qup1
0000000000000000 d route_qhm_qup0_qhs_qup1_hops
0000000000000000 d route_qhm_qup0_qns_llcc
0000000000000000 d route_qhm_qup0_qns_llcc_hops
0000000000000000 d route_qhm_qup1_ebi
0000000000000000 d route_qhm_qup1_ebi_hops
0000000000000000 d route_qhm_qup1_qhs_crypto0_cfg
0000000000000000 d route_qhm_qup1_qhs_crypto0_cfg_hops
0000000000000000 d route_qhm_qup1_qhs_hwkm
0000000000000000 d route_qhm_qup1_qhs_hwkm_hops
0000000000000000 d route_qhm_qup1_qhs_pka_wrapper_cfg
0000000000000000 d route_qhm_qup1_qhs_pka_wrapper_cfg_hops
0000000000000000 d route_qhm_qup1_qhs_qup0
0000000000000000 d route_qhm_qup1_qhs_qup0_hops
0000000000000000 d route_qhm_qup1_qns_llcc
0000000000000000 d route_qhm_qup1_qns_llcc_hops
0000000000000000 d route_qup0_core_master_qup0_core_slave
0000000000000000 d route_qup0_core_master_qup0_core_slave_hops
0000000000000000 d route_qup1_core_master_qup1_core_slave
0000000000000000 d route_qup1_core_master_qup1_core_slave_hops
0000000000000000 d route_qxm_crypto_ebi
0000000000000000 d route_qxm_crypto_ebi_hops
0000000000000000 d route_qxm_crypto_qns_llcc
0000000000000000 d route_qxm_crypto_qns_llcc_hops
0000000000000000 d route_qxm_mdp0_ebi
0000000000000000 d route_qxm_mdp0_ebi_hops
0000000000000000 d route_qxm_mdp0_qns_llcc
0000000000000000 d route_qxm_mdp0_qns_llcc_hops
0000000000000000 d route_qxm_nsp_ebi
0000000000000000 d route_qxm_nsp_ebi_hops
0000000000000000 d route_qxm_nsp_qhs_crypto0_cfg
0000000000000000 d route_qxm_nsp_qhs_crypto0_cfg_hops
0000000000000000 d route_qxm_nsp_qhs_hwkm
0000000000000000 d route_qxm_nsp_qhs_hwkm_hops
0000000000000000 d route_qxm_nsp_qhs_pka_wrapper_cfg
0000000000000000 d route_qxm_nsp_qhs_pka_wrapper_cfg_hops
0000000000000000 d route_qxm_nsp_qhs_qup0
0000000000000000 d route_qxm_nsp_qhs_qup0_hops
0000000000000000 d route_qxm_nsp_qhs_qup1
0000000000000000 d route_qxm_nsp_qhs_qup1_hops
0000000000000000 d route_qxm_nsp_qns_llcc
0000000000000000 d route_qxm_nsp_qns_llcc_hops
0000000000000030 C rpmh
0000000000000000 T rpmh_barrier_all
0000000000000000 T rpmh_barrier_single
0000000000000000 T rpmh_check_tcs_idle_HLOS
0000000000000000 T rpmh_churn_all
0000000000000000 T rpmh_churn_single
0000000000000000 T rpmh_clean_cmd
0000000000000000 T rpmh_client_command_add
0000000000000000 T rpmh_client_command_finish
0000000000000000 T rpmh_client_command_remove
0000000000000000 T rpmh_client_handle_add
0000000000000000 T rpmh_client_init
0000000000000000 T rpmh_clientq_create
0000000000000000 T rpmh_client_wait_on_cmd
0000000000000000 T rpmh_clock_toggle
0000000000000000 T rpmh_clz
0000000000000000 T rpmh_cmdq_create
0000000000000000 T rpmh_cmdq_send_cmd_at_head
0000000000000000 T rpmh_cmdq_send_cmd_set
0000000000000000 T rpmh_core_verify
0000000000000000 T rpmh_core_verify_ptr
0000000000000000 t rpmh_create_dal_event
0000000000000000 T rpmh_create_handle
0000000000000000 T rpmh_create_handle_explicit
0000000000000000 T rpmh_create_handle_internal
0000000000000000 T rpmh_deregister_isr
0000000000000000 t rpmh_destroy_dal_event
0000000000000000 T rpmh_enter_sleep
0000000000000000 T rpmh_epcb_timeout
0000000000000000 T rpmh_err_fatal
0000000000000000 D rpmh_event_create
0000000000000000 D rpmh_event_destroy
0000000000000000 D rpmh_event_reset
0000000000000000 D rpmh_event_set
0000000000000000 D rpmh_event_wait
0000000000000000 T rpmh_exit_sleep
0000000000000000 T rpmh_find_resource_command
0000000000000000 T rpmh_finish_amc
0000000000000000 T rpmh_finish_amc_internal
0000000000000000 T rpmh_free
0000000000000000 T rpmh_get_timestamp
0000000000000000 T rpmh_get_wake_latency
0000000000000000 b rpmh_handle
0000000000000000 T rpmh_invalidate_explicit_cmds
0000000000000000 T rpmh_is_drv_id_valid
0000000000000000 B rpmh_is_processing
0000000000000000 T rpmh_issue_command
0000000000000000 T rpmh_issue_command_set
0000000000000000 T rpmh_issue_command_set_internal
0000000000000000 T rpmh_lock
0000000000000000 T rpmh_malloc
0000000000000004 C rpmh_os
0000000000000000 T rpmh_os_init
0000000000000000 T rpmh_realloc
0000000000000000 T rpmh_register_isr
0000000000000000 t rpmh_reset_dal_event
0000000000000000 T rpmh_resource_command_exit_sleep
0000000000000000 T rpmh_resource_command_finish
0000000000000000 T rpmh_resource_command_get_priority
0000000000000000 T rpmh_resource_command_get_voter
0000000000000000 T rpmh_resource_command_init
0000000000000000 T rpmh_resource_command_update
0000000000000000 T rpmh_resource_command_val_at_rpmh
0000000000000000 t rpmh_set_dal_event
0000000000000000 B RPMH_STANDALONE
0000000000000008 C rpmh_tcs
0000000000000000 T rpmh_unlock
0000000000000000 b rpmh_wa_handle
0000000000000000 t rpmh_wait_dal_event
0000000000000000 t rpmh_wait_for_cmd.constprop.5
0000000000000000 T rsc_conf_hidden_tcs_ownership
0000000000000000 T rsc_copy_cmd_seqs
0000000000000000 T rsc_driver_init
0000000000000000 T rsc_enable_ts_events
0000000000000000 T rsc_get_count
0000000000000000 T rsc_get_handles
0000000000000000 T rsc_get_time_stamp
0000000000000000 T RscHalCheckAMCFinishedIRQ
0000000000000000 T RscHalCheckTCSCmdCompletionStatus
0000000000000000 T RscHalCheckTCSCmdIssueStatus
0000000000000000 T RscHalCheckTCSCmdTriggerStatus
0000000000000000 T RscHalCheckTCSIdle_HLOS
0000000000000000 T RscHalClearAMCFinishedIRQ
0000000000000000 T RscHalClearePCBTimedOut
0000000000000000 T rsc_hal_conf_hidden_tcs_owner
0000000000000000 T rsc_hal_config_br_addr
0000000000000000 T RscHalConfigureCmdCompletion
0000000000000000 T RscHalConvertAMCtoTCS
0000000000000000 T RscHalConvertTCStoAMC
0000000000000000 T rsc_hal_copy_extended_cmd_seq
0000000000000000 T rsc_hal_copy_simple_cmd_seq
0000000000000000 T RscHalDisableAMCFinishedIRQ
0000000000000000 T RscHalEnableAMCFinishedIRQ
0000000000000000 T rsc_hal_enable_ts_unit
0000000000000000 T rscHalGetChipsetMappingTable
0000000000000000 T rscHalGetContext
0000000000000000 T rsc_hal_get_delay_cntr_bitwidth
0000000000000000 T rscHalGetDrvInfo
0000000000000000 T rsc_hal_get_major_ver
0000000000000000 T rsc_hal_get_minor_ver
0000000000000000 T rscHalGetNumCmdsPerTcs
0000000000000000 T rsc_hal_get_num_drvs
0000000000000000 T rsc_hal_get_num_seq_cmd_words
0000000000000000 T rscHalGetNumTcs
0000000000000000 T rsc_hal_get_num_ts_events
0000000000000000 T rsc_hal_get_parentchild_cfg
0000000000000000 T rsc_hal_get_seq_override_start_addr_valid
0000000000000000 T rsc_hal_get_seq_program_counter
0000000000000000 T rsc_hal_get_solver_cfg
0000000000000000 T rsc_hal_get_status0
0000000000000000 T rsc_hal_get_status1
0000000000000000 T rsc_hal_get_status2
0000000000000000 T rsc_hal_get_step_ver
0000000000000000 T rsc_hal_get_ts_overflow
0000000000000000 T rsc_hal_get_ts_unit_h
0000000000000000 T rsc_hal_get_ts_unit_l
0000000000000000 T rsc_hal_get_ts_valid
0000000000000000 T RscHalIsePCBTimedOut
0000000000000000 T RscHalIsTCSIdle
0000000000000004 C rsc_hal_read_back_val
0000000000000000 T RscHalReadConfig
0000000000000000 T RscHalReadResponseData
0000000000000000 T RscHalRegisterDrv
0000000000000000 T rsc_hal_seq_busy
0000000000000000 T rsc_hal_set_seq_override_start_addr
0000000000000000 T rsc_hal_set_seq_override_start_addr_valid
0000000000000000 T rsc_hal_set_trigger_seq
0000000000000000 T rsc_hal_set_trigger_start_address
0000000000000000 T rsc_hal_set_ts_unit_owner
0000000000000000 T rscHalSetupDrv0Tcs
0000000000000000 T rscHalSetupDrv2Tcs
0000000000000000 T RscHalSetupTCS
0000000000000000 T RscHalToggleePCBTimeOut
0000000000000000 T RscHalToggleTCSCmd
0000000000000000 T RscHalTriggerTCS
0000000000000000 T RscHalUpdateePCBTimeOutThreshold
0000000000000000 T RscHalVersionID
0000000000000000 T rsc_init_base_address
0000000000000000 T rsc_instance_init
0000000000000000 T rsc_mode_index
0000000000000040 C rsc_params
0000000000000000 b rsc_params_count
0000000000000000 T rsc_program_dyn_cmd_seq
0000000000000000 T rsc_read_id_info
0000000000000000 T rsc_read_internal_config
0000000000000000 T rsc_set_low_power_mode
0000000000000000 T rsc_target_init
0000000000000000 T rsc_trigger_seq
0000000000000000 T rsc_ts_init
0000000000000000 T scmi_construct_msg_hdr
0000000000000000 B scmi_host_spinlock
                 U scmi_num_clk_doms
0000000000000000 T scmi_packet_init_payload
                 U scmi_plat_ops
0000000000000000 T scmi_process_packet
0000000000000000 T scmi_read_packet
0000000000000000 T scmi_write_packet
0000000000000000 T sec_core
0000000000000000 T set_boot_remap
0000000000000000 t set_g_cmd_set_single
0000000000000000 t sgi15_isr_handler
0000000000000000 d silver_pll_c4_sequence
0000000000000000 D silver_pll_pcu_modes
000000000000147c t skip_mibu_scid_qos_config
0000000000000000 d slave_ebi
0000000000000000 d slave_ebi_hw_nodes
0000000000000000 d slave_hwkm_core_slave
0000000000000000 d slave_hwkm_core_slave_hw_nodes
0000000000000000 d slave_ipa_core_slave
0000000000000000 d slave_ipa_core_slave_hw_nodes
0000000000000000 d slave_pka_core_slave
0000000000000000 d slave_pka_core_slave_hw_nodes
0000000000000000 d slave_qhs_crypto0_cfg
0000000000000000 d slave_qhs_crypto0_cfg_hw_nodes
0000000000000000 d slave_qhs_hwkm
0000000000000000 d slave_qhs_hwkm_hw_nodes
0000000000000000 d slave_qhs_pka_wrapper_cfg
0000000000000000 d slave_qhs_pka_wrapper_cfg_hw_nodes
0000000000000000 d slave_qhs_qup0
0000000000000000 d slave_qhs_qup0_hw_nodes
0000000000000000 d slave_qhs_qup1
0000000000000000 d slave_qhs_qup1_hw_nodes
0000000000000000 d slave_qns_a1noc_snoc
0000000000000000 d slave_qns_a2noc_snoc
0000000000000000 d slave_qns_cnoc3_cnoc2
0000000000000000 d slave_qns_cnoc3_cnoc2_hw_nodes
0000000000000000 d slave_qns_gem_noc_cnoc
0000000000000000 d slave_qns_gemnoc_sf
0000000000000000 d slave_qns_gemnoc_sf_hw_nodes
0000000000000000 d slave_qns_llcc
0000000000000000 d slave_qns_llcc_hw_nodes
0000000000000000 d slave_qns_mem_noc_hf
0000000000000000 d slave_qns_mem_noc_hf_hw_nodes
0000000000000000 d slave_qns_nsp_gemnoc
0000000000000000 d slave_qns_nsp_gemnoc_hw_nodes
0000000000000000 d slave_qup0_core_slave
0000000000000000 d slave_qup0_core_slave_hw_nodes
0000000000000000 d slave_qup1_core_slave
0000000000000000 d slave_qup1_core_slave_hw_nodes
0000000000000000 B smem_query_db
0000000000000000 D smmu_cfg
0000000000000000 T smmu_init
0000000000000fb8 t SPI_CONFIGURATION_DATA_SC7180
0000000000001578 t SPI_CONFIGURATION_DATA_SC7280
0000000000000a50 t SPI_CONFIGURATION_DATA_SDM845
0000000000000000 T SpmiBus_DeInit
0000000000000000 T SpmiBus_Init
0000000000000000 T SpmiBus_ReadLong
0000000000000000 T SpmiBus_WriteLong
0000000000000000 D spmiDevices
0000000000000000 B spmiDrv
0000000000000000 D spmiInfo
0000000000000000 b spmi_initialized
0000000000000000 T SpmiOs_Init
0000000000000000 T SpmiOs_Wait
0000000000001c40 T SYSINI_VERSION
0000000000001808 T SYSINI_VERSION_KRYO400GOLD
00000000000019b8 T SYSINI_VERSION_KRYO400SILVER
0000000000000000 D targetcfg_info
0000000000000000 R target_info
0000000000000000 D target_pcu_node
0000000000000000 T tcs_check_idle_HLOS
0000000000000000 T tcs_clean_sleep_wake
0000000000000000 t tcs_clean_up
0000000000000000 r tcs_config_tz
0000000000000000 T tcs_finish_active_amc
0000000000000000 T tcs_finish_amc
0000000000000000 T tcs_init
0000000000000008 C tcs_mode
0000000000000000 T tcs_prepare_sleep_add_cmd_set
0000000000000000 T tcs_prepare_sleep_commit
0000000000000000 T tcs_send
0000000000000000 t tcs_send_internal
0000000000000000 T tcs_size
0000000000000000 T tcs_slots_available
0000000000000000 T tcs_update_mode
0000000000000000 r temp_config_data
0000000000000000 T timer_qtimer_get_frames_list
0000000000000000 T timer_qtimer_read_time_raw
0000000000000000 T timer_qtimer_read_time_us
0000000000000000 T timer_qtimer_security_config
0000000000000000 T timer_sec_wdog_init
0000000000000000 T timer_sec_wdog_pet
0000000000000000 T timer_sec_wdog_start
0000000000000000 T timer_sec_wdog_stop
0000000000000000 t timer_sec_wdt_bark_handler
0000000000000000 T Tlmm_Init
0000000000000000 T Tlmm_PlatformInit
0000000000000000 D trans_bases_kodiak
0000000000000000 T translate_address
0000000000000000 d TuringMMUTBU0PD
0000000000000000 d TuringMMUTBU1PD
0000000000000008 C tz_completion_cb
0000000000000008 C tz_timeout_cb
0000000000000000 T update_addr_translation
0000000000000000 T vmidmt_ClearError
0000000000000000 T vmidmt_config
0000000000000000 t _vmidmt_ConfigCtxt.isra.4
0000000000000000 T vmidmt_ConfigErrRep
0000000000000000 T vmidmt_config_options
0000000000000000 T vmidmt_config_options_per_master
0000000000000000 T vmidmt_ConfigSSDT
0000000000000000 T vmidmt_ConfigVmidCtxt
0000000000000000 T vmidmt_ConfigVmidCtxtWithSIDList
0000000000000000 T vmidmt_config_vmids
0000000000000000 T vmidmt_EnableClientP
0000000000000000 d vmidmt_err_cfg_nonsec_ctx
0000000000000000 d vmidmt_err_cfg_sec_ctx
0000000000000000 d vmidmt_err_clt_nonsec_ctx
0000000000000000 b vmidmt_err_clt_sec_ctx
0000000000000000 t vmidmt_error_handler
0000000000000000 D vmidmt_err_pos_to_hal_map
0000000000000000 T vmidmt_GetError
0000000000000000 T vmidmt_getInfo_index
0000000000000000 T vmidmt_Init
0000000000000000 T vmidmt_IsError
0000000000000000 T vmidmt_map_multisid_vmid_internal
0000000000000000 T vmidmt_map_vmid_internal
0000000000000000 T vmidmt_register_interrupts
0000000000000000 T vmidmt_Reset
0000000000000000 T vmidmt_Restore
0000000000000000 T vmidmt_Save
0000000000000000 t _vmidmt_SetDefaultConfig.isra.0.part.1
0000000000000000 t _vmidmt_ShiftCtxt.isra.2
00000000000001fc t wa_end
00000000000001a8 t wa_r0p0_start
00000000000001cc t wa_r1p0_start
00000000000001f4 t wa_r1p1_start
0000000000000158 t wa_start
0000000000000000 d wpss_mpu_addr
0000000000000000 d wpss_mpu_rgs
0000000000000000 T write_output_payload_word
0000000000000000 T write_output_payload_word_at_offset
0000000000000000 d XOVoteDomain
0000000000000000 T XpuEnableDomains
0000000000000000 D xpu_err_non_sec_ctx
0000000000000000 D xpu_err_pos_to_hal_map
0000000000000000 B xpu_err_sec_ctx
0000000000000000 T XpuLockDownAssetDynamically
0000000000000000 T XpuLockDownAssets
0000000000000000 T XpuMasterMPuInit
0000000000000000 R xpu_non_sec_intr_en_reg
0000000000000000 R xpu_non_sec_intr_status_reg
0000000000000000 T XpuProgramMPUPartitions
0000000000000000 T XpuProgramMPUPartitionsDynamicPerm
0000000000000000 T XpuProgramMPUPartitionsPerm
0000000000000000 T xpu_register_interrupts
0000000000000000 R xpu_sec_intr_en_reg
0000000000000000 R xpu_sec_intr_status_reg
0000000000000000 T XpuSetRGOwnership
0000000000000000 T xpu_static_config
*/
#include "qtiseclib.h"
#include "defs.h"
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
__int64 ac_init()
{
  __int64 result; // x0

  vmidmt_config();
  if ( (unsigned int)xpu_static_config() )
    qtisec_assert("noship_src/drivers/accesscontrol/ac_init.c", 0x57u, "0 == xpu_static_config()");
  result = xpu_register_interrupts();
  if ( (_DWORD)result )
    qtisec_assert("noship_src/drivers/accesscontrol/ac_init.c", 0x59u, "0 == xpu_register_interrupts()");
  return result;
}



__int64 __fastcall ACQCGetxPUType(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 1016LL) & 3;
}



__int64 ACTzTargetConfig()
{
  __int64 result; // x0

  result = 31457288LL;
  MEMORY[0x1E00008] = 271;
  return result;
}



__int64 __fastcall calculate_cpumasks(__int64 result)
{
  int *v1; // x1
  char v2; // w2
  __int64 i; // x2
  int v4; // t1

  v1 = &dword_1A61C;
  v2 = ~(unsigned __int8)((unsigned __int64)MEMORY[0x78018C] >> 7);
  dword_1A624 = v2 & 0xF;
  dword_1A62C = v2 & 0x70;
  dword_1A634 = v2 & 0x80;
  for ( i = 0LL; i != 16; i += 4LL )
  {
    v4 = *v1;
    v1 += 2;
    *(_DWORD *)(result + i) = v4;
  }
  return result;
}



__int64 __fastcall check_dupRegion(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        int a8)
{
  int v9; // w7
  __int64 *v10; // x5
  unsigned int v11; // w8
  char v12; // w11
  __int64 *v13; // x9
  __int64 v14; // x12
  unsigned int v15; // w10
  __int64 v16; // x1
  unsigned __int64 v17; // x0
  __int64 v18; // x2
  unsigned int i; // w0
  unsigned int v20; // w6
  __int64 v21; // x1
  char *v22; // x2
  unsigned __int64 v23; // x1
  unsigned __int64 v24; // x0
  __int64 v25; // x2
  unsigned __int64 v27[2]; // [xsp+10h] [xbp+10h] BYREF
  char v28; // [xsp+20h] [xbp+20h]
  unsigned __int64 v29[2]; // [xsp+28h] [xbp+28h] BYREF
  char v30; // [xsp+38h] [xbp+38h]

  if ( (unsigned int)compare_ch_segments(a1, a2, a3, a4, a5, a6, a7, a8) )
  {
    return (unsigned int)-1;
  }
  else
  {
    v9 = 1;
    v10 = addr_trans_segs;
    v11 = 0;
    v12 = 1;
    v13 = addr_trans_segs;
    v14 = 24LL;
    v15 = *(_DWORD *)(a1 + 24);
    while ( v9 != v15 )
    {
      if ( !*((_BYTE *)v10 + 16) )
      {
        v16 = *v10;
        v17 = v10[3];
        if ( *v10 >= v17 )
          return (unsigned int)-1;
        v18 = v10[1];
        v28 = v12;
        v27[0] = v18 + v16;
        v27[1] = v17 - v16;
        for ( i = v9; i < v15; i = v20 )
        {
          v20 = i + 1;
          v21 = i * v14;
          v22 = (char *)v13 + v21;
          if ( !*((_BYTE *)v13 + v21 + 16) )
          {
            v23 = *(__int64 *)((char *)v13 + v21);
            v24 = *(__int64 *)((char *)v13 + v20 * v14);
            if ( v23 >= v24 )
              return (unsigned int)-1;
            v25 = *((_QWORD *)v22 + 1);
            v30 = v12;
            v29[0] = v25 + v23;
            v29[1] = v24 - v23;
            if ( check_overlap(v27, v29) )
              return (unsigned int)-1;
          }
        }
      }
      v10 += 3;
      ++v9;
    }
  }
  return v11;
}



__int64 __fastcall check_for_events(__int64 a1, int a2)
{
  __int64 result; // x0
  __int64 v5; // x19
  int v6; // w0
  unsigned int *v7[3]; // [xsp+38h] [xbp+38h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 32), v7);
  while ( 1 )
  {
    result = inq_it_deref((__int64)v7);
    v5 = result;
    if ( !result )
      return result;
    v6 = *(_DWORD *)(result + 16);
    if ( v6 == 1 )
    {
      if ( *(_DWORD *)v5 >= *(_DWORD *)(a1 + 52) )
        goto LABEL_9;
LABEL_8:
      rpmh_event_set(*(_QWORD *)(v5 + 8));
      inq_it_delete(v7);
      qtiseclib_cb_memset(v5, 0LL, 32LL);
      inq_append(*(unsigned int **)(a1 + 40), v5);
      inq_it_begin(*(_QWORD *)(a1 + 32), v7);
    }
    else
    {
      if ( !v6 && *(_DWORD *)v5 == a2 )
        goto LABEL_8;
LABEL_9:
      inq_it_next(v7);
    }
  }
}



bool __fastcall check_overlap(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // x2
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x4
  _BOOL8 result; // x0

  v2 = *a1;
  v3 = *a2;
  if ( *a1 >= *a2 || (v4 = a1[1], result = 0LL, v3 < v2 + v4) )
  {
    result = 1LL;
    if ( v2 > v3 )
      return v2 < v3 + a2[1];
  }
  return result;
}



__int64 __fastcall Clock_DisableClock(__int64 a1)
{
  int v2; // w0
  __int64 v3; // x0
  int v4; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  qtiseclib_cb_spin_lock(&ClockMutex);
  v2 = *(_DWORD *)(a1 + 48);
  if ( v2 )
  {
    *(_DWORD *)(a1 + 48) = v2 - 1;
    if ( v2 == 1 )
    {
      HAL_clk_DisableClock(a1 + 8);
      Clock_DisableClockDomain(*(_QWORD *)(a1 + 32));
      v3 = *(_QWORD *)(a1 + 40);
      if ( v3 )
      {
        v4 = *(_DWORD *)(v3 + 16);
        if ( v4 )
        {
          *(_DWORD *)(v3 + 16) = v4 - 1;
          if ( v4 == 1 )
            HAL_clk_DisablePowerDomain((_DWORD **)v3);
        }
      }
    }
  }
  qtiseclib_cb_spin_unlock(&ClockMutex);
  return 0LL;
}



__int64 __fastcall Clock_DisableClockDomain(__int64 a1)
{
  int v1; // w1
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_DWORD *)(a1 + 48);
  if ( !v1 )
    return 0LL;
  *(_DWORD *)(a1 + 48) = v1 - 1;
  if ( v1 != 1 )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 40);
  if ( v3 )
    Clock_DisableSource(v3);
  v4 = *(_QWORD *)(a1 + 32);
  if ( v4 )
    Clock_VoltageRequest(*(_DWORD *)(v4 + 16), 0);
  return 0LL;
}



__int64 __fastcall Clock_DisableClockGroup(unsigned int a1)
{
  __int64 v1; // x29
  __int64 v3; // x24
  __int64 result; // x0
  unsigned __int64 v5; // x23
  __int64 v6; // x19
  __int64 v7; // x3
  __int64 v8; // x4
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7
  int v12; // w0
  unsigned int v13; // w20
  unsigned __int64 i; // x20
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned __int64 j; // x20
  unsigned __int64 k; // x20
  __int64 v19; // x0
  __int64 v20; // x2
  unsigned __int64 m; // x20
  __int64 v22; // x0
  unsigned __int64 n; // x20
  _QWORD *v24; // x0
  int v25; // w3
  __int64 v26; // [xsp+0h] [xbp-50h]
  __int64 v27[2]; // [xsp+40h] [xbp-10h] BYREF

  if ( a1 > 4 )
    return 0xFFFFFFFFLL;
  v26 = v1;
  v3 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_8);
  result = 0xFFFFFFFFLL;
  if ( v3 )
  {
    v5 = (unsigned __int64)a1 << 6;
    v6 = v3 + v5;
    if ( *(_QWORD *)(v3 + v5) )
    {
      qtiseclib_cb_spin_lock(&ClockMutex);
      v12 = *(_DWORD *)(v6 + 40);
      if ( v12 )
      {
        *(_DWORD *)(v6 + 40) = v12 - 1;
        if ( v12 == 1 )
        {
          v13 = *(_DWORD *)(v6 + 44);
          v27[0] = 0LL;
          v27[1] = 0LL;
          for ( i = *(_QWORD *)(v3 + v5) + 24LL * v13 - 24; i >= *(_QWORD *)v6; i -= 24LL )
          {
            if ( !*(_DWORD *)(i + 16) )
              HAL_clk_DisableClock(i);
          }
          v15 = *(_QWORD *)(v6 + 8);
          if ( v15 )
          {
            for ( j = v15 + 16LL * *(unsigned int *)(v6 + 48) - 16; j >= *(_QWORD *)(v6 + 8); j -= 16LL )
            {
              if ( !*(_DWORD *)(j + 8) )
                HAL_clk_DisablePowerDomain((_DWORD **)j);
            }
          }
          v16 = *(_QWORD *)(v6 + 16);
          if ( v16 )
          {
            for ( k = v16 + 24LL * *(unsigned int *)(v6 + 52) - 24; k >= *(_QWORD *)(v6 + 16); k -= 24LL )
            {
              if ( !*(_DWORD *)(k + 16) )
                HAL_clk_DisableClock(k);
            }
          }
          v19 = *(_QWORD *)(v6 + 24);
          if ( v19 )
          {
            v20 = 24LL;
            for ( m = v19 + 24LL * *(unsigned int *)(v6 + 56) - 24; m >= *(_QWORD *)(v6 + 24); m -= 24LL )
            {
              v24 = *(_QWORD **)(m + 16);
              if ( v24 )
                icbuarb_issue_request(v24, v27, v20, v7, v8, v9, v10, v11, v26);
            }
          }
          v22 = *(_QWORD *)(v6 + 32);
          if ( v22 )
          {
            for ( n = v22 + 24LL * *(unsigned int *)(v6 + 60) - 24; n >= *(_QWORD *)(v6 + 32); n -= 24LL )
            {
              v25 = *(_DWORD *)(n + 12);
              if ( v25 )
                rpmh_issue_command(qword_1A528, 0, 1, v25, 0);
            }
          }
        }
      }
      qtiseclib_cb_spin_unlock(&ClockMutex);
      return 0LL;
    }
  }
  return result;
}



__int64 __fastcall Clock_EnableClock(__int64 a1)
{
  int v2; // w0
  int **v3; // x21
  __int64 v4; // x19
  int v5; // w0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  qtiseclib_cb_spin_lock(&ClockMutex);
  v2 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v2 + 1;
  if ( v2
    || ((v3 = (int **)(a1 + 8),
         Clock_EnableClockDomain(*(_QWORD *)(a1 + 32)),
         HAL_clk_EnableClock(a1 + 8),
         (v4 = *(_QWORD *)(a1 + 40)) == 0)
     || (v5 = *(_DWORD *)(v4 + 16), *(_DWORD *)(v4 + 16) = v5 + 1, v5)
     || (HAL_clk_EnablePowerDomain(v4), (unsigned int)HAL_clk_WaitForPowerDomainOn((_DWORD **)v4)))
    && (unsigned int)HAL_clk_WaitForClockOn(v3) )
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0LL;
  }
  else
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0xFFFFFFFFLL;
  }
}



__int64 __fastcall Clock_EnableClockDomain(__int64 a1)
{
  int v1; // w1
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v1 + 1;
  if ( v1 )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 32);
  if ( v3 )
    Clock_VoltageRequest(0, *(_DWORD *)(v3 + 16));
  v4 = *(_QWORD *)(a1 + 40);
  if ( v4 )
    Clock_EnableSource(v4);
  return 0LL;
}



__int64 __fastcall Clock_EnableClockGroup(unsigned int a1)
{
  __int64 v1; // x29
  __int64 v2; // x23
  unsigned __int64 v3; // x21
  __int64 v4; // x19
  __int64 v5; // x2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  int v11; // w0
  __int64 v12; // x20
  __int64 v13; // x20
  __int64 v14; // x0
  int v15; // w0
  int v16; // w3
  int v17; // w4
  unsigned int v18; // w0
  int **v19; // x20
  __int64 client; // x0
  __int64 v21; // x0
  _QWORD *v22; // x20
  __int64 v23; // x0
  _QWORD *v24; // x24
  _DWORD **v25; // x0
  _QWORD *v26; // x24
  __int64 v27; // x0
  int **i; // x19
  int **v29; // x0
  __int64 v31; // [xsp+0h] [xbp-60h]
  __int64 v32; // [xsp+50h] [xbp-10h] BYREF
  __int64 v33; // [xsp+58h] [xbp-8h]

  if ( a1 > 4 )
    return 0xFFFFFFFFLL;
  v31 = v1;
  v2 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_8);
  if ( v2 )
  {
    v3 = (unsigned __int64)a1 << 6;
    v4 = v2 + v3;
    if ( *(_QWORD *)(v2 + v3) )
    {
      qtiseclib_cb_spin_lock(&ClockMutex);
      v11 = *(_DWORD *)(v4 + 40);
      *(_DWORD *)(v4 + 40) = v11 + 1;
      if ( v11 )
        goto LABEL_43;
      v12 = *(_QWORD *)(v4 + 32);
      v32 = 0LL;
      v33 = 0LL;
      if ( v12 )
      {
        *(_DWORD *)(v4 + 60) = 0;
        while ( 1 )
        {
          v14 = *(_QWORD *)v12;
          if ( !*(_QWORD *)v12 )
            break;
          ++*(_DWORD *)(v4 + 60);
          if ( !*(_DWORD *)(v12 + 12) )
          {
            *(_DWORD *)(v12 + 12) = cmd_db_query_addr(v14);
            v15 = pwr_utils_hlvl_named_resource(*(_QWORD *)v12, *(_DWORD *)(v12 + 8), 0LL);
            *(_DWORD *)(v12 + 16) = v15;
            if ( !*(_DWORD *)(v12 + 12) )
            {
              v15 = 0;
              *(_DWORD *)cortex_a78_aarch64_sysini = 0;
              __break(0x3E8u);
            }
            if ( v15 == -1 )
            {
              *(_DWORD *)cortex_a78_aarch64_sysini = 0;
              __break(0x3E8u);
            }
          }
          v16 = *(_DWORD *)(v12 + 12);
          v17 = *(_DWORD *)(v12 + 16);
          v12 += 24LL;
          v18 = rpmh_issue_command(qword_1A528, 0, 1, v16, v17);
          rpmh_barrier_single(qword_1A528, v18);
        }
      }
      v13 = *(_QWORD *)(v4 + 24);
      if ( v13 )
      {
        *(_DWORD *)(v4 + 56) = 0;
        while ( *(_DWORD *)(v13 + 8) )
        {
          ++*(_DWORD *)(v4 + 56);
          if ( !*(_QWORD *)(v13 + 16) )
          {
            client = icbuarb_create_client(*(_DWORD *)v13, *(_DWORD *)(v13 + 4));
            *(_QWORD *)(v13 + 16) = client;
            if ( !client )
              qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0x255u, "pICB->hICB");
          }
          v21 = *(unsigned int *)(v13 + 8);
          v13 += 24LL;
          v32 = v21;
          v33 = v21;
          icbuarb_issue_request(*(_QWORD **)(v13 - 8), &v32, v5, v6, v7, v8, v9, v10, v31);
        }
      }
      v19 = *(int ***)(v4 + 16);
      if ( v19 )
      {
        *(_DWORD *)(v4 + 52) = 0;
        while ( *v19 )
        {
          ++*(_DWORD *)(v4 + 52);
          HAL_clk_EnableClock((__int64)v19);
          if ( !(unsigned int)HAL_clk_WaitForClockOn(v19) )
            goto LABEL_42;
          v19 += 3;
        }
      }
      v22 = *(_QWORD **)(v4 + 8);
      if ( v22 )
      {
        *(_DWORD *)(v4 + 48) = 0;
        while ( *v22 )
        {
          ++*(_DWORD *)(v4 + 48);
          v23 = (__int64)v22;
          v22 += 2;
          HAL_clk_EnablePowerDomain(v23);
        }
        v24 = *(_QWORD **)(v4 + 8);
        LODWORD(v22) = 0;
        while ( *v24 )
        {
          v25 = (_DWORD **)v24;
          v24 += 2;
          LODWORD(v22) = (unsigned int)v22 | ((unsigned int)HAL_clk_WaitForPowerDomainOn(v25) == 0);
        }
      }
      v26 = *(_QWORD **)(v2 + v3);
      *(_DWORD *)(v4 + 44) = 0;
      while ( *v26 )
      {
        ++*(_DWORD *)(v4 + 44);
        v27 = (__int64)v26;
        v26 += 3;
        HAL_clk_EnableClock(v27);
      }
      for ( i = *(int ***)(v2 + v3); *i; i += 3 )
      {
        v29 = i;
        LODWORD(v22) = (unsigned int)v22 | ((unsigned int)HAL_clk_WaitForClockOn(v29) == 0);
      }
      if ( !(_DWORD)v22 )
      {
LABEL_43:
        qtiseclib_cb_spin_unlock(&ClockMutex);
        return 0LL;
      }
LABEL_42:
      qtiseclib_cb_spin_unlock(&ClockMutex);
    }
  }
  return 0xFFFFFFFFLL;
}



__int64 __fastcall Clock_EnableDFS(__int64 a1)
{
  unsigned __int64 v1; // x19
  __int64 result; // x0
  __int64 i; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 32);
  result = 0xFFFFFFFFLL;
  if ( v1 )
  {
    if ( *(_DWORD *)(v1 + 16) )
    {
      result = 0LL;
      if ( (*(_DWORD *)(v1 + 56) & 0x800000) == 0 )
      {
        for ( i = *(_QWORD *)(v1 + 24) + 4LL; *(_DWORD *)(i - 4); i += 24LL )
        {
          if ( *(unsigned __int8 *)(i + 10) != 255 )
            HAL_clk_ConfigDFSMux(v1, i);
        }
        HAL_clk_EnableDFS(v1);
        *(_DWORD *)(v1 + 56) |= 0x800000u;
        return 0LL;
      }
    }
  }
  return result;
}



__int64 __fastcall Clock_EnableSource(__int64 a1)
{
  unsigned int v1; // w20
  int v3; // w0

  if ( !a1 || *(_QWORD *)(a1 + 32) && (unsigned int)Clock_EnableSource() )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 16);
    v1 = 0;
    *(_DWORD *)(a1 + 16) = v3 + 1;
    if ( !v3 )
    {
      v1 = 0;
      if ( !*(_QWORD *)(a1 + 24) )
        HAL_clk_EnableSource((__int64 *)a1);
    }
  }
  return v1;
}



__int64 __fastcall Clock_GetClockId(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  _QWORD *v5; // x20
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD **)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_10);
  result = 0xFFFFFFFFLL;
  if ( v5 )
  {
    while ( *v5 )
    {
      result = qtiseclib_cb_strcmp(a1);
      if ( !(_DWORD)result )
      {
        *a2 = v5;
        return result;
      }
      v5 += 7;
    }
    result = 0xFFFFFFFFLL;
    *a2 = 0LL;
  }
  return result;
}



__int64 __fastcall Clock_GetFrequencyPlan(__int64 a1, unsigned __int64 *a2, unsigned int *a3)
{
  bool v3; // zf
  __int64 v5; // x22
  __int64 result; // x0
  __int64 v7; // x0
  unsigned int v8; // w20
  unsigned __int64 v11; // x0
  _DWORD *v12; // x2
  __int64 i; // x0

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( !v3 && a1 != 0 )
  {
    v5 = *(_QWORD *)(a1 + 32);
    result = 0xFFFFFFFFLL;
    if ( !v5 )
      return result;
    v7 = *(_QWORD *)(v5 + 24);
    v8 = 0;
    if ( !v7 )
    {
      *a3 = 0;
      return 0LL;
    }
    while ( *(_DWORD *)v7 )
    {
      if ( (*(_DWORD *)(v5 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(v7 + 14) != 255 )
        ++v8;
      v7 += 24LL;
    }
    if ( *a2 || (*a3 = v8, v11 = qtisec_malloc(4LL * (v8 & 0x3FFFFFFF)), (*a2 = v11) != 0) )
    {
      if ( v8 <= *a3 )
      {
        v12 = (_DWORD *)*a2;
        for ( i = *(_QWORD *)(v5 + 24); *(_DWORD *)i; i += 24LL )
        {
          if ( (*(_DWORD *)(v5 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(i + 14) != 255 )
            *v12++ = *(_DWORD *)i;
        }
        *a3 = v8;
        return 0LL;
      }
      *a3 = v8;
    }
    else
    {
      *a3 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}



__int64 __fastcall Clock_GetRPMId(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  _QWORD *v4; // x19
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD **)ClockDrvCtxt[0];
  if ( *(_QWORD *)ClockDrvCtxt[0] )
  {
    while ( *v4 )
    {
      result = qtiseclib_cb_strcmp(a1);
      if ( !(_DWORD)result )
      {
        *a2 = v4;
        return result;
      }
      v4 += 3;
    }
  }
  return 0xFFFFFFFFLL;
}



__int64 Clock_Init()
{
  __int64 result; // x0

  result = (unsigned __int8)byte_1A500;
  if ( !byte_1A500 )
  {
    Clock_InitRPMh();
    if ( (unsigned int)Clock_InitImage((__int64)ClockDrvCtxt) )
      qtisec_assert(
        "noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c",
        0x307u,
        "0 == Clock_InitImage(&ClockDrvCtxt)");
    result = 1LL;
    byte_1A500 = 1;
  }
  return result;
}



__int64 __fastcall Clock_InitImage(__int64 a1)
{
  __int64 v1; // x20
  unsigned int v2; // w21
  int v3; // w20

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 24LL) + 40LL;
  MEMORY[0x171154] = MEMORY[0x171154] & 0x81F0000E | 1;
  while ( (MEMORY[0x171154] & 0x80000000) != 0 )
    qtiseclib_cb_udelay(1LL);
  Clock_EnableClockGroup(2u);
  Clock_EnableClockGroup(3u);
  if ( (MEMORY[0x339B024] & 1) != 0 )
  {
    bSSCGDSCPrevEnabled = 0;
    MEMORY[0x339B024] &= 0xF8FFFFFE;
    __dsb(0xFu);
    while ( (MEMORY[0x339B030] & 1) == 0 )
      ;
    while ( (MEMORY[0x380101C] & 0x80000000) != 0 )
      ;
  }
  else
  {
    bSSCGDSCPrevEnabled = 1;
  }
  Clock_EnableClockGroup(4u);
  MEMORY[0x3D91098] = MEMORY[0x3D91098] & 0x81E07FFC | 1;
  MEMORY[0x3D91204] = MEMORY[0x3D91204] & 0x81E0000C | 1;
  MEMORY[0x3D9E110] |= 1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D91074] = MEMORY[0x3D91074] & 0x7FFF0 | 1;
  MEMORY[0x3D9106C] &= 0xF8FFFFFE;
  while ( (MEMORY[0x3D9106C] & 0x80000000) == 0 )
    ;
  MEMORY[0x3D91510] = 2;
  MEMORY[0x3D9E120] = MEMORY[0x3D9E120] & 0xFFFFFE00 | 0x1F4;
  MEMORY[0x3D91014] = MEMORY[0x3D91014] & 0x7FF0F | 0x70;
  MEMORY[0x3D91008] = 1;
  MEMORY[0x3D91160] = 1;
  MEMORY[0x3D98004] = 1;
  qtiseclib_cb_udelay(150LL);
  MEMORY[0x3D91008] = 0;
  MEMORY[0x3D91160] = 0;
  MEMORY[0x3D98004] = 0;
  MEMORY[0x3D9158C] = MEMORY[0x3D9158C] & 0x3C0001 | 0x10;
  qtiseclib_cb_udelay(1LL);
  MEMORY[0x3D9158C] &= 0x3C0001u;
  MEMORY[0x3D9158C] &= 0x3C0010u;
  MEMORY[0x3D9100C] &= 0xF8FFFFFE;
  while ( (MEMORY[0x3D9100C] & 0x80000000) == 0 )
    ;
  MEMORY[0x3D94004] &= 0x3000800u;
  MEMORY[0x3D94000] &= 0x3000800u;
  MEMORY[0x106100] &= ~4u;
  MEMORY[0x153000] = MEMORY[0x153000] & 2;
  MEMORY[0x15301C] = MEMORY[0x15301C] & 2;
  MEMORY[0x153018] = MEMORY[0x153018] & 2;
  MEMORY[0x153010] = MEMORY[0x153010] & 2;
  MEMORY[0x153014] = MEMORY[0x153014] & 2;
  MEMORY[0x153008] = MEMORY[0x153008] & 2;
  MEMORY[0x153004] = MEMORY[0x153004] & 2;
  MEMORY[0x106100] |= 0x800u;
  MEMORY[0x153000] = MEMORY[0x153000] & 1 | 2;
  MEMORY[0x15301C] = MEMORY[0x15301C] & 1 | 2;
  MEMORY[0x153010] = MEMORY[0x153010] & 1 | 2;
  MEMORY[0x153014] = MEMORY[0x153014] & 1 | 2;
  MEMORY[0x153008] = MEMORY[0x153008] & 1 | 2;
  MEMORY[0x153004] = MEMORY[0x153004] & 1 | 2;
  MEMORY[0x153018] = MEMORY[0x153018] & 1 | 2;
  MEMORY[0x3D94004] = MEMORY[0x3D94004] & 0x3000004 | 0x800;
  MEMORY[0x3D94000] = MEMORY[0x3D94000] & 0x3000004 | 0x800;
  MEMORY[0x190004] = MEMORY[0x190004] & 0x81F03FFF | 0x4000;
  MEMORY[0x190010] = MEMORY[0x190010] & 0x81F03FFE | 0x4000;
  MEMORY[0x190020] = MEMORY[0x190020] & 0x81F03FFF | 0x4000;
  MEMORY[0x190028] = MEMORY[0x190028] & 0x81F03FFF | 0x4000;
  MEMORY[0x183008] = MEMORY[0x183008] & 0x81F03FFF | 0x4000;
  MEMORY[0x17100C] = MEMORY[0x17100C] & 0x81F03FFF | 0x4000;
  v2 = Clock_EnableSource(v1);
  if ( v2 )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = 500;
    MEMORY[0x1FD3300] = 1;
    MEMORY[0x18A2A4] = 0;
    MEMORY[0x18A00C] &= 0x81F0000E;
    MEMORY[0x18A000] = MEMORY[0x18A000] & 0x81F0000E | 1;
    if ( (MEMORY[0x18A000] & 2) == 0 )
    {
      while ( (MEMORY[0x18A000] & 0x80000000) != 0 )
      {
        qtiseclib_cb_udelay(1LL);
        if ( !--v3 )
          return v2;
      }
    }
    MEMORY[0x4180044] = 1;
    qtiseclib_cb_udelay(100LL);
    MEMORY[0xC2B0000] |= 1u;
    qtiseclib_cb_udelay(300LL);
    MEMORY[0xC2B0000] &= ~1u;
    qtiseclib_cb_udelay(100LL);
    MEMORY[0x4180044] = 0;
    MEMORY[0x18A000] &= 0x81F0000E;
    MEMORY[0x3D9152C] = 0;
  }
  return v2;
}



__int64 Clock_InitRPMh()
{
  int addr; // w23
  int v1; // w22
  int v2; // w21
  unsigned int v3; // w0

  qword_1A528 = rpmh_create_handle(0, (__int64)"clock");
  dword_1A530 = pwr_utils_lvl_resource_idx((__int64)"cx.lvl");
  dword_1A534 = pwr_utils_lvl_resource_idx((__int64)"mx.lvl");
  addr = cmd_db_query_addr((__int64)"cx.lvl");
  v1 = cmd_db_query_addr((__int64)"mx.lvl");
  v2 = cmd_db_query_addr((__int64)"xo.lvl");
  if ( !qword_1A528 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC5u, "pDrvCtxt->hRPMh != 0");
  if ( dword_1A530 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC6u, "pDrvCtxt->nCXLVLIdx != -1");
  if ( !addr )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC7u, "nCXAddr");
  if ( !v1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC8u, "nMXAddr");
  if ( !v2 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC9u, "nXOAddr");
  dword_1A544 = addr;
  dword_1A550 = v1;
  v3 = rpmh_issue_command(qword_1A528, 0, 1, v2, 3);
  return rpmh_barrier_single(qword_1A528, v3);
}



__int64 Clock_IsBSPSupported()
{
  return 1LL;
}



__int64 __fastcall Clock_IsClockOn(__int64 a1, _BYTE *a2)
{
  bool v2; // zf
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  result = HAL_clk_IsClockOn((int **)(a1 + 8));
  if ( (_DWORD)result )
  {
    *a2 = 1;
    return 0LL;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}



__int64 __fastcall Clock_IsClockPowerDomainOn(__int64 a1, _BYTE *a2)
{
  bool v2; // zf
  _DWORD **v3; // x0
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD ***)(a1 + 40);
  if ( !v3 || (result = HAL_clk_IsPowerDomainOn(v3), (_DWORD)result) )
  {
    *a2 = 1;
    return 0LL;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}



__int64 Clock_PostInitImage()
{
  MEMORY[0x3D9100C] = MEMORY[0x3D9100C] & 0xF8FFFFFE | 1;
  MEMORY[0x3D98004] = 1;
  qtiseclib_cb_udelay(150LL);
  MEMORY[0x3D9158C] = MEMORY[0x3D9158C] & 0x3C0010 | 1;
  while ( (MEMORY[0x3D9100C] & 0x80000000) != 0 )
    ;
  MEMORY[0x3D9106C] = MEMORY[0x3D9106C] & 0xF8FFFFFE | 1;
  while ( (MEMORY[0x3D9106C] & 0x80000000) != 0 )
    ;
  Clock_DisableClockGroup(4u);
  if ( !bSSCGDSCPrevEnabled )
  {
    MEMORY[0x339B024] = MEMORY[0x339B024] & 0xF8FFFFFE | 1;
    __dsb(0xFu);
    while ( (MEMORY[0x339B024] & 0x80000000) != 0 )
      ;
  }
  Clock_DisableClockGroup(3u);
  Clock_DisableClockGroup(2u);
  return 0LL;
}



__int64 Clock_RPMRequest()
{
  return 0LL;
}



__int64 __fastcall Clock_SetClockFrequency(__int64 a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w1
  __int64 v4; // x19
  __int64 result; // x0
  __int64 v6; // x20
  unsigned int v7; // w3
  __int64 v8; // x21
  unsigned int v9; // w0
  unsigned int v10; // w1
  unsigned int v11; // w0
  unsigned int v12; // w1
  __int64 v13; // x0
  bool v14; // zf
  int v15; // w0

  v3 = 1000 * a2;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 32);
  result = 0xFFFFFFFFLL;
  if ( v4 )
  {
    v6 = *(_QWORD *)(v4 + 24);
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)v6;
        if ( !*(_DWORD *)v6 )
          return 0xFFFFFFFFLL;
        if ( v3 <= v7 && ((*(_DWORD *)(v4 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(v6 + 14) != 255) )
          break;
        v6 += 24LL;
      }
      result = 0xFFFFFFFFLL;
      if ( *(_DWORD *)(v6 + 4) <= 2u )
      {
        if ( a3 )
          *a3 = v7 / 0x3E8;
        result = 0LL;
        if ( v6 != *(_QWORD *)(v4 + 32) )
        {
          qtiseclib_cb_spin_lock(&ClockMutex);
          v8 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_18) + 40LL * *(unsigned int *)(v6 + 4);
          if ( *(_DWORD *)(v4 + 48) )
          {
            v9 = *(_DWORD *)(v4 + 52);
            v10 = *(_DWORD *)(v6 + 16);
            if ( v10 > v9 )
              Clock_VoltageRequest(v9, v10);
            if ( v8 != *(_QWORD *)(v4 + 40) )
              Clock_EnableSource(v8);
          }
          if ( (*(_DWORD *)(v4 + 56) & 0x800000) == 0 )
            HAL_clk_ConfigClockMux((_DWORD *)v4, (unsigned int *)(v6 + 4));
          if ( *(_DWORD *)(v4 + 48) )
          {
            v11 = *(_DWORD *)(v4 + 52);
            v12 = *(_DWORD *)(v6 + 16);
            if ( v12 < v11 )
              Clock_VoltageRequest(v11, v12);
            v13 = *(_QWORD *)(v4 + 40);
            if ( v13 )
              v14 = v8 == v13;
            else
              v14 = 1;
            if ( !v14 )
              Clock_DisableSource(v13);
          }
          v15 = *(_DWORD *)(v6 + 16);
          *(_QWORD *)(v4 + 32) = v6;
          *(_QWORD *)(v4 + 40) = v8;
          *(_DWORD *)(v4 + 52) = v15;
          qtiseclib_cb_spin_unlock(&ClockMutex);
          return 0LL;
        }
      }
    }
  }
  return result;
}



__int64 __fastcall Clock_SetCXVoltage(int a1)
{
  int v1; // w22
  int v2; // w21
  int v3; // w20
  unsigned int v4; // w0

  v1 = aClockVRegMapping[a1];
  v2 = pwr_utils_hlvl(dword_1A530, v1, 0LL);
  v3 = pwr_utils_hlvl(dword_1A534, v1, 0LL);
  if ( v2 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xF5u, "nCXHLVL != -1");
  if ( v3 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xF6u, "nMXHLVL != -1");
  dword_1A548 = v2;
  dword_1A554 = v3;
  v4 = rpmh_issue_command_set(qword_1A528, dword_1A538);
  rpmh_barrier_single(qword_1A528, v4);
  return 0LL;
}



__int64 Clock_SetRPMAvailable()
{
  return 0LL;
}



__int64 Clock_TZInitDone()
{
  __int64 result; // x0

  result = Clock_PostInitImage();
  if ( (_DWORD)result )
    qtisec_assert(
      "noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c",
      0x317u,
      "0 == Clock_PostInitImage(&ClockDrvCtxt)");
  return result;
}



__int64 __fastcall Clock_WriteRegRegion(__int64 result)
{
  unsigned int i; // w1
  __int64 v2; // x3
  int v3; // w4

  for ( i = 0; i < *(_DWORD *)(result + 8); ++i )
  {
    v2 = 4LL * (i & 0x3FFFFFFF);
    v3 = *(_DWORD *)(*(_QWORD *)result + 4LL * i);
    *(_DWORD *)(v2 + *(_QWORD *)(result + 16)) = v3;
  }
  return result;
}



unsigned __int64 __fastcall cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1611595775 )
    return hoya_11_cluster_aarch64_sysini(result);
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    return hoya_20_cluster_aarch64_sysini(result);
  return hoya_10_cluster_aarch64_sysini(result);
}




__int64 __fastcall cmd_db_conv_str_to_unit64(__int64 a1)
{
  __int64 v2; // x2
  __int64 result; // x0
  unsigned __int8 v4; // w1
  char v5; // w3

  v2 = 0LL;
  result = 0LL;
  do
  {
    v4 = *(_BYTE *)(a1 + v2);
    if ( !v4 )
      break;
    v5 = 8 * v2++;
    result |= (unsigned __int64)v4 << v5;
  }
  while ( v2 != 8 );
  return result;
}



bool cmd_db_init()
{
  _BOOL4 v0; // w20
  char v2; // [xsp+4Bh] [xbp+4Bh] BYREF
  int v3; // [xsp+4Ch] [xbp+4Ch] BYREF

  v3 = 0;
  smem_query_db = cmd_db_target_mem_init(&v3);
  v0 = !smem_query_db
    || (cmd_db_prep_access(), *(_DWORD *)smem_query_db != 1)
    || *(_DWORD *)(smem_query_db + 4) != 201535707;
  cmd_db_access_done();
  if ( v0 )
    smem_query_db = 0LL;
  v2 = 32;
  cmd_db_test_addr = cmd_db_query_addr((__int64)"MC0");
  dword_1FCCC = cmd_db_query_addr((__int64)"mss.lvl");
  cmd_db_query_aux_data((__int64)"mss.lvl", &v2, (__int64)&cmd_db_test_data);
  cmd_db_test_priority = cmd_db_query_priority(cmd_db_test_addr, 0);
  dword_1FCBC = cmd_db_query_priority(dword_1FCCC, 1);
  dword_1FCC0 = cmd_db_query_priority_res_id((__int64)"cx.lvl", 0);
  dword_1FCC4 = cmd_db_query_priority_res_id((__int64)"cx.tmr", 1);
  return v0;
}




__int64 __fastcall cmd_db_query(__int64 a1, __int64 a2, __int64 a3)
{
  bool v5; // zf
  unsigned int v6; // w21
  int v7; // w0
  int v9; // w0
  __int64 v10; // x26
  int v11; // w0
  int v12; // w25
  int v13; // w21
  unsigned int v14; // w25
  __int64 v15; // x5
  unsigned __int16 *v16; // x4
  unsigned __int16 *v17; // x1
  unsigned int i; // w2
  int v19; // w0
  __int64 v20; // x3
  __int64 v21; // x22
  bool v22; // zf
  unsigned int v23; // w20
  unsigned int v24; // w2
  __int64 v25; // x1
  __int64 v26; // x21
  __int64 v27; // x2

  if ( !smem_query_db )
  {
LABEL_21:
    v6 = 1;
    goto LABEL_37;
  }
  if ( a1 )
    v5 = a2 == 0;
  else
    v5 = 1;
  v6 = 2;
  v7 = v5;
  if ( !v7 && (a3 || !*(_DWORD *)(a2 + 24)) )
  {
    v9 = *(_DWORD *)(a1 + 16);
    if ( !v9 )
    {
      v10 = cmd_db_conv_str_to_unit64(a1);
      goto LABEL_17;
    }
    if ( v9 == 1 )
    {
      v11 = *(_WORD *)(a1 + 14) & 0xF;
      if ( (unsigned int)(v11 - 3) <= 2 )
      {
        v10 = 0LL;
        *(_DWORD *)(a1 + 20) = v11;
LABEL_17:
        v12 = *(_DWORD *)(a1 + 20);
        cmd_db_prep_access();
        v13 = 0;
        v14 = v12 - 3;
        v15 = smem_query_db + 144;
        v16 = (unsigned __int16 *)(smem_query_db + 8);
        v17 = (unsigned __int16 *)(smem_query_db + 10);
        while ( v14 <= 2 && *v16 != *(_DWORD *)(a1 + 20) )
        {
LABEL_20:
          ++v13;
          v16 += 8;
          v17 += 8;
          if ( v13 == 8 )
            goto LABEL_21;
        }
        for ( i = 0; ; i = (unsigned __int16)(i + 1) )
        {
          if ( i >= v17[2] )
            goto LABEL_20;
          v19 = *(_DWORD *)(a1 + 16);
          v20 = *v17 + 24LL * i;
          v21 = v15 + v20;
          if ( v19 )
          {
            if ( v19 != 1 )
              continue;
            v22 = *(_DWORD *)(a1 + 12) == *(_DWORD *)(v21 + 16);
          }
          else
          {
            v22 = *(_QWORD *)(v15 + v20) == v10;
          }
          if ( v22 )
          {
            qtiseclib_cb_memcpy(a2, a1, 9LL);
            v23 = *(_DWORD *)(a2 + 24);
            v24 = *(unsigned __int16 *)(v21 + 20);
            v25 = smem_query_db;
            *(_DWORD *)(a2 + 12) = *(_DWORD *)(v21 + 16);
            v26 = v25 + 16LL * v13;
            *(_DWORD *)(a2 + 16) = *(_DWORD *)(v21 + 8);
            *(_DWORD *)(a2 + 20) = *(_DWORD *)(v21 + 12);
            *(_WORD *)(a2 + 28) = *(_WORD *)(v26 + 16);
            if ( v23 && v24 )
            {
              if ( v24 <= v23 )
                v23 = v24;
              v27 = *(unsigned __int16 *)(v26 + 12);
              v6 = 0;
              qtiseclib_cb_memcpy(a3, v25 + 144 + v27 + *(unsigned __int16 *)(v21 + 22), v23);
              *(_DWORD *)(a2 + 24) = v23;
            }
            else
            {
              v6 = 0;
              if ( v24 )
                *(_DWORD *)(a2 + 24) = v24;
            }
            goto LABEL_37;
          }
        }
      }
    }
    goto LABEL_21;
  }
LABEL_37:
  cmd_db_access_done();
  return v6;
}



__int64 __fastcall cmd_db_query_addr(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+38h] [xbp+38h]
  __int64 v5; // [xsp+40h] [xbp+40h]
  __int64 v6; // [xsp+48h] [xbp+48h]

  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)&v3, 0LL) )
    return 0LL;
  else
    return HIDWORD(v4);
}



__int64 __fastcall cmd_db_query_aux_data(__int64 a1, _BYTE *a2, __int64 a3)
{
  bool v3; // zf
  bool v4; // zf
  __int64 result; // x0
  __int64 v8[3]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v9[3]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v10; // [xsp+58h] [xbp+58h]

  if ( a3 )
    v3 = a2 == 0LL;
  else
    v3 = 1;
  v4 = v3 || a1 == 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0LL;
  memset(v8, 0, sizeof(v8));
  if ( v4 )
    return 2LL;
  qtiseclib_cb_memcpy(v8, a1, 9LL);
  LODWORD(v10) = (unsigned __int8)*a2;
  result = cmd_db_query((__int64)v8, (__int64)v9, a3);
  if ( !(_DWORD)result )
    *a2 = v10;
  return result;
}



__int64 __fastcall cmd_db_query_len(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3[3]; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+48h] [xbp+48h]

  memset(v3, 0, sizeof(v3));
  v4 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)v3, 0LL) )
    return 0LL;
  else
    return (unsigned int)v4;
}



__int64 __fastcall cmd_db_query_priority(int a1, char a2)
{
  __int64 v4; // [xsp+28h] [xbp+28h] BYREF
  int v5; // [xsp+30h] [xbp+30h]
  int v6; // [xsp+34h] [xbp+34h]
  __int64 v7; // [xsp+38h] [xbp+38h]
  __int64 v8[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v9; // [xsp+50h] [xbp+50h]
  __int64 v10; // [xsp+58h] [xbp+58h]

  v4 = 0LL;
  v5 = 0;
  v7 = 1LL;
  v6 = a1;
  v8[0] = 0LL;
  v8[1] = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  if ( (unsigned int)cmd_db_query((__int64)&v4, (__int64)v8, 0LL) )
    return 0LL;
  else
    return 2 * ((HIDWORD(v9) >> a2) & 1) + (((unsigned int)v9 >> a2) & 1);
}



__int64 __fastcall cmd_db_query_priority_res_id(__int64 a1, char a2)
{
  int v3; // w0
  unsigned int v4; // w1
  __int64 v6[3]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v7[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v8; // [xsp+50h] [xbp+50h]
  __int64 v9; // [xsp+58h] [xbp+58h]

  v7[0] = 0LL;
  v7[1] = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  memset(v6, 0, sizeof(v6));
  if ( a1 )
  {
    qtiseclib_cb_memcpy(v6, a1, 9LL);
    v3 = cmd_db_query((__int64)v6, (__int64)v7, 0LL);
    v4 = 0;
    if ( !v3 )
      return 2 * ((HIDWORD(v8) >> a2) & 1) + (((unsigned int)v8 >> a2) & 1);
  }
  else
  {
    return 2;
  }
  return v4;
}



__int64 __fastcall cmd_db_query_slv_id(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+38h] [xbp+38h]
  __int64 v5; // [xsp+40h] [xbp+40h]
  __int64 v6; // [xsp+48h] [xbp+48h]

  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 0LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)&v3, 0LL) )
    return 0LL;
  else
    return BYTE6(v4) & 0xF;
}



__int64 __fastcall cmd_db_query_version(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3[3]; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+48h] [xbp+48h]

  memset(v3, 0, sizeof(v3));
  v4 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)v3, 0LL) )
    return 0LL;
  else
    return WORD2(v4);
}



__int64 __fastcall cmd_db_target_mem_init(_DWORD *a1)
{
  cmd_db_addr = 2156265472LL;
  *a1 = 0x20000;
  return 2156265472LL;
}




bool __fastcall cmdq_empty(__int64 a1)
{
  return !inq_head(*(_QWORD *)(a1 + 16)) && inq_head(*(_QWORD *)(a1 + 8)) == 0;
}



unsigned int *__fastcall cmdq_finish_cmd(__int64 a1, __int64 a2, int a3, __int64 a4, int a5)
{
  __int64 v8; // x0
  __int64 v9; // x0
  __int64 i; // x20
  __int64 v11; // x0
  unsigned int *v13[3]; // [xsp+38h] [xbp+38h] BYREF

  if ( a5 )
  {
    rpmh_core_verify(0LL);
    v8 = 0LL;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 8);
  }
  inq_it_begin(v8, v13);
  while ( 1 )
  {
    v9 = inq_it_deref((__int64)v13);
    if ( !v9 )
      rpmh_err_fatal("Inconsistent cmdq state.");
    if ( a2 == v9 )
      break;
    inq_it_next(v13);
  }
  inq_it_delete(v13);
  for ( i = 0LL; *(_DWORD *)(a2 + 8) > (unsigned int)i; ++i )
  {
    v11 = 8 * i;
    rpmh_resource_command_finish(*(_DWORD *)(*(_QWORD *)a2 + v11), a3);
  }
  rpmh_clean_cmd((_QWORD *)a2, *(_DWORD *)a1);
  return inq_append(*(unsigned int **)(a1 + 24), a2);
}



__int64 __fastcall cmdq_num_in_flight(__int64 a1)
{
  return inq_size(*(_QWORD *)(a1 + 8));
}



__int64 __fastcall compare_ch_segments(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        int a8)
{
  int v8; // w1
  unsigned int v9; // w5
  int j; // w3
  unsigned int v11; // w5
  int i; // w3
  __int64 *v13; // x1
  __int64 *v14; // x1
  __int64 v15; // t1
  __int64 v16; // x4
  __int64 v17; // x11
  __int64 v18; // x4
  unsigned int v19; // w8
  int v20; // w14
  int v21; // w9
  __int64 v22; // x10
  __int64 *v23; // x1
  __int64 *v24; // x1
  __int64 v25; // t1
  __int64 v26; // x4
  __int64 v27; // x11
  __int64 v28; // x4
  unsigned int v29; // w8
  int v30; // w14
  int v31; // w9
  __int64 v32; // x10

  v8 = *(_DWORD *)(a1 + 36);
  if ( !v8 )
  {
    v11 = -16;
    for ( i = 0; i != *(_DWORD *)(a1 + 24); ++i )
    {
      v13 = *(__int64 **)(a1 + 40);
      if ( i )
      {
        a8 = *(_DWORD *)(*v13 + v11 + 32LL);
        a3 = *(_DWORD *)(*v13 + v11 + 36LL) & 0xF;
      }
      v15 = *v13;
      v14 = v13 + 1;
      v16 = 16LL * (i & 0xFFFFFFF);
      v17 = v16 + 24;
      v18 = v16 + 28;
      v19 = 1;
      v20 = *(_DWORD *)(v15 + v17);
      v21 = *(_DWORD *)(v15 + v18) & 0xF;
      while ( v19 < *(_DWORD *)(a1 + 28) )
      {
        if ( i && (a8 != *(_DWORD *)(*v14 + v11 + 32LL) || a3 != (*(_DWORD *)(*v14 + v11 + 36LL) & 0xF)) )
          return 0xFFFFFFFFLL;
        v22 = *v14;
        if ( v20 != *(_DWORD *)(*v14 + v17) )
          return 0xFFFFFFFFLL;
        ++v14;
        if ( v21 != (*(_DWORD *)(v22 + v18) & 0xF) )
          return 0xFFFFFFFFLL;
        ++v19;
      }
      v11 += 16;
    }
    return 0LL;
  }
  if ( v8 == 1 )
  {
    v9 = -16;
    for ( j = 0; j != *(_DWORD *)(a1 + 24); ++j )
    {
      v23 = *(__int64 **)(a1 + 40);
      if ( j )
      {
        a8 = *(_DWORD *)(*v23 + v9 + 12LL);
        a3 = *(_DWORD *)(*v23 + v9 + 16LL) & 0xF;
      }
      v25 = *v23;
      v24 = v23 + 1;
      v26 = 16LL * (j & 0xFFFFFFF);
      v27 = v26 + 4;
      v28 = v26 + 8;
      v29 = 1;
      v30 = *(_DWORD *)(v25 + v27);
      v31 = *(_DWORD *)(v25 + v28) & 0xF;
      while ( v29 < *(_DWORD *)(a1 + 28) )
      {
        if ( j && (a8 != *(_DWORD *)(*v24 + v9 + 12LL) || a3 != (*(_DWORD *)(*v24 + v9 + 16LL) & 0xF)) )
          return 0xFFFFFFFFLL;
        v32 = *v24;
        if ( v30 != *(_DWORD *)(*v24 + v27) )
          return 0xFFFFFFFFLL;
        ++v24;
        if ( v31 != (*(_DWORD *)(v32 + v28) & 0xF) )
          return 0xFFFFFFFFLL;
        ++v29;
      }
      v9 += 16;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}




__int64 __fastcall cortex_a78_aarch64_sysini(__int64 result)
{
  unsigned __int64 StatusReg; // x0
  unsigned __int64 v2; // x0

  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    if ( MEMORY[0x1FC8000] == 1612185856LL )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFDFFFFFLL);
      __isb(0xFu);
    }
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 2, 0));
    if ( MEMORY[0x1FC8000] == 1612185856LL )
      v2 = StatusReg & 0xFFFFFFFFFFFFFC0FLL | 0x30;
    else
      v2 = StatusReg & 0xFFFFFFFFFFC0000FLL | 0x928C0;
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 2, 0), v2 & 0xFFFFFFF0FFFFFFF0LL | 0x10000000FLL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) != 0 )
    {
      if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) == 0x100000 )
      {
        if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 6)) & 1) != 1 )
          e_1688305_wa();
        e_1827429_wa();
        e_1821534_wa();
        e_1941498_wa();
        e_1951500_wa();
      }
      else if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) == 1048577 )
      {
        e_1941498_wa();
        e_1951500_wa();
      }
    }
    else
    {
      e_1688305_wa();
      e_1515634_wa();
      e_1503072_wa();
      e_1467580_wa();
      e_1492189_wa();
      e_1827429_wa();
      e_1821534_wa();
      e_1941498_wa();
    }
    result = 1612185856LL;
  }
  else if ( !(_BYTE)result )
  {
    result = 1612185856LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 cortex_a78_amu_disable()
{
  __int64 result; // x0

  result = 1612185856LL;
  if ( MEMORY[0x1FC8000] == 1612185856LL )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 2, 4), 0xFuLL);
    result = 7LL;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 3, 0), 7uLL);
    __isb(0xFu);
  }
  return result;
}



__int64 cortex_a78_amu_enable()
{
  __int64 result; // x0

  result = 1612185856LL;
  if ( MEMORY[0x1FC8000] == 1612185856LL )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 2, 5), 0xFuLL);
    result = 7LL;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 3, 1), 7uLL);
    __isb(0xFu);
  }
  return result;
}



__int64 __fastcall cpu_aarch64_sysini(__int64 result)
{
  unsigned __int64 v1; // x2

  v1 = _ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xFFFFFFFFFF0FFFF0LL;
  if ( v1 == 1091555408 )
    return kryo500_silver_aarch64_sysini(result);
  if ( v1 == 1091556368 )
    return cortex_a78_aarch64_sysini(result);
  return result;
}



__int64 __fastcall cpucp_clkdom_init(__int64 a1)
{
  char v1; // w0
  int *v2; // x2
  __int64 result; // x0
  __int64 v4; // x1
  __int64 v5; // x20
  int v6; // [xsp+34h] [xbp+34h] BYREF
  int v7[2]; // [xsp+38h] [xbp+38h] BYREF

  v1 = qtiseclib_cb_plat_my_core_pos(a1);
  v2 = &dword_1A61C;
  result = (unsigned int)(1 << v1);
  v4 = 0LL;
  while ( 1 )
  {
    v5 = (int)v4;
    if ( !clkdom_init_status[v4] && ((unsigned int)result & *v2) != 0 )
      break;
    ++v4;
    v2 += 2;
    if ( v4 == 4 )
      return result;
  }
  qtiseclib_cb_spin_lock(&cpucp_clkdom_init_spinlock);
  if ( !clkdom_init_status[v5] )
  {
    v7[0] = *((_DWORD *)&clkdom_cpumasks + 2 * v5);
    v7[1] = 1;
    if ( !(unsigned int)cpucp_scmi_send(0x14u, 7u, (__int64)v7, 8u, &v6, 0LL, 0LL) && !v6 )
      clkdom_init_status[v5] = 1;
  }
  return qtiseclib_cb_spin_unlock(&cpucp_clkdom_init_spinlock);
}



__int64 cpucp_host_clock_domain_disable()
{
  return 0LL;
}



__int64 __fastcall cpucp_host_clock_domain_enable(__int64 a1)
{
  cpucp_clkdom_init(a1);
  return 0LL;
}



__int64 cpucp_host_clock_domain_init()
{
  return 0LL;
}



__int64 cpucp_host_configure_shared_data()
{
  __int64 result; // x0
  char v1; // w20
  __int16 v2; // w0
  __int16 v3; // x5^2
  _DWORD *v4; // x6
  int *v5; // x3
  int v6; // w0
  char v7; // w2
  _DWORD *v8; // x4

  result = 0xFFFFFFFFLL;
  v1 = MEMORY[0x18508000];
  if ( MEMORY[0x18508000] == 3 )
  {
    calculate_cpumasks(407930404LL);
    MEMORY[0x18508634] |= MEMORY[0x1850862C] | MEMORY[0x18508628] | MEMORY[0x18508624] | MEMORY[0x18508630];
    MEMORY[0x18508220] = MEMORY[0x1FC8000] | (MEMORY[0x1FC8001] << 16);
    MEMORY[0x18508224] = (MEMORY[0x784210] >> 6) & 0xF;
    MEMORY[0x18508228] = MEMORY[0x784180] >> 29;
    MEMORY[0x18508234] = MEMORY[0x78070C] & 0xF;
    MEMORY[0x18508238] = MEMORY[0x7802DC] >> 29;
    MEMORY[0x1850822C] = (unsigned __int8)((unsigned __int64)MEMORY[0x784180] >> 20);
    MEMORY[0x185082A1] = 8;
    MEMORY[0x185082A2] = 8;
    MEMORY[0x185082A3] = 8;
    MEMORY[0x185085D3] = 0;
    MEMORY[0x185085DC] = 0;
    MEMORY[0x185085CA] = 0;
    MEMORY[0x18508230] = MEMORY[0x784180] & 0xFFFFF;
    MEMORY[0x1850837A] = 8
                       * ((MEMORY[0x784290] >> 13) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x784290] << 45) >> 63) | 1);
    MEMORY[0x1850837C] = 8
                       * ((4 * (MEMORY[0x7842AC] & 0xF) + (MEMORY[0x7842A8] >> 30)) & 0x1F)
                       * (((__int64)((unsigned __int64)(4 * (MEMORY[0x7842AC] & 0xFu) + (MEMORY[0x7842A8] >> 30)) << 58) >> 63) | 1);
    MEMORY[0x1850837E] = 8 * (MEMORY[0x7842AB] & 0x1F) * (((__int16)(MEMORY[0x7842A8] >> 14) >> 15) | 1);
    MEMORY[0x1850847C] = CPR11_SVSL1_QUOT_VMIN() - ((MEMORY[0x7842B0] >> 8) & 0xFFF);
    v2 = CPR11_SVSL1_QUOT_VMIN();
    MEMORY[0x1850847E] = (v3 & 0xFFF) - v2;
    MEMORY[0x1850857A] = (*v4 >> 8) & 0xFFF;
    MEMORY[0x1850857C] = CPR11_SVSL1_QUOT_VMIN();
    v6 = *v5;
    MEMORY[0x185082A4] = v7;
    MEMORY[0x1850857E] = HIWORD(v6) & 0xFFF;
    MEMORY[0x18508380] = 8 * ((*v8 >> 18) & 0x1F) * (((__int64)((unsigned __int64)(unsigned int)*v8 << 40) >> 63) | 1);
    MEMORY[0x18508480] = ((unsigned __int16)*v5 >> 4) - (HIWORD(*v5) & 0xFFF);
    MEMORY[0x18508580] = (unsigned __int16)*v5 >> 4;
    MEMORY[0x185082A9] = v7;
    MEMORY[0x185082AA] = v7;
    MEMORY[0x18508244] = (unsigned __int64)MEMORY[0x7842B4] >> 10;
    MEMORY[0x185082AB] = 9;
    MEMORY[0x1850838A] = 8
                       * ((MEMORY[0x7842B8] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B8] << 54) >> 63) | 1);
    MEMORY[0x1850838C] = 8
                       * ((4 * (MEMORY[0x7842B8] & 0xF) + (MEMORY[0x7842B4] >> 30)) & 0x1F)
                       * (((__int64)((unsigned __int64)(4 * (MEMORY[0x7842B8] & 0xFu) + (MEMORY[0x7842B4] >> 30)) << 58) >> 63) | 1);
    MEMORY[0x1850838E] = 8
                       * (MEMORY[0x7842B7] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B4] << 34) >> 63) | 1);
    MEMORY[0x1850848C] = (((unsigned __int64)MEMORY[0x7842BC] >> 2) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842BC] >> 14) & 0xFFF);
    MEMORY[0x1850848E] = 5 * (((MEMORY[0x7842C0] & 3) << 6) + (MEMORY[0x7842BC] >> 26));
    MEMORY[0x1850858A] = ((unsigned __int64)MEMORY[0x7842BC] >> 14) & 0xFFF;
    MEMORY[0x1850858C] = ((unsigned __int64)MEMORY[0x7842BC] >> 2) & 0xFFF;
    MEMORY[0x185082AC] = 9;
    MEMORY[0x1850858E] = ((MEMORY[0x7842BC] & 3) << 10) + (MEMORY[0x7842B8] >> 22);
    MEMORY[0x18508390] = 8
                       * ((MEMORY[0x7842B4] >> 18) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B4] << 40) >> 63) | 1);
    MEMORY[0x185082B9] = v7;
    MEMORY[0x185082BA] = v7;
    MEMORY[0x18508245] = (unsigned __int64)MEMORY[0x7842B4] >> 10;
    MEMORY[0x185082BB] = v7;
    MEMORY[0x18508590] = ((unsigned __int64)MEMORY[0x7842B8] >> 10) & 0xFFF;
    MEMORY[0x18508490] = MEMORY[0x18508590] - (MEMORY[0x7842B8] >> 22) - ((MEMORY[0x7842BC] & 3) << 10);
    MEMORY[0x185083AA] = 8
                       * (((unsigned __int64)MEMORY[0x7842D4] >> 22) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 36) >> 63) | 1);
    MEMORY[0x185083AC] = 8
                       * (MEMORY[0x7842D6] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 42) >> 63) | 1);
    MEMORY[0x185083AE] = 8
                       * ((MEMORY[0x7842D4] >> 10) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 48) >> 63) | 1);
    MEMORY[0x185084AC] = (MEMORY[0x7842D8] >> 20) - (MEMORY[0x7842DC] & 0xFFF);
    MEMORY[0x185084AE] = ((MEMORY[0x7842D8] >> 8) & 0xFFF) - (MEMORY[0x7842D8] >> 20);
    MEMORY[0x185085AA] = MEMORY[0x7842DC] & 0xFFF;
    MEMORY[0x185085AC] = MEMORY[0x7842D8] >> 20;
    MEMORY[0x185082BD] = v7;
    MEMORY[0x185085AE] = (MEMORY[0x7842D8] >> 8) & 0xFFF;
    MEMORY[0x185083B2] = 8
                       * (((unsigned __int64)MEMORY[0x7842D4] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 54) >> 63) | 1);
    MEMORY[0x185084B2] = 16 * MEMORY[0x7842D8] + (MEMORY[0x7842D4] >> 28) - ((MEMORY[0x7842D8] >> 8) & 0xFFF);
    MEMORY[0x185085B2] = 16 * MEMORY[0x7842D8] + (MEMORY[0x7842D4] >> 28);
    MEMORY[0x185082B3] = 11;
    MEMORY[0x185082B1] = 13;
    MEMORY[0x18508247] = 16 * (MEMORY[0x7842D4] & 0xF) + (MEMORY[0x7842D0] >> 28);
    MEMORY[0x185082B2] = 13;
    MEMORY[0x1850839A] = 8
                       * ((16 * (MEMORY[0x7842C8] & 3) + (MEMORY[0x7842C4] >> 28)) & 0x1F)
                       * (((__int64)((unsigned __int64)(16 * (MEMORY[0x7842C8] & 3u) + (MEMORY[0x7842C4] >> 28)) << 58) >> 63) | 1);
    MEMORY[0x1850839C] = 8
                       * ((MEMORY[0x7842C4] >> 22) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 36) >> 63) | 1);
    MEMORY[0x1850839E] = 8
                       * (MEMORY[0x7842C6] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 42) >> 63) | 1);
    MEMORY[0x1850849C] = (((unsigned __int64)MEMORY[0x7842CC] >> 6) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842CC] >> 18) & 0xFFF);
    MEMORY[0x1850849E] = 5 * (unsigned __int8)((unsigned __int64)MEMORY[0x7842D0] >> 14);
    MEMORY[0x1850859A] = ((unsigned __int64)MEMORY[0x7842CC] >> 18) & 0xFFF;
    MEMORY[0x1850859C] = ((unsigned __int64)MEMORY[0x7842CC] >> 6) & 0xFFF;
    MEMORY[0x185082B5] = 11;
    MEMORY[0x1850859E] = ((MEMORY[0x7842CC] & 0x3F) << 6) + (MEMORY[0x7842C8] >> 26);
    MEMORY[0x185083A2] = 8
                       * ((MEMORY[0x7842C4] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 54) >> 63) | 1);
    MEMORY[0x185084A2] = (((unsigned __int64)MEMORY[0x7842C8] >> 2) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF);
    MEMORY[0x185082B4] = 11;
    MEMORY[0x185085A2] = ((unsigned __int64)MEMORY[0x7842C8] >> 2) & 0xFFF;
    MEMORY[0x185083A0] = 8
                       * ((MEMORY[0x7842C4] >> 10) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 48) >> 63) | 1);
    MEMORY[0x185084A0] = (((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF)
                       - (MEMORY[0x7842C8] >> 26)
                       - ((MEMORY[0x7842CC] & 0x3F) << 6);
    MEMORY[0x185085A0] = ((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF;
    MEMORY[0x18508246] = MEMORY[0x18508247];
    cmd_db_tzbsp_init();
    MEMORY[0x185085F0] = cmd_db_query_addr((__int64)"mx.lvl");
    MEMORY[0x185085F4] = 28;
    cmd_db_query_aux_data((__int64)"mx.lvl", (_BYTE *)0x185085F4, 407930358LL);
    MEMORY[0x18508614] = v1;
    MEMORY[0x18508615] = 13;
    MEMORY[0x18508618] = 0;
    MEMORY[0x18508616] = 1;
    MEMORY[0x18508617] = 1;
    MEMORY[0x18508619] = 1;
    MEMORY[0x1850861B] = 1;
    MEMORY[0x1850861D] = 1;
    MEMORY[0x1850861F] = 1;
    result = 0LL;
    MEMORY[0x1850861A] = 0;
    MEMORY[0x1850861C] = 0;
    MEMORY[0x1850861E] = 0;
    MEMORY[0x18508620] = 0;
  }
  return result;
}



__int64 cpucp_host_error_handler()
{
  return 0LL;
}



__int64 cpucp_host_handle_irq()
{
  return 0LL;
}



__int64 cpucp_host_init()
{
  return 0LL;
}



__int64 cpucp_host_recv_message()
{
  return 0LL;
}



__int64 cpucp_host_send_message()
{
  return 0LL;
}



__int64 __fastcall cpucp_iface_initialize(_QWORD *a1)
{
  int *v1; // x2
  _QWORD *v2; // x0
  int v3; // w1
  int v4; // t1

  a1[1] = cpucp_prepare;
  a1[2] = cpucp_unprepare;
  a1[3] = cpucp_load_firmware;
  a1[4] = cpucp_host_init;
  v1 = &dword_1A61C;
  a1[8] = cpucp_host_configure_shared_data;
  a1[9] = cpucp_host_error_handler;
  a1[10] = cpucp_host_send_message;
  a1[11] = cpucp_host_recv_message;
  a1[5] = cpucp_start;
  v2 = a1 + 12;
  v3 = 0;
  do
  {
    *(_DWORD *)v2 = v3++;
    v2[4] = cpucp_host_clock_domain_init;
    v2[5] = cpucp_host_clock_domain_enable;
    v2[6] = cpucp_host_clock_domain_disable;
    v2 += 10;
    *(v2 - 1) = cpucp_host_handle_irq;
    v4 = *v1;
    v1 += 2;
    *((_DWORD *)v2 - 18) = v4;
  }
  while ( v3 != 4 );
  return 0LL;
}



__int64 cpucp_load_firmware()
{
  return 0LL;
}



__int64 cpucp_prepare()
{
  MEMORY[0x18598000] |= 1u;
  MEMORY[0x18580000] |= 1u;
  while ( (MEMORY[0x18580000] & 1) == 0 )
    ;
  return 0LL;
}



__int64 __fastcall cpucp_scmi_send(
        unsigned __int8 a1,
        unsigned __int8 a2,
        __int64 a3,
        unsigned int a4,
        _DWORD *a5,
        __int64 a6,
        unsigned int *a7)
{
  bool v7; // zf
  unsigned int v8; // w19
  unsigned __int64 v16; // x23
  unsigned __int64 StatusReg; // x0
  unsigned __int64 v18; // x2
  unsigned int v20; // w19
  unsigned int v21; // w24
  int v23; // w1
  unsigned __int64 v24; // x1
  unsigned __int64 v25; // x23
  unsigned int v27; // w0
  __int64 v28; // x3
  unsigned int v29; // w0
  __int64 v30; // x2
  __int64 i; // x1
  int v32; // t1
  __int64 v33; // x0
  __int64 v34; // x4
  __int64 v35; // x0
  __int64 v36; // x1
  __int64 v37; // x3

  if ( a3 )
    v7 = 1;
  else
    v7 = a4 == 0;
  v8 = -1;
  if ( v7 )
  {
    v8 = -2;
    if ( a4 <= 0x64 )
    {
      qtiseclib_cb_spin_lock(&scmi_host_spinlock);
      v16 = 500 * _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 0)) / 0x3E8;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      v18 = v16 + StatusReg;
      while ( StatusReg < v18 && MEMORY[0x18509004] != 1 )
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      if ( MEMORY[0x18509004] != 1 )
        goto LABEL_14;
      __dsb(0xFu);
      MEMORY[0x18509018] = scmi_construct_msg_hdr(a2, 0, a1, 0);
      MEMORY[0x18509004] = 0;
      MEMORY[0x18509010] = 0;
      v20 = (a4 + 3) >> 2;
      v21 = 0;
      scmi_packet_init_payload(407932928LL);
      while ( v21 < v20 && a3 != 0 )
      {
        v23 = *(_DWORD *)(a3 + 4LL * v21++);
        write_output_payload_word(407932928LL, v23);
      }
      get_input_payload_word_at_offset(407932928LL, 1);
      MEMORY[0x17C00008] = 0x10000000;
      v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      v25 = v16 + v24;
      while ( MEMORY[0x18509004] != 1 && v24 < v25 )
        v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      if ( MEMORY[0x18509004] == 1 )
      {
        __dsb(0xFu);
        if ( MEMORY[0x18509014] <= 7u )
        {
LABEL_31:
          v8 = 0;
          if ( a7 )
          {
            if ( *a7 )
            {
              if ( MEMORY[0x18509014] > 8u )
              {
                v8 = -3;
                if ( a6 )
                {
                  v27 = MEMORY[0x18509014] - 8;
                  if ( *a7 >= MEMORY[0x18509014] - 8 )
                  {
                    v28 = v27 >> 2;
                    v29 = v27 >> 2;
                    v30 = 407932960LL;
                    for ( i = 0LL; i != v28; ++i )
                    {
                      v32 = *(_DWORD *)v30;
                      v30 += 4LL;
                      *(_DWORD *)(a6 + 4 * i) = v32;
                    }
                    v33 = 4LL * (v29 & 0x3FFFFFFF);
                    v34 = v33 + 407932960;
                    v35 = a6 + v33;
                    v36 = 0LL;
                    v37 = MEMORY[0x18509014] & 3;
                    while ( v37 != v36 )
                    {
                      *(_BYTE *)(v35 + v36) = *(_BYTE *)(v34 + v36);
                      ++v36;
                    }
                    v8 = 0;
                    *a7 = MEMORY[0x18509014] - 8;
                  }
                  else
                  {
                    v8 = -4;
                    *a7 = v27;
                  }
                }
              }
            }
          }
          goto LABEL_44;
        }
        v8 = -5;
        if ( a5 )
        {
          *a5 = MEMORY[0x1850901C];
          goto LABEL_31;
        }
      }
      else
      {
LABEL_14:
        v8 = -6;
      }
LABEL_44:
      qtiseclib_cb_spin_unlock(&scmi_host_spinlock);
    }
  }
  return v8;
}



__int64 cpucp_start()
{
  __int64 result; // x0

  MEMORY[0x182A00B0] = MEMORY[0x182A00B0] & 3 | 0x200;
  MEMORY[0x182A00B0] = MEMORY[0x182A00B0] & 0xF00 | 1;
  MEMORY[0x182A000C] = MEMORY[0x182A000C] & 0xF0000000 | 1;
  MEMORY[0x182A0010] = 2;
  MEMORY[0x182A007C] = MEMORY[0x182A007C] & 0xF0000000 | 1;
  MEMORY[0x182A0080] = 0;
  MEMORY[0x182A005C] = MEMORY[0x182A005C] & 0xF0000000 | 1;
  MEMORY[0x182A0060] = 0;
  MEMORY[0x182A008C] = MEMORY[0x182A008C] & 0xF0000000 | 1;
  MEMORY[0x182A0090] = 1;
  MEMORY[0x18598018] = 19230;
  MEMORY[0x18598010] |= 1u;
  result = cpucp_host_configure_shared_data();
  if ( !(_DWORD)result )
  {
    MEMORY[0x18598000] &= ~1u;
    MEMORY[0x18598024] = 0;
    MEMORY[0x18598004] |= 1u;
    result = MEMORY[0x18580000] | 2u;
    MEMORY[0x18580000] |= 2u;
  }
  return result;
}



__int64 cpucp_unprepare()
{
  MEMORY[0x18598000] &= ~1u;
  MEMORY[0x18580000] &= ~1u;
  return 0LL;
}



__int64 __fastcall cpu_lpm_exit(__int64 a1, unsigned __int8 *a2, int a3)
{
  __int64 v5; // x0
  __int64 v6; // x0

  v5 = *a2;
  if ( (unsigned int)(v5 - 3) <= 1 )
  {
    if ( (_DWORD)v5 == 4 )
    {
      v6 = qtiseclib_cb_plat_my_core_pos(v5);
      lmh_c4_exit(v6);
    }
    int_svc_notify_cpu_state(1LL);
  }
  pcu_config_low_power_mode(*(__int64 **)(a1 + 64), 1);
  if ( !a3 )
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 68LL) &= 0xFFFC3FFu;
  return 0LL;
}



__int64 __fastcall cpuss_aarch64_por_sysini(__int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1611595775 )
    return hoya_11_cpuss_aarch64_por_sysini(result);
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    return hoya_20_cpuss_aarch64_por_sysini(result);
  return hoya_10_cpuss_aarch64_por_sysini(result);
}



void cpuss_dmb()
{
  __dmb(0xFu);
}



void cpuss_dsb()
{
  __dsb(0xFu);
}



void cpuss_isb()
{
  __isb(0xFu);
}



unsigned __int64 cpuss_read_isr()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 0, 12, 1, 0));
}



void __fastcall __noreturn dbg_err_fatal(unsigned int a1)
{
  dbg_err_fatal_handler(a1);
}



__int64 dbg_init()
{
  int_svc_register_isr(33, (__int64)"NSEC_WDOG_BITE", 0xFuLL, (__int64)nsec_wdt_bite_isr_handler, 0LL);
  return int_svc_register_isr(15, (__int64)"SGI15", 6uLL, (__int64)sgi15_isr_handler, 0LL);
}



__int64 dbg_is_sdi_enable()
{
  return 0LL;
}



__int64 __fastcall drv_valid(int a1)
{
  __int64 i; // x1
  int v2; // w4

  for ( i = 0LL; i != 48; i += 48LL )
  {
    v2 = *(_DWORD *)((char *)&_compound_literal_1_2 + i);
    if ( v2 == a1 )
      return 1LL;
  }
  return 0LL;
}



__int64 __fastcall get_finished_drv(int a1)
{
  unsigned int v2; // w19
  __int64 v3; // x0
  int v5; // w0
  __int64 v6; // x2
  unsigned int *v7; // x19
  _QWORD *v8; // x1
  int v9; // w3
  bool v10; // cc
  int v11; // [xsp+3Ch] [xbp+3Ch] BYREF

  v2 = lookup_drv_index(a1);
  v3 = (unsigned int)RscHalCheckAMCFinishedIRQ(*((_DWORD *)&_compound_literal_1_2 + 12 * v2 + 1), &v11) == 0;
  rpmh_core_verify(v3);
  if ( v11 )
  {
    v5 = 31 - rpmh_clz(v11);
    v6 = 0LL;
    v7 = (unsigned int *)(tcs_mode + 4LL * v2);
    while ( v6 != 48 )
    {
      v8 = (_QWORD *)((char *)&_compound_literal_1_2 + v6);
      v9 = v5 - *(_DWORD *)((char *)&_compound_literal_1_2 + v6 + 20);
      v10 = *(_DWORD *)((char *)&_compound_literal_1_2 + v6 + 4) != a1 || v9 < 0;
      if ( !v10 && (unsigned int)v9 < **(_DWORD **)(v8[5] + 8LL * *v7) )
        return *(unsigned int *)v8;
      v6 += 48LL;
    }
  }
  return 0x3FFFFFFFLL;
}



__int64 __fastcall get_input_payload_char_at_offset(__int64 a1, int a2)
{
  return *(unsigned int *)(a1 + a2 + 28);
}



__int64 __fastcall get_input_payload_word_at_offset(__int64 a1, int a2)
{
  return *(unsigned int *)(a1 + 4LL * a2 + 28);
}



__int64 get_max_cmd_size()
{
  return 504LL;
}



__int64 __fastcall get_system_memory_map(__int64 a1, _QWORD *a2)
{
  __int64 v4; // x2
  unsigned int v5; // w4
  __int64 *v6; // x1
  __int64 v7; // x5
  char *v8; // x6
  _QWORD *v9; // x6
  unsigned int i; // w21
  __int64 result; // x0
  __int64 v12; // x0

  qtiseclib_cb_memset(a2, 0LL, 576LL);
  v4 = 0LL;
  v5 = 0;
  v6 = (__int64 *)&byte_2FDA8;
  do
  {
    if ( *(_BYTE *)v6 )
    {
      v9 = &a2[3 * v5];
      if ( *v9 )
      {
        ++v5;
        v9[1] = v9[1] - v4 + *(v6 - 2);
      }
    }
    else
    {
      v7 = *(v6 - 2);
      v8 = (char *)&a2[3 * v5];
      if ( *(_QWORD *)v8 )
      {
        *((_QWORD *)v8 + 1) = *((_QWORD *)v8 + 1) - v4 + v7;
        v4 = v7;
      }
      else
      {
        a2[3 * v5] = v7;
        v4 = v7;
        v8[16] = 1;
      }
    }
    v6 += 3;
  }
  while ( v6 != &info );
  for ( i = 1; ; ++i )
  {
    result = *(unsigned int *)(a1 + 28);
    if ( i >= (unsigned int)result )
      break;
    v12 = i;
    memcpy(&a2[18 * v12], a2, 0x90uLL);
  }
  return result;
}




unsigned int *__fastcall HAL_avs_Enable(unsigned int a1, int a2)
{
  unsigned int *result; // x0
  unsigned int v3; // w1

  result = (unsigned int *)asAVSRegs[7 * a1 + 4];
  if ( a2 )
  {
    *result |= 1u;
    v3 = *result | 0x10;
  }
  else
  {
    *result &= ~1u;
    v3 = *result & 0xFFFFFFEF;
  }
  *result = v3;
  return result;
}



__int64 __fastcall HAL_avs_EnableCtl(unsigned int a1, unsigned __int8 a2)
{
  int v2; // w22
  int v4; // w21
  __int64 *v5; // x19
  unsigned int v6; // w19
  int VddSettleTimeUS; // w0

  v2 = a2;
  v4 = 201;
  v5 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v5 = ((a2 != 0) << 7) | 0x30000;
  while ( 1 )
  {
    if ( !--v4 )
    {
      v6 = 0;
      goto LABEL_7;
    }
    if ( (*(_DWORD *)v5[1] & 0x30000) == 0 )
      break;
    qtiseclib_cb_udelay(2LL);
  }
  v6 = 1;
LABEL_7:
  if ( v2 )
  {
    VddSettleTimeUS = HAL_avs_GetVddSettleTimeUS(a1, gHALAVSContext[4 * a1 + 2]);
    qtiseclib_cb_udelay((unsigned int)(VddSettleTimeUS + 36));
  }
  return v6;
}



__int64 __fastcall HAL_avs_GetVddSettleTimeUS(int a1, int a2)
{
  if ( a2 )
    return 120 * ((unsigned int)(1000 * a2) / gHALAVSContext[4 * a1 + 3]) / 0x64;
  else
    return 0LL;
}




__int64 __fastcall HAL_avs_Ramp_En(unsigned int a1, char a2)
{
  unsigned int *v2; // x2
  __int64 result; // x0

  v2 = (unsigned int *)asAVSRegs[7 * a1 + 4];
  *v2 = ((a2 & 1) << 15) | *v2 & 0xFFFF7FFF;
  result = *v2;
  *v2 = ((a2 & 1) << 14) | result & 0xFFFFBFFF;
  return result;
}



__int64 __fastcall HAL_avs_RestoreBootVoltage(unsigned int a1)
{
  return HAL_avs_SetVoltage(a1, gHALAVSContext[4 * a1 + 1]);
}



__int64 HAL_avs_SecondaryRailInit()
{
  HAL_avs_Enable(1u, 1);
  HAL_avs_EnableCtl(1u, 1u);
  return HAL_avs_RestoreBootVoltage(1u);
}



__int64 __fastcall HAL_avs_SetClockDivider(unsigned int a1, char a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 4];
  result = ((a2 & 0x1F) << 8) | *v2 & 0xFFFFE0FF;
  *v2 = result;
  return result;
}



__int64 __fastcall HAL_avs_SetDelay(unsigned int a1, __int16 a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 6];
  result = *v2 & 0xFFFFFC00;
  *v2 = result | a2 & 0x3FF;
  return result;
}



__int64 __fastcall HAL_avs_SetMaxVoltage(unsigned int a1, int a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 5];
  result = (unsigned __int16)*v2;
  *v2 = result | (a2 << 16);
  return result;
}



__int64 __fastcall HAL_avs_SetMinVoltage(unsigned int a1, unsigned __int16 a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 5];
  result = *v2 & 0xFFFF0000;
  *v2 = result | a2;
  return result;
}



__int64 __fastcall HAL_avs_SetPowerMode(unsigned int a1, int a2)
{
  int v2; // w2
  int v4; // w20
  __int64 *v5; // x19

  if ( a2 == 1 )
  {
    v2 = 7;
  }
  else
  {
    v2 = 6;
    if ( a2 )
      return 0LL;
  }
  v4 = 201;
  v5 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v5 = v2 | 0x20000;
  while ( --v4 )
  {
    if ( (*(_DWORD *)v5[1] & 0x30000) == 0 )
      return 1LL;
    qtiseclib_cb_udelay(2LL);
  }
  return 0LL;
}



__int64 __fastcall HAL_avs_SetVoltage(unsigned int a1, unsigned int a2)
{
  int v4; // w24
  unsigned int v5; // w2
  int v6; // w1
  int v7; // w23
  __int64 *v8; // x22
  _DWORD *v9; // x0
  unsigned int v10; // w24
  __int64 VddSettleTimeUS; // x0
  __int64 result; // x0

  v4 = 201;
  v5 = gHALAVSContext[4 * a1 + 2];
  v6 = a2 - v5;
  v7 = v5 - a2;
  if ( v5 < a2 )
    v7 = v6;
  v8 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v8 = (unsigned __int16)a2 | 0x100000;
  while ( 1 )
  {
    if ( !--v4 )
    {
      v10 = 0;
      goto LABEL_10;
    }
    v9 = (_DWORD *)v8[1];
    if ( (*v9 & 0x30000) == 0 && a2 == (unsigned __int16)*v9 )
      break;
    qtiseclib_cb_udelay(2LL);
  }
  v10 = 1;
LABEL_10:
  if ( !bIsInit_1181 && a2 > gHALAVSContext[4 * a1 + 2] )
  {
    VddSettleTimeUS = HAL_avs_GetVddSettleTimeUS(a1, v7);
    qtiseclib_cb_udelay(VddSettleTimeUS);
  }
  result = v10;
  bIsInit_1181 = 0;
  gHALAVSContext[4 * a1 + 2] = a2;
  return result;
}



__int64 __fastcall HAL_avs_SetVoltageStepSize(unsigned int a1, int a2, unsigned __int8 a3)
{
  int *v3; // x3
  __int64 result; // x0

  v3 = (int *)asAVSRegs[7 * a1 + 4];
  *v3 = *v3 & 0xFFFFFF | (a2 << 24);
  result = (a3 << 16) | *v3 & 0xFF00FFFF;
  *v3 = result;
  return result;
}



__int64 __fastcall HAL_avs_SetVoltageWidth(unsigned int a1, char a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 4];
  result = (32 * (a2 & 1)) | *v2 & 0xFFFFFFDF;
  *v2 = result;
  return result;
}



_DWORD *__fastcall HAL_clk_ConfigClockMux(_DWORD *result, unsigned int *a2)
{
  bool v2; // zf
  _DWORD **v3; // x9

  if ( a2 )
    v2 = result == 0LL;
  else
    v2 = 1;
  if ( !v2 && *(_QWORD *)result )
  {
    HAL_clk_GenericConfigMuxOffs_part_0((unsigned __int64)result, a2, 4u, 8u, 0xCu, 0x10u);
    result = *v3;
    **v3 |= 1u;
    while ( (*result & 1) != 0 )
      ;
  }
  return result;
}



unsigned __int64 __fastcall HAL_clk_ConfigDFSMux(unsigned __int64 result, __int64 a2)
{
  unsigned int v2; // w2

  if ( result )
  {
    v2 = *(unsigned __int8 *)(a2 + 10);
    if ( *(_DWORD *)(result + 16) > v2 )
      return HAL_clk_GenericConfigMuxOffs_part_0(
               result,
               (unsigned int *)a2,
               4 * v2 + 28,
               4 * v2 + 92,
               4 * v2 + 156,
               4 * v2 + 220);
  }
  return result;
}



__int64 __fastcall HAL_clk_DisableClock(__int64 result)
{
  unsigned __int64 v1; // x1
  int v2; // w0

  LODWORD(v1) = *(_DWORD *)(result + 8);
  if ( (_DWORD)v1 )
  {
    v1 = (unsigned int)v1;
    v2 = *(_DWORD *)(result + 12);
  }
  else
  {
    v1 = *(_QWORD *)result;
    if ( !*(_QWORD *)result )
      return result;
    v2 = 1;
  }
  result = *(_DWORD *)v1 & (unsigned int)~v2;
  *(_DWORD *)v1 = result;
  return result;
}



_DWORD *__fastcall HAL_clk_DisablePowerDomain(_DWORD **a1)
{
  _DWORD *result; // x0

  result = *a1;
  if ( result )
    *result |= 1u;
  return result;
}



__int64 __fastcall HAL_clk_DisableSource(__int64 a1)
{
  __int64 result; // x0

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
  {
    result = MEMORY[0x153030] & (unsigned int)~(_DWORD)result;
    MEMORY[0x153030] = result;
  }
  return result;
}



         HAL_clk_EnableClock(a1 + 8),
         (v4 = *(_QWORD *)(a1 + 40)) == 0)
     || (v5 = *(_DWORD *)(v4 + 16), *(_DWORD *)(v4 + 16) = v5 + 1, v5)
     || (HAL_clk_EnablePowerDomain(v4), (unsigned int)HAL_clk_WaitForPowerDomainOn((_DWORD **)v4)))
    && (unsigned int)HAL_clk_WaitForClockOn(v3) )
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0LL;
  }
  else
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0xFFFFFFFFLL;
  }
}



__int64 __fastcall HAL_clk_EnableDFS(__int64 result)
{
  __int64 v1; // x1

  v1 = *(_QWORD *)result;
  if ( *(_QWORD *)result )
  {
    result = *(unsigned int *)(result + 16);
    if ( (_DWORD)result )
    {
      result = 33LL;
      *(_DWORD *)(v1 + 20) = 33;
    }
  }
  return result;
}



__int64 __fastcall HAL_clk_EnablePowerDomain(__int64 result)
{
  unsigned int *v1; // x2
  unsigned int v2; // w1

  v1 = *(unsigned int **)result;
  if ( *(_QWORD *)result )
  {
    v2 = *v1 & 0xFFFFFFFE;
    *(_DWORD *)(result + 8) = !(*(_BYTE *)v1 & 1);
    *v1 = v2;
  }
  return result;
}



__int64 *__fastcall HAL_clk_EnableSource(__int64 *result)
{
  int v1; // w3

  v1 = *((_DWORD *)result + 2);
  if ( v1 )
  {
    result = (__int64 *)*result;
    MEMORY[0x153030] |= v1;
    if ( result )
    {
      while ( (*(_DWORD *)result & 0x40000000) == 0 )
        ;
    }
  }
  return result;
}



__int64 __fastcall HAL_clk_IsClockOn(int **a1)
{
  int *v1; // x0

  v1 = *a1;
  if ( v1 )
    return (unsigned int)(*v1 >> 31);
  else
    return 0LL;
}



  if ( !v3 || (result = HAL_clk_IsPowerDomainOn(v3), (_DWORD)result) )
  {
    *a2 = 1;
    return 0LL;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}



__int64 __fastcall HAL_clk_WaitForClockOn(int **a1)
{
  int v2; // w20

  if ( !*a1 )
    return 0xFFFFFFFFLL;
  if ( (**a1 & 2) != 0 )
    return 0LL;
  v2 = 100;
  while ( 1 )
  {
    if ( (unsigned int)HAL_clk_IsClockOn(a1) )
      return 0LL;
    if ( !--v2 )
      break;
    qtiseclib_cb_udelay(1LL);
  }
  return 0xFFFFFFFFLL;
}



__int64 __fastcall HAL_clk_WaitForPowerDomainOn(_DWORD **a1)
{
  int v2; // w19
  __int64 result; // x0

  v2 = 10000;
  qtiseclib_cb_udelay(1LL);
  while ( 1 )
  {
    result = HAL_clk_IsPowerDomainOn(a1);
    if ( !(_DWORD)result )
      break;
    if ( !--v2 )
      return 0xFFFFFFFFLL;
    qtiseclib_cb_udelay(1LL);
  }
  return result;
}



__int64 __fastcall handle_scmi_base_protocol_msg(__int64 a1)
{
  int v2; // w1
  __int64 v3; // x20
  int v4; // w0
  int v5; // w1
  __int64 v6; // x20
  int v7; // w0
  int v8; // w1
  __int64 input_payload_char_at_offset; // x0
  int v10; // w20
  unsigned int v12; // [xsp+3Ch] [xbp+3Ch] BYREF
  int v13[4]; // [xsp+40h] [xbp+40h] BYREF

  scmi_packet_init_payload(a1);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      write_output_payload_word(a1, 0);
      v2 = 0x20000;
      goto LABEL_4;
    case 1:
      write_output_payload_word(a1, 0);
      v2 = 257;
      goto LABEL_4;
    case 2:
      write_output_payload_word(a1, 0);
      v2 = 0;
      goto LABEL_4;
    case 3:
      v3 = 0LL;
      write_output_payload_word(a1, 0);
      scmi_plat_ops(v13, &v12, 16LL);
      v4 = v12;
      if ( v12 > 0x10 )
        v4 = 16;
      v12 = v4;
      while ( (unsigned int)v3 < (v12 + 3) >> 2 )
      {
        v5 = v13[v3++];
        write_output_payload_word(a1, v5);
      }
      return 0LL;
    case 4:
      v6 = 0LL;
      write_output_payload_word(a1, 0);
      handle_scmi_vendor_protocol_msg(v13, &v12, 16LL);
      v7 = v12;
      if ( v12 > 0x10 )
        v7 = 16;
      v12 = v7;
      while ( (unsigned int)v6 < (v12 + 3) >> 2 )
      {
        v8 = v13[v6++];
        write_output_payload_word(a1, v8);
      }
      return 0LL;
    case 5:
      write_output_payload_word(a1, 0);
      v2 = 0x10000;
      goto LABEL_4;
    case 6:
      input_payload_char_at_offset = get_input_payload_char_at_offset(a1, 0);
      v10 = MEMORY[0x319B8](input_payload_char_at_offset, v13);
      write_output_payload_word(a1, 0);
      write_output_payload_word(a1, v10);
      v2 = v13[0];
      if ( v10 )
LABEL_4:
        write_output_payload_word(a1, v2);
      break;
    default:
      write_output_payload_word_at_offset(a1, -1, 0);
      break;
  }
  return 0LL;
}



__int64 __fastcall handle_scmi_clk_mgmt_protocol_msg(__int64 a1)
{
  int v2; // w1
  unsigned int input_payload_word_at_offset; // w20

  scmi_packet_init_payload(a1);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      write_output_payload_word(a1, 0);
      v2 = 0x10000;
      break;
    case 1:
      write_output_payload_word(a1, 0);
      v2 = scmi_num_clk_doms;
      break;
    case 2:
      write_output_payload_word(a1, 0);
      goto LABEL_9;
    case 3:
    case 4:
    case 5:
    case 6:
      v2 = -3;
      break;
    case 7:
      input_payload_word_at_offset = get_input_payload_word_at_offset(a1, 0);
      if ( (unsigned int)get_input_payload_word_at_offset(a1, 1) != 1 || !MEMORY[0x319B0] )
        goto LABEL_10;
      MEMORY[0x319B0](input_payload_word_at_offset);
LABEL_9:
      v2 = 0;
      break;
    default:
LABEL_10:
      v2 = -1;
      break;
  }
  write_output_payload_word(a1, v2);
  return 0LL;
}



unsigned __int64 __fastcall hoya_10_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFF7LL | 8);
    __isb(0xFu);
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 )
    {
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 3)) & 0xFFFFFFFFFFFF7FFFLL | 0x8000;
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 3, 3), result);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall hoya_10_cpuss_aarch64_por_sysini(__int64 result)
{
  int v1; // w2
  unsigned __int64 v2; // x4

  if ( (unsigned __int8)result == 1LL )
  {
    MEMORY[0x17E00058] = 9615380;
    MEMORY[0x17E00060] = MEMORY[0x17E00060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E10058] = 9615380;
    MEMORY[0x17E10060] = MEMORY[0x17E10060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E60058] = 9615380;
    MEMORY[0x17E60060] = MEMORY[0x17E60060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E70058] = 9615380;
    MEMORY[0x17E70060] = MEMORY[0x17E70060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E20058] = 9615380;
    MEMORY[0x17E20060] = MEMORY[0x17E20060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E30058] = 9615380;
    MEMORY[0x17E30060] = MEMORY[0x17E30060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E40058] = 9615380;
    MEMORY[0x17E40060] = MEMORY[0x17E40060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E50058] = 9615380;
    MEMORY[0x17E50060] = MEMORY[0x17E50060] & 0xFFFFFFFD | 2;
    MEMORY[0x17810058] = MEMORY[0x17810058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x17810068] = MEMORY[0x17810068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1781005C] = MEMORY[0x1781005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810060] = MEMORY[0x17810060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810064] = MEMORY[0x17810064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810054] = MEMORY[0x17810054] & 0xFFFFFC00 | 0x282;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271LL )
    {
      MEMORY[0x17990174] = MEMORY[0x17990174] & 0xFFFFFFFE | 1;
      __dmb(0xFu);
    }
    MEMORY[0x1799001C] &= ~0x800u;
    __dmb(0xFu);
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFBFFFFF | 0x400000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 || (MEMORY[0x1FC8000] | 0xFF) == 1610613503 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFEFFFFF | 0x100000;
      __dmb(0xFu);
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFF7FFFF | 0x80000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 || (MEMORY[0x1FC8000] | 0xFF) == 1610613503 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFF7FFFFF | 0x800000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    {
      MEMORY[0x17990028] &= ~0x20u;
      __dmb(0xFu);
    }
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    {
      result = 395903216LL;
      v1 = 20;
      v2 = (unsigned __int64)&SPI_CONFIGURATION_DATA_SDM845;
      do
      {
        *(_DWORD *)result &= ~*(_DWORD *)v2;
        result = (unsigned int)(result + 4);
        v2 = (unsigned int)(v2 + 4);
        --v1;
      }
      while ( v1 >= 0 );
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall hoya_10_interconnect_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    MEMORY[0x1790008C] = MEMORY[0x1790008C] & 0xFFFFFFE0 | 1;
    __dsb(0xFu);
    __isb(0xFu);
    result = 395313284LL;
    MEMORY[0x17900084] &= 0xFFFF00FF;
    __dmb(0xFu);
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}






unsigned __int64 __fastcall hoya_11_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 1uLL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFF7LL | 8);
    __isb(0xFu);
    result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 0));
    if ( (result & 0x400) != 0 )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 4, 4), 0x22222222uLL);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall hoya_11_cpuss_aarch64_por_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    if ( (MEMORY[0x17E00024] & 1) != 0 )
    {
      MEMORY[0x18000058] = 9615380;
      MEMORY[0x18000060] = MEMORY[0x18000060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 2) != 0 )
    {
      MEMORY[0x18010058] = 9615380;
      MEMORY[0x18010060] = MEMORY[0x18010060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 4) != 0 )
    {
      MEMORY[0x18020058] = 9615380;
      MEMORY[0x18020060] = MEMORY[0x18020060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 8) != 0 )
    {
      MEMORY[0x18030058] = 9615380;
      MEMORY[0x18030060] = MEMORY[0x18030060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x10) != 0 )
    {
      MEMORY[0x18040058] = 9615380;
      MEMORY[0x18040060] = MEMORY[0x18040060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x20) != 0 )
    {
      MEMORY[0x18050058] = 9615380;
      MEMORY[0x18050060] = MEMORY[0x18050060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x40) != 0 )
    {
      MEMORY[0x18060058] = 9615380;
      MEMORY[0x18060060] = MEMORY[0x18060060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x80) != 0 )
    {
      MEMORY[0x18070058] = 9615380;
      MEMORY[0x18070060] = MEMORY[0x18070060] & 0xFFFFFFFD | 2;
    }
    MEMORY[0x17E0041C] = 9615380;
    MEMORY[0x17E00434] = MEMORY[0x17E00434] & 0xFFFFFFFE | 1;
    MEMORY[0x18080058] = MEMORY[0x18080058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x18080068] = MEMORY[0x18080068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1808005C] = MEMORY[0x1808005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080060] = MEMORY[0x18080060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080064] = MEMORY[0x18080064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080054] = MEMORY[0x18080054] & 0xFFFFFC00 | 0x282;
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}





unsigned __int64 __fastcall hoya_20_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 1uLL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 0));
    if ( (result & 0x400) != 0 )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 4, 4), 0x22222222uLL);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall hoya_20_cpuss_aarch64_por_sysini(__int64 result)
{
  __int64 v1; // x2
  __int64 v2; // x5
  __int64 v3; // x6
  __int64 i; // x7
  __int64 v5; // x0
  int v6; // w2
  unsigned __int64 v7; // x4

  if ( (unsigned __int8)result == 1LL )
  {
    v1 = MEMORY[0x17E0002C];
    v2 = 402653272LL;
    v3 = 402653280LL;
    for ( i = 1LL; (i & v1) != 0; i *= 2LL )
    {
      *(_QWORD *)v2 = 11538461LL;
      *(_DWORD *)v3 = *(_DWORD *)v3 & 0xFFFFFFFD | 2;
      v2 += 0x10000LL;
      v3 += 0x10000LL;
    }
    MEMORY[0x17E0041C] = 9615380;
    MEMORY[0x17E00434] = MEMORY[0x17E00434] & 0xFFFFFFFE | 1;
    __dmb(0xFu);
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135LL )
      MEMORY[0x180801C4] = MEMORY[0x180801C4] & 0xFFFFFFF8 | 3;
    MEMORY[0x18080058] = MEMORY[0x18080058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x18080068] = MEMORY[0x18080068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1808005C] = MEMORY[0x1808005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080060] = MEMORY[0x18080060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080064] = MEMORY[0x18080064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080054] = MEMORY[0x18080054] & 0xFFFFFC00 | 0x282;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      MEMORY[0x17A20048] = MEMORY[0x17A20048] & 0xFFFFFEFF | 0x100;
      __dmb(0xFu);
      MEMORY[0x17A20088] = MEMORY[0x17A20088] & 0xFFFFFFF7 | 8;
      __dmb(0xFu);
      MEMORY[0x17A20088] = MEMORY[0x17A20088] & 0xFFFFFFFB | 4;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      MEMORY[0x17E00458] &= ~0x2000000u;
      MEMORY[0x17E00458] = MEMORY[0x17E00458] & 0x83FFFFFF | 0x14000000;
      MEMORY[0x17E00458] = MEMORY[0x17E00458] & 0xFFFFFFE0 | 1;
      MEMORY[0x17E0045C] &= 0xFFFFFFF0;
      MEMORY[0x17E00230] = MEMORY[0x17E00230] & 0xFFFEFFFF | 0x10000;
      MEMORY[0x17E00230] = MEMORY[0x17E00230] & 0xF0FFFFFF | 0x1000000;
      v5 = 398459120LL;
      v6 = 24;
      v7 = (unsigned __int64)&SPI_CONFIGURATION_DATA_SC7280;
      do
      {
        *(_DWORD *)v5 &= ~*(_DWORD *)v7;
        v5 = (unsigned int)(v5 + 4);
        v7 = (unsigned int)(v7 + 4);
        --v6;
      }
      while ( v6 >= 0 );
    }
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      result = 400556600LL;
      MEMORY[0x17E00238] = MEMORY[0x17E00238] & 0xFFFFFFFB | 4;
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 icbcfg_init()
{
  __int64 result; // x0
  unsigned int *v1; // x24
  __int64 v2; // x26
  unsigned int v3; // w21
  unsigned int v4; // w20
  unsigned int v5; // w22
  unsigned int i; // w23
  int *v7; // x19
  int v8; // w1
  int v9; // w2
  int v10; // w4
  int v11; // w1
  int v12; // w1
  int v13; // w1
  int v14; // w2
  int v15; // w3
  int v16; // w1
  int v17; // w2
  int v18; // w3
  int v19; // w2
  int v20; // w3
  int v21; // w4
  int v22; // w1
  int v23; // w2
  int v24; // w3
  int v25; // w5
  int v26; // w1
  int v27; // w2
  int v28; // w3
  int v29; // w5
  int v30; // w1
  int v31; // w27
  int v32; // w27
  int v33; // w27

  if ( !icb_dev_config_valid )
  {
    icb_dev_config = (__int64)*off_1A820;
    icb_dev_config_valid = 1;
  }
  result = (unsigned __int8)icb_dev_config_valid;
  if ( icb_dev_config_valid )
  {
    result = icb_dev_config;
    v1 = *(unsigned int **)(icb_dev_config + 48);
    if ( v1 )
    {
      v2 = *((_QWORD *)v1 + 1);
      v3 = 0;
      v4 = 0;
      v5 = 0;
      for ( i = 0; ; ++i )
      {
        result = *v1;
        if ( i >= (unsigned int)result )
          break;
        v7 = (int *)(v2 + 32LL * i);
        v8 = *v7;
        result = *((_QWORD *)v7 + 1);
        if ( !result && v8 != 1 )
          break;
        switch ( v8 )
        {
          case 1:
            return result;
          case 2:
            v9 = v7[4];
            v10 = v7[5];
            v11 = v7[6];
            if ( v9 == v10 )
              v12 = v9 & v11;
            else
              v12 = (v10 & *(_DWORD *)result ^ v11) & v9 ^ v10 & *(_DWORD *)result;
            goto LABEL_25;
          case 3:
            v13 = v7[4];
            v14 = v7[5];
            v15 = v7[6];
            if ( v13 == v14 )
              LOWORD(v13) = v15 & v13;
            else
              LOWORD(v13) = *(_WORD *)result & v14 ^ (*(_WORD *)result & v14 ^ v15) & v13;
            goto LABEL_29;
          case 4:
            v16 = v7[4];
            v17 = v7[5];
            v18 = v7[6];
            if ( v16 == v17 )
              LOBYTE(v16) = v18 & v16;
            else
              LOBYTE(v16) = *(_BYTE *)result & v17 ^ (*(_BYTE *)result & v17 ^ v18) & v16;
            goto LABEL_33;
          case 5:
            v5 = (v7[5] & (unsigned int)v7[4] & *(_DWORD *)result) >> v7[6];
            continue;
          case 6:
            v4 = (v7[5] & v7[4] & (unsigned int)*(unsigned __int16 *)result) >> v7[6];
            continue;
          case 7:
            v3 = (v7[5] & v7[4] & (unsigned int)*(unsigned __int8 *)result) >> v7[6];
            continue;
          case 8:
            v19 = v7[4];
            v20 = v7[5];
            v21 = v7[6];
            v22 = v19 & v5;
            if ( v19 == v20 )
              v12 = v22 << v21;
            else
              v12 = *(_DWORD *)result & ~v19 & v20 | (v22 << v21);
LABEL_25:
            *(_DWORD *)result = v12;
            continue;
          case 9:
            v23 = v7[4];
            v24 = v7[5];
            v25 = v7[6];
            v26 = v4 & v23;
            if ( v23 == v24 )
              v13 = v26 << v25;
            else
              v13 = (unsigned __int16)(*(_WORD *)result & v24) & ~v23 | (v26 << v25);
LABEL_29:
            *(_WORD *)result = v13;
            break;
          case 10:
            v27 = v7[4];
            v28 = v7[5];
            v29 = v7[6];
            v30 = v3 & v27;
            if ( v27 == v28 )
              v16 = v30 << v29;
            else
              v16 = (unsigned __int8)(*(_BYTE *)result & v28) & ~v27 | (v30 << v29);
LABEL_33:
            *(_BYTE *)result = v16;
            break;
          case 11:
            v31 = 1000;
            v5 = v7[5] & v7[4] & *(_DWORD *)result;
            do
            {
              if ( v7[6] == v5 )
                break;
              qtiseclib_cb_udelay(1LL);
              --v31;
              v5 = v7[5] & v7[4] & **((_DWORD **)v7 + 1);
            }
            while ( v31 );
            break;
          case 12:
            v32 = 1000;
            v4 = *(unsigned __int16 *)result & v7[5] & v7[4];
            do
            {
              if ( v4 == v7[6] )
                break;
              qtiseclib_cb_udelay(1LL);
              --v32;
              v4 = **((unsigned __int16 **)v7 + 1) & v7[5] & v7[4];
            }
            while ( v32 );
            break;
          case 13:
            v33 = 1000;
            v3 = *(unsigned __int8 *)result & v7[5] & v7[4];
            do
            {
              if ( v3 == v7[6] )
                break;
              qtiseclib_cb_udelay(1LL);
              --v33;
              v3 = **((unsigned __int8 **)v7 + 1) & v7[5] & v7[4];
            }
            while ( v33 );
            break;
          default:
            continue;
        }
      }
    }
  }
  return result;
}




__int64 __fastcall ICB_Get_AllowedMemRegion(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  __int64 v4; // x1
  int v5; // w2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  int v10; // w7
  _QWORD *v12; // x0
  __int64 v13; // [xsp+28h] [xbp-8h] BYREF

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 1LL;
  if ( !(unsigned __int8)get_device_configuration_isra_0(&v13)
    || (unsigned int)check_dupRegion(v13, v4, v5, v6, v7, v8, v9, v10) )
  {
    return 0xFFFFFFFFLL;
  }
  v12 = *(_QWORD **)(v13 + 16);
  *a2 = *v12;
  a2[1] = v12[1];
  return 0LL;
}



__int64 __fastcall ICB_Get_MCAddr(__int64 a1, __int64 a2, _QWORD *a3)
{
  bool v3; // zf
  char device_configuration_isra_0; // w0
  unsigned int v8; // w1
  __int64 v10; // [xsp+28h] [xbp-8h] BYREF

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 || a1 == 0 )
    return 1LL;
  device_configuration_isra_0 = get_device_configuration_isra_0(&v10);
  v8 = -1;
  if ( device_configuration_isra_0 )
  {
    v8 = 0;
    *a3 = a2;
  }
  return v8;
}



__int64 __fastcall ICB_Get_Memmap(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  char device_configuration_isra_0; // w0
  unsigned int v5; // w1
  __int64 v7; // [xsp+28h] [xbp-8h] BYREF

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 1LL;
  device_configuration_isra_0 = get_device_configuration_isra_0(&v7);
  v5 = -1;
  if ( device_configuration_isra_0 )
  {
    get_system_memory_map(v7, a2);
    return 0;
  }
  return v5;
}



__int64 __fastcall icbuarb_create_client(int a1, int a2)
{
  __int64 i; // x20
  _DWORD *v3; // x4
  __int64 v6; // x19
  __int64 v7; // x0
  unsigned int v8; // w20
  __int64 v9; // x0
  __int64 v10; // x21
  __int64 v11; // x0
  __int64 v12; // x0

  if ( info )
  {
    for ( i = 0LL; i != 8LL * *(unsigned int *)info; i += 8LL )
    {
      v3 = *(_DWORD **)(*(_QWORD *)(info + 8) + i);
      if ( v3 && *v3 == a1 && v3[1] == a2 )
      {
        v6 = qtisec_malloc(0x20uLL);
        if ( !v6 )
          return 0LL;
        v7 = *(_QWORD *)(*(_QWORD *)(info + 8) + i);
        v8 = 0;
        *(_DWORD *)v6 = a1;
        *(_DWORD *)(v6 + 4) = a2;
        *(_QWORD *)(v6 + 8) = v7;
        qtiseclib_cb_memset(v6 + 16, 0LL, 16LL);
        while ( 1 )
        {
          v9 = *(_QWORD *)(v6 + 8);
          if ( v8 >= *(_DWORD *)(v9 + 8) )
            break;
          v10 = 16LL * v8;
          v11 = *(_QWORD *)(*(_QWORD *)(v9 + 16) + v10);
          if ( v11 )
          {
            if ( !(unsigned __int8)add_sw_node_request((int *)(v11 + 32), v6 + 16) )
              break;
          }
          v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 16LL) + v10 + 8);
          if ( v12 )
          {
            if ( !(unsigned __int8)add_sw_node_request((int *)(v12 + 32), v6 + 16) )
              break;
          }
          ++v8;
        }
        if ( v8 < *(_DWORD *)(*(_QWORD *)(v6 + 8) + 8LL) )
        {
          remove_client_requests(v6);
          qtisec_free(v6);
          return 0LL;
        }
        return v6;
      }
    }
  }
  return 0LL;
}





__int64 __fastcall icbuarb_destroy_client(_QWORD *a1)
{
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  __int64 v9; // [xsp+0h] [xbp+0h]
  _QWORD v10[2]; // [xsp+20h] [xbp+20h] BYREF

  if ( !a1 )
    return 0LL;
  qtiseclib_cb_memset(v10, 0LL, 16LL);
  if ( !(unsigned __int8)icbuarb_issue_request(a1, v10, v2, v3, v4, v5, v6, v7, v9) )
    return 0LL;
  remove_client_requests((__int64)a1);
  qtisec_free((__int64)a1);
  return 1LL;
}



__int64 icbuarb_init()
{
  __int64 result; // x0
  unsigned int v1; // w21
  __int64 v2; // x19
  int v3; // w0
  __int64 v4; // x0
  __int64 v5; // x3
  __int64 v6; // x5
  __int64 v7; // x4
  __int64 v8; // x1
  __int64 v9; // x6
  __int64 v10; // x7
  unsigned int v11; // w2
  int v12; // w12
  int v13; // w13
  __int64 v14; // x8
  __int64 v15; // x3
  __int64 v16; // x5
  __int64 v17; // x4
  __int64 v18; // x1
  __int64 v19; // x6
  __int64 v20; // x7
  unsigned int v21; // w2
  int v22; // w12
  int v23; // w13
  __int64 v24; // x8
  char v25; // w0
  char v26; // [xsp+37h] [xbp+37h] BYREF
  int v27; // [xsp+38h] [xbp+38h] BYREF
  unsigned __int16 v28; // [xsp+3Ch] [xbp+3Ch]
  unsigned __int8 v29; // [xsp+3Eh] [xbp+3Eh]

  result = 1LL;
  if ( !info )
  {
    v1 = 0;
    info = (__int64)&target_info;
    while ( v1 < *(_DWORD *)(info + 48) )
    {
      v2 = *(_QWORD *)(*(_QWORD *)(info + 56) + 8LL * v1);
      v26 = 8;
      if ( (unsigned int)cmd_db_query_aux_data(*(_QWORD *)(v2 + 8), &v26, (__int64)&v27) )
        goto LABEL_23;
      ++v1;
      *(_DWORD *)(v2 + 20) = cmd_db_query_addr(*(_QWORD *)(v2 + 8));
      v3 = v28;
      *(_BYTE *)(v2 + 36) = 0;
      *(_DWORD *)(v2 + 24) = v3;
      *(_DWORD *)(v2 + 28) = v27;
      *(_DWORD *)(v2 + 32) = v29;
    }
    rpmh_handle = rpmh_create_handle(0, (__int64)"ICB");
    if ( !rpmh_handle )
    {
LABEL_23:
      v25 = 0;
      return v25 & 1;
    }
    v4 = info;
    v5 = 0LL;
    v6 = 8LL * *(unsigned int *)(info + 16);
    while ( v6 != v5 )
    {
      v7 = 0LL;
      v8 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + v5);
      v9 = 8LL * *(unsigned int *)(v8 + 48);
      while ( v7 != v9 )
      {
        v10 = *(_QWORD *)(*(_QWORD *)(v8 + 56) + v7);
        v11 = *(_DWORD *)(v10 + 64);
        if ( v11 < *(_DWORD *)(v10 + 68) )
        {
          v13 = *(_DWORD *)(v8 + 4);
          v12 = *(_DWORD *)(v8 + 8);
          v14 = *(_QWORD *)(v10 + 72) + 16LL * *(unsigned int *)(v10 + 64);
          *(_QWORD *)v14 = v8 + 16;
          *(_DWORD *)(v14 + 8) = v13;
          *(_DWORD *)(v14 + 12) = v12;
          *(_DWORD *)(v10 + 64) = v11 + 1;
        }
        v7 += 8LL;
      }
      v5 += 8LL;
    }
    v15 = 0LL;
    v16 = 8LL * *(unsigned int *)(v4 + 32);
    while ( v15 != v16 )
    {
      v17 = 0LL;
      v18 = *(_QWORD *)(*(_QWORD *)(v4 + 40) + v15);
      v19 = 8LL * *(unsigned int *)(v18 + 48);
      while ( v17 != v19 )
      {
        v20 = *(_QWORD *)(*(_QWORD *)(v18 + 56) + v17);
        v21 = *(_DWORD *)(v20 + 64);
        if ( v21 < *(_DWORD *)(v20 + 68) )
        {
          v23 = *(_DWORD *)(v18 + 4);
          v22 = *(_DWORD *)(v18 + 8);
          v24 = *(_QWORD *)(v20 + 72) + 16LL * *(unsigned int *)(v20 + 64);
          *(_QWORD *)v24 = v18 + 16;
          *(_DWORD *)(v24 + 8) = v23;
          *(_DWORD *)(v24 + 12) = v22;
          *(_DWORD *)(v20 + 64) = v21 + 1;
        }
        v17 += 8LL;
      }
      v15 += 8LL;
    }
    v25 = icbuarb_target_init(v4);
    return v25 & 1;
  }
  return result;
}



__int64 __fastcall icbuarb_issue_request(
        _QWORD *a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x8
  __int64 result; // x0
  __int64 v12; // x11
  unsigned int i; // w10
  __int64 v14; // x12
  __int64 v15; // x9
  __int64 v16; // x9
  __int64 v17; // x9
  char v18; // w13
  __int64 v19; // x0
  __int64 v20; // x1
  __int64 v21; // x2
  __int64 v22; // x9
  char v23; // w13
  __int64 v24; // x0
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x9
  int v28; // w11
  __int64 v29; // x4
  __int64 v30; // x12
  __int64 v31; // x1
  __int64 v32; // x0
  int v33; // w13
  __int64 v34; // x5
  unsigned __int64 v35; // x1
  unsigned __int64 v36; // x3
  int v37; // w2
  __int64 v38; // x18
  unsigned __int64 *v39; // x14
  __int64 v40; // x7
  unsigned int v41; // w2
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x6
  unsigned __int64 v44; // x7
  unsigned __int64 v45; // x2
  unsigned __int64 v46; // x2
  unsigned __int64 v47; // x5
  unsigned __int64 v48; // x1
  unsigned __int64 v49; // x2
  int v50; // w1
  __int64 v51; // x1
  _QWORD *v52; // x2
  unsigned int v53; // w21
  __int64 j; // x0
  _DWORD *v55; // x1
  __int64 v56; // x5
  unsigned int v57; // w2
  char *v58; // x4
  int v59; // w3
  int v60; // w3
  char *v62; // x0
  int v63; // w0
  int v64; // w20
  unsigned int v65[52]; // [xsp+40h] [xbp-D0h] BYREF

  v9 = info;
  if ( !info )
    return 0LL;
  if ( !a1 || a2 == 0LL )
    return 0LL;
  v12 = a1[1];
  a1[2] = *a2;
  a1[3] = a2[1];
  if ( !v12 )
    return 0LL;
  for ( i = 0; i < *(_DWORD *)(v12 + 8); ++i )
  {
    v14 = 16LL * i;
    v15 = *(_QWORD *)(*(_QWORD *)(v12 + 16) + v14);
    if ( v15 )
    {
      aggregate_sw_node((unsigned int *)(v15 + 32), (_QWORD *)(v15 + 16));
      v19 = 0LL;
      v20 = 8LL * *(unsigned int *)(v17 + 48);
      while ( v19 != v20 )
      {
        v21 = *(_QWORD *)(*(_QWORD *)(v17 + 56) + v19);
        v19 += 8LL;
        *(_BYTE *)(v21 + 36) = v18;
      }
    }
    v16 = *(_QWORD *)(*(_QWORD *)(v12 + 16) + v14 + 8);
    if ( v16 )
    {
      aggregate_sw_node((unsigned int *)(v16 + 32), (_QWORD *)(v16 + 16));
      v24 = 0LL;
      v25 = 8LL * *(unsigned int *)(v22 + 48);
      while ( v24 != v25 )
      {
        v26 = *(_QWORD *)(*(_QWORD *)(v22 + 56) + v24);
        v24 += 8LL;
        *(_BYTE *)(v26 + 36) = v23;
      }
    }
  }
  v27 = 0LL;
  v28 = 0;
  v29 = commit_queue;
  v30 = 8LL * *(unsigned int *)(v9 + 48);
  while ( v27 != v30 )
  {
    v31 = v29;
    v32 = *(_QWORD *)(*(_QWORD *)(v9 + 56) + v27);
    v33 = *(unsigned __int8 *)(v32 + 36);
    if ( *(_BYTE *)(v32 + 36) )
    {
      v34 = 0LL;
      v35 = 0LL;
      v36 = 0LL;
      while ( 1 )
      {
        v37 = *(_DWORD *)(v32 + 16);
        if ( v34 == 16LL * *(unsigned int *)(v32 + 64) )
          break;
        v38 = *(_QWORD *)(v32 + 72) + v34;
        v39 = *(unsigned __int64 **)v38;
        if ( v37 )
        {
          if ( v36 < v39[1] )
            v36 = v39[1];
          v46 = *v39;
        }
        else
        {
          v40 = *(unsigned int *)(v32 + 24);
          v41 = *(_DWORD *)(v38 + 8);
          v42 = v40 * v39[1];
          v43 = v42 / v41;
          if ( v42 % v41 )
            ++v43;
          if ( v36 < v43 )
            v36 = v43;
          v44 = v40 * *v39;
          v45 = v41 * *(_DWORD *)(v38 + 12);
          if ( v44 % v45 )
            v46 = v44 / v45 + 1;
          else
            v46 = v44 / v45;
        }
        v34 += 16LL;
        if ( v35 < v46 )
          v35 = v46;
      }
      *(_QWORD *)(v32 + 48) = v35;
      *(_QWORD *)(v32 + 56) = v36;
      if ( v37 )
      {
        *(_DWORD *)(v32 + 40) = 0;
      }
      else
      {
        v47 = *(unsigned int *)(v32 + 28);
        if ( v35 % v47 )
          v48 = v35 / v47 + 1;
        else
          v48 = v35 / v47;
        v49 = v36 / v47;
        if ( v48 > 0x3FFF )
          LODWORD(v48) = 0x3FFF;
        if ( v36 % v47 )
          ++v49;
        if ( v49 > 0x3FFF )
          LODWORD(v49) = 0x3FFF;
        *(_DWORD *)(v32 + 40) = v49 | ((_DWORD)v48 << 14);
      }
      v50 = *(_DWORD *)(v32 + 40);
      if ( v50 )
        *(_DWORD *)(v32 + 40) = v50 | 0x20000000;
      v51 = v29;
      v52 = 0LL;
      while ( v51 && *(_DWORD *)(v32 + 32) >= *(_DWORD *)(v51 + 32) )
      {
        v52 = (_QWORD *)v51;
        v51 = *(_QWORD *)v51;
      }
      if ( v51 == v29 )
      {
        *(_QWORD *)v32 = v51;
        v31 = v32;
      }
      else
      {
        *v52 = v32;
        v33 = v28;
        *(_QWORD *)v32 = v51;
        v31 = v29;
      }
      v28 = v33;
      *(_BYTE *)(v32 + 36) = 0;
    }
    v27 += 8LL;
    v29 = v31;
  }
  if ( v28 )
    commit_queue = v29;
  result = 1LL;
  if ( commit_queue )
  {
    v53 = 0;
    qtiseclib_cb_memset(v65, 0LL, 204LL);
    for ( j = 0LL; ; j = v57 )
    {
      v55 = (_DWORD *)commit_queue;
      if ( !commit_queue )
        break;
      v56 = *(_QWORD *)commit_queue;
      v57 = j + 1;
      *(_QWORD *)commit_queue = 0LL;
      v58 = (char *)&a9 + 12 * (unsigned int)j;
      v59 = v55[5];
      commit_queue = v56;
      *((_DWORD *)v58 - 49) = v59;
      v60 = v55[10];
      *((_DWORD *)v58 - 48) = v60;
      if ( v56 )
      {
        if ( v55[8] == *(_DWORD *)(v56 + 32) && v57 != 16 )
          continue;
      }
      v62 = (char *)&a9 + 12 * j;
      v65[0] = 0;
      v65[1] = v57;
      *((_DWORD *)v62 - 48) = v60 | 0x40000000;
      *(v62 - 188) = 1;
      v63 = rpmh_issue_command_set(rpmh_handle, v65);
      if ( v63 )
        v64 = v63;
      else
        v64 = v53;
      v53 = v64;
      qtiseclib_cb_memset(v65, 0LL, 204LL);
      v57 = 0;
    }
    rpmh_barrier_all(rpmh_handle, v53);
    return 1LL;
  }
  return result;
}





__int64 icbuarb_target_d4_entry()
{
  __int64 result; // x0
  unsigned int v1; // w0
  unsigned int v2; // w22
  unsigned int v3[4]; // [xsp+30h] [xbp+30h] BYREF
  int v4; // [xsp+40h] [xbp+40h]
  char v5; // [xsp+44h] [xbp+44h]

  result = (unsigned __int8)initialized;
  if ( initialized )
  {
    result = *(unsigned int *)(mm_node + 40);
    if ( !(_DWORD)result )
    {
      qtiseclib_cb_memset(v3, 0LL, 204LL);
      v3[0] = 0;
      v3[1] = 1;
      v1 = *(_DWORD *)(mm_node + 20);
      v5 = 1;
      v3[3] = v1;
      v4 = 1610612737;
      v2 = rpmh_issue_command_set(rpmh_wa_handle, v3);
      v5 = 1;
      v3[0] = 2;
      v4 = 1610612737;
      rpmh_issue_command_set(rpmh_wa_handle, v3);
      v5 = 0;
      v3[0] = 1;
      v4 = 0x40000000;
      rpmh_issue_command_set(rpmh_wa_handle, v3);
      return rpmh_barrier_single(rpmh_wa_handle, v2);
    }
  }
  return result;
}



__int64 icbuarb_target_d4_exit()
{
  __int64 result; // x0
  unsigned int v1; // w0
  unsigned int v2[5]; // [xsp+20h] [xbp+20h] BYREF
  char v3; // [xsp+34h] [xbp+34h]

  result = (unsigned __int8)initialized;
  if ( initialized )
  {
    result = *(unsigned int *)(mm_node + 40);
    if ( !(_DWORD)result )
    {
      rpmh_invalidate_explicit_cmds(rpmh_wa_handle);
      qtiseclib_cb_memset(v2, 0LL, 204LL);
      v2[0] = 0;
      v2[1] = 1;
      v1 = *(_DWORD *)(mm_node + 20);
      v3 = 0;
      v2[3] = v1;
      v2[4] = 0x40000000;
      return rpmh_issue_command_set(rpmh_wa_handle, v2);
    }
  }
  return result;
}



__int64 __fastcall icbuarb_target_init(__int64 a1)
{
  int addr; // w0
  __int64 v3; // x2
  __int64 v4; // x1

  addr = cmd_db_query_addr((__int64)"MM1");
  v3 = 0LL;
  while ( v3 != 8LL * *(unsigned int *)(a1 + 48) )
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + v3);
    v3 += 8LL;
    if ( addr == *(_DWORD *)(v4 + 20) )
      goto LABEL_6;
  }
  v4 = 0LL;
LABEL_6:
  mm_node = v4;
  if ( v4 )
  {
    rpmh_wa_handle = rpmh_create_handle_explicit(0, (__int64)"ICB");
    if ( rpmh_wa_handle )
      initialized = 1;
  }
  return (unsigned __int8)initialized;
}









unsigned int *__fastcall inq_append(unsigned int *result, __int64 a2)
{
  __int64 v2; // x3
  __int64 v3; // x2

  v2 = *((_QWORD *)result + 2);
  v3 = *result;
  if ( v2 )
  {
    *(_QWORD *)(v2 + v3) = a2;
    *(_QWORD *)(a2 + v3) = 0LL;
    *((_QWORD *)result + 2) = a2;
  }
  else
  {
    *((_QWORD *)result + 1) = a2;
    *((_QWORD *)result + 2) = a2;
    *(_QWORD *)(a2 + v3) = 0LL;
  }
  ++result[1];
  return result;
}



_DWORD *__fastcall inq_create(int a1)
{
  _DWORD *v2; // x19

  v2 = (_DWORD *)rpmh_malloc(0x18u);
  rpmh_core_verify_ptr((__int64)v2);
  qtiseclib_cb_memset(v2, 0LL, 24LL);
  *v2 = a1;
  return v2;
}




__int64 __fastcall inq_head(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}



__int64 __fastcall inq_it_begin(__int64 a1, _QWORD *a2)
{
  __int64 result; // x0

  *a2 = a1;
  a2[1] = 0LL;
  result = *(_QWORD *)(a1 + 8);
  a2[2] = result;
  return result;
}



__int64 __fastcall inq_it_delete(unsigned int **a1)
{
  __int64 result; // x0
  unsigned int *v3; // x2
  unsigned int *v4; // x3
  unsigned int **v5; // x19
  __int64 v6; // x4

  result = (__int64)a1[2];
  if ( result )
  {
    v3 = *a1;
    v4 = a1[1];
    if ( v4 )
    {
      v6 = *v3;
      *(_QWORD *)((char *)v4 + v6) = *(_QWORD *)(result + v6);
      a1[2] = *(unsigned int **)(result + v6);
      if ( result == *((_QWORD *)v3 + 2) )
        *((_QWORD *)v3 + 2) = v4;
      --v3[1];
    }
    else
    {
      v5 = a1;
      rpmh_core_verify(*((_QWORD *)v3 + 1) == result);
      result = inq_pop(*v5);
      v5[2] = (unsigned int *)*((_QWORD *)*v5 + 1);
    }
  }
  return result;
}



__int64 __fastcall inq_it_deref(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}



unsigned int *__fastcall inq_it_insert(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // x2
  unsigned int *v5; // x0
  unsigned int *result; // x0
  unsigned int *v7; // x1
  unsigned int *v8; // x0
  __int64 v9; // x0
  unsigned int *v10; // x1
  unsigned int v11; // w0

  v2 = a1[2];
  v5 = *a1;
  if ( v2 )
  {
    v7 = a1[1];
    if ( v7 )
    {
      v9 = *v5;
      *(_QWORD *)(a2 + v9) = v2;
      *(_QWORD *)((char *)v7 + v9) = a2;
    }
    else
    {
      rpmh_core_verify(*((_QWORD *)v5 + 1) == (_QWORD)v2);
      v8 = *a1;
      *(_QWORD *)(a2 + **a1) = *((_QWORD *)*a1 + 1);
      *((_QWORD *)v8 + 1) = a2;
    }
    v10 = *a1;
    v11 = (*a1)[1];
    a1[2] = (unsigned int *)a2;
    result = (unsigned int *)(v11 + 1);
    v10[1] = (unsigned int)result;
  }
  else
  {
    a1[1] = (unsigned int *)*((_QWORD *)v5 + 2);
    result = inq_append(v5, a2);
    a1[2] = (unsigned int *)a2;
  }
  return result;
}



unsigned int **__fastcall inq_it_next(unsigned int **result)
{
  unsigned int *v1; // x1

  v1 = result[2];
  result[1] = v1;
  if ( v1 )
    result[2] = *(unsigned int **)((char *)v1 + **result);
  return result;
}



__int64 __fastcall inq_pop(unsigned int *a1)
{
  unsigned int v1; // w2
  __int64 v2; // x1
  __int64 v3; // x3
  __int64 v4; // x4

  v1 = a1[1];
  if ( !v1 )
    return 0LL;
  v2 = *((_QWORD *)a1 + 1);
  v3 = *a1;
  v4 = *(_QWORD *)(v2 + v3);
  *((_QWORD *)a1 + 1) = v4;
  if ( !v4 )
    *((_QWORD *)a1 + 2) = 0LL;
  *(_QWORD *)(v2 + v3) = 0LL;
  a1[1] = v1 - 1;
  return v2;
}



__int64 __fastcall inq_size(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}



__int64 __fastcall interconnect_aarch64_sysini(__int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    return hoya_10_interconnect_aarch64_sysini(result);
  return result;
}




__int64 __fastcall int_svc_core_pos_to_mpidr(unsigned int a1)
{
  if ( a1 > 7 )
    qtisec_assert("noship_src/services/int_svc/int_svc.c", 0xCBu, "core_pos < QTISECLIB_PLAT_CORE_COUNT");
  if ( g_mpidr_map[a1] == 57005LL )
    qtisec_assert("noship_src/services/int_svc/int_svc.c", 0xCCu, "INVALID_MPIDR != g_mpidr_map[core_pos]");
  return g_mpidr_map[a1];
}



__int64 int_svc_init()
{
  __int64 i; // x0

  for ( i = 0LL; i != 8; ++i )
    g_mpidr_map[i] = 57005LL;
  return int_svc_notify_cpu_state(1LL);
}



bool __fastcall int_svc_is_cpu_on(char a1)
{
  int v2; // w19

  qtiseclib_cb_spin_lock(&g_int_svc_cpu_state_lock);
  v2 = (char)((1 << a1) & g_int_cpu_on_state);
  qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
  return v2 != 0;
}



__int64 __fastcall int_svc_notify_cpu_state(__int64 a1)
{
  int v1; // w23
  unsigned int v2; // w0
  unsigned int v3; // w24
  int v4; // w1
  unsigned int v5; // w19
  char v6; // w23
  int v7; // w0
  unsigned int v8; // w19
  int v9; // w19
  int v10; // w0
  int v11; // w1
  __int64 v12; // x0

  v1 = a1;
  v2 = qtiseclib_cb_plat_my_core_pos(a1);
  v3 = v2;
  if ( g_mpidr_map[v2] == 57005LL )
    g_mpidr_map[v2] = _ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 5));
  qtiseclib_cb_spin_lock(&g_int_svc_cpu_state_lock);
  if ( v1 == 1 )
  {
    v4 = 1 << v3;
    if ( (((int)(unsigned __int8)g_int_cpu_on_state >> g_int_swdog_target) & 1LL) != 0 )
      v5 = 255;
    else
      v5 = v3;
    g_int_cpu_on_state |= v4;
    g_int_cpu_interruptible_state |= v4;
    if ( v5 == 255 )
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    if ( v5 > 7 )
      qtisec_assert("noship_src/services/int_svc/int_svc.c", 0x140u, "new_sec_wdog_target < QTISECLIB_PLAT_CORE_COUNT");
  }
  else if ( v1 )
  {
    if ( v3 != (unsigned __int8)g_int_swdog_target )
    {
      g_int_cpu_on_state &= ~(1 << v3);
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    }
    v9 = (unsigned __int8)g_int_cpu_on_state;
    v10 = (unsigned __int8)g_int_cpu_on_state - 1;
    v11 = (unsigned __int8)g_int_cpu_on_state & ~(1 << v3);
    g_int_cpu_on_state &= ~(1 << v3);
    if ( (v10 & v9) == 0 )
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    v5 = __clz(__rbit32(v11));
  }
  else
  {
    v6 = ~(1 << v3);
    v7 = (unsigned __int8)(v6 & g_int_cpu_interruptible_state);
    g_int_cpu_interruptible_state &= v6;
    if ( v3 != (unsigned __int8)g_int_swdog_target )
    {
      g_int_cpu_on_state &= v6;
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    }
    if ( ((unsigned __int8)(g_int_cpu_on_state - 1) & (unsigned __int8)g_int_cpu_on_state) != 0 )
    {
      v8 = (unsigned __int8)(v6 & g_int_cpu_on_state);
      g_int_cpu_on_state &= v6;
    }
    else
    {
      if ( !v7 )
        qtisec_assert("noship_src/services/int_svc/int_svc.c", 0x115u, "0 != g_int_cpu_interruptible_state");
      g_int_cpu_on_state &= v6;
      v8 = (unsigned __int8)g_int_cpu_interruptible_state;
    }
    v5 = __clz(__rbit32(v8));
  }
  if ( (((int)(unsigned __int8)g_int_cpu_interruptible_state >> v5) & 1) == 0 )
    qtisec_assert(
      "noship_src/services/int_svc/int_svc.c",
      0x141u,
      "g_int_cpu_interruptible_state & (1 << new_sec_wdog_target)");
  v12 = int_svc_core_pos_to_mpidr(v5);
  qtiseclib_cb_set_spi_routing(516LL, 0LL, v12);
  g_int_swdog_target = v5;
  return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
}



  v0 = int_svc_register_isr(
         230,
         (__int64)"VMIDMT CTL Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_clt_sec_ctx);
  v1 = v0 | int_svc_register_isr(
              231,
              (__int64)"VMIDMT CTL NSec",
              0x10uLL,
              (__int64)vmidmt_error_handler,
              (__int64)&vmidmt_err_clt_nonsec_ctx);
  v2 = int_svc_register_isr(
         232,
         (__int64)"VMIDMT CFG Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_cfg_sec_ctx);
  result = v2 | (unsigned int)int_svc_register_isr(
                                233,
                                (__int64)"VMIDMT CFG NSec",
                                0x10uLL,
                                (__int64)vmidmt_error_handler,
                                (__int64)&vmidmt_err_cfg_nonsec_ctx) | v1;
  MEMORY[0x1FC5040] = -1;
  MEMORY[0x1FC3040] = -1;
  MEMORY[0x1FC4050] = -1;
  MEMORY[0x1FC2050] = -1;
  return result;
}



__int64 __fastcall int_svc_unregister_isr(int a1)
{
  __int64 v2; // x1
  unsigned int v3; // w20

  qtiseclib_cb_spin_lock(&g_int_svc_fiq_lock);
  v2 = 0LL;
  while ( g_isrs[34 * v2] != a1 )
  {
    if ( ++v2 == 32 )
    {
      v3 = -1;
      goto LABEL_6;
    }
  }
  v3 = 0;
  qtiseclib_cb_memset(&g_isrs[34 * (unsigned int)v2], 0LL, 136LL);
LABEL_6:
  qtiseclib_cb_spin_unlock(&g_int_svc_fiq_lock);
  return v3;
}



bool __fastcall is_amc_finished(int a1)
{
  unsigned int v1; // w0
  __int64 v2; // x0
  int v4; // [xsp+1Ch] [xbp+1Ch] BYREF

  v1 = lookup_drv_index(a1);
  v2 = (unsigned int)RscHalCheckAMCFinishedIRQ(*((_DWORD *)&_compound_literal_1_2 + 12 * v1 + 1), &v4) == 0;
  rpmh_core_verify(v2);
  return v4 != 0;
}



__int64 __fastcall is_amc_free(int a1)
{
  __int64 v1; // x19
  __int64 v2; // x21
  char *v3; // x20
  _QWORD *v4; // x19
  __int64 i; // x0
  __int64 v6; // x2

  v1 = (unsigned int)lookup_drv_index(a1);
  v2 = 4 * v1;
  v3 = (char *)&_compound_literal_1_2 + 48 * v1;
  rpmh_core_verify(**(_DWORD **)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4 * v1)) != 0);
  v4 = (_QWORD *)(rpmh_tcs + 8 * v1);
  for ( i = 0LL; i != 24LL * **(unsigned int **)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + v2)); i += 24LL )
  {
    v6 = *v4 + i;
    if ( !*(_DWORD *)(v6 + 4) )
      return 1LL;
  }
  return 0LL;
}



__int64 __fastcall isContextInitialized(_BYTE *a1, unsigned int a2)
{
  __int64 result; // x0

  if ( a2 <= 2 )
  {
    if ( a1 )
    {
      result = 4294967290LL;
      if ( *a1 )
      {
        if ( a1[32 * a2 + 28] )
          return 0LL;
        else
          return 4294967290LL;
      }
    }
    else
    {
      return 4294967290LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  return result;
}



__int64 is_rpmh_busy()
{
  return (unsigned __int8)rpmh_is_processing;
}



__int64 __fastcall is_tcs_stuck(int a1)
{
  __int64 v1; // x19
  unsigned int v2; // w22
  unsigned int v3; // w0
  char *v4; // x20
  __int64 v5; // x23
  __int64 v6; // x21
  __int64 v7; // x0
  char v9; // [xsp+6Fh] [xbp+6Fh] BYREF

  v1 = 0LL;
  v2 = 0;
  v3 = lookup_drv_index(a1);
  v4 = (char *)&_compound_literal_1_2 + 48 * v3;
  v5 = 4LL * v3;
  v6 = 8LL * v3;
  while ( **(_DWORD **)(*((_QWORD *)v4 + 5) + 8LL * *(unsigned int *)(tcs_mode + v5)) > (unsigned int)v1 )
  {
    v7 = (unsigned int)RscHalIsTCSIdle(*((_DWORD *)v4 + 1), v4[20] + (unsigned __int8)v1, &v9) == 0;
    rpmh_core_verify(v7);
    if ( !v9
      && rpmh_get_timestamp() > (unsigned __int64)(*(_QWORD *)(*(_QWORD *)(rpmh_tcs + v6) + 24 * v1 + 8) + 192000LL) )
    {
      v2 = 1;
      rpmh_core_verify(1LL);
    }
    ++v1;
  }
  return v2;
}



unsigned __int64 __fastcall kryo400_gold_aarch64_config_wa_sysini(unsigned __int64 result, int a2)
{
  if ( (_DWORD)result == -2147450881 )
  {
    if ( a2 )
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFEFFFFLL | 0x10000;
    else
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFEFFFFLL;
    _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1), result);
  }
  __isb(0xFu);
  return result;
}



__int64 __fastcall kryo400_gold_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFELL | 1);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    result = 269LL;
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall kryo400_silver_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 5, 3, 0), 0x40000000uLL);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8500020uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00000uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8D00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}



__int64 __fastcall kryo500_silver_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 5, 3, 0), 0x40000000uLL);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    if ( MEMORY[0x1FC8000] == 1612185856LL )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFDFFFFFLL);
      __isb(0xFu);
    }
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8500020uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00000uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8D00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}







__int64 lmh_target_config_init()
{
  __int64 result; // x0

  result = (unsigned __int8)lmh_enable;
  if ( lmh_enable )
  {
    qtiseclib_cb_memcpy(lmh_hsr_version, "1.0", 10LL);
    MEMORY[0x18378094] = 1;
    MEMORY[0x18378100] = 0;
    MEMORY[0x18378380] = 15;
    MEMORY[0x18378390] = 257;
    MEMORY[0x18378394] = 258;
    MEMORY[0x18378398] = 259;
    MEMORY[0x1837839C] = 260;
    MEMORY[0x183783A0] = 261;
    MEMORY[0x183783A4] = 262;
    MEMORY[0x18378410] = 1114112;
    MEMORY[0x18378580] = 113;
    MEMORY[0x18378600] = 18;
    MEMORY[0x18378614] = 193;
    MEMORY[0x18378620] = 193;
    MEMORY[0x18378694] = 1182721;
    MEMORY[0x183786A0] = 1117185;
    MEMORY[0x18378B00] = 18;
    MEMORY[0x18378B14] = 1;
    MEMORY[0x18378B20] = 4;
    MEMORY[0x18378B94] = 65537;
    MEMORY[0x18378BA0] = 65537;
    MEMORY[0x18378C14] = 1170;
    MEMORY[0x18378C20] = 1150;
    MEMORY[0x18378C94] = 51216;
    MEMORY[0x18378CA0] = 12817;
    MEMORY[0x18378D80] = 12;
    MEMORY[0x18378D98] = 2;
    MEMORY[0x18378D9C] = 16;
    MEMORY[0x18378E9C] = 3585;
    MEMORY[0x18378F18] = 50364417;
    MEMORY[0x18379080] = 3;
    MEMORY[0x18379090] = 2;
    MEMORY[0x18379094] = 3;
    MEMORY[0x18379110] = 272;
    MEMORY[0x18379114] = 16;
    MEMORY[0x18379194] = 196671;
    MEMORY[0x18379198] = 327805;
    MEMORY[0x1837919C] = 524476;
    MEMORY[0x183791A0] = 655610;
    MEMORY[0x183791A4] = 786745;
    MEMORY[0x183791A8] = 852343;
    MEMORY[0x183791AC] = 983478;
    MEMORY[0x183791B0] = 1049076;
    MEMORY[0x183791B4] = 1180211;
    MEMORY[0x183791B8] = 1245809;
    MEMORY[0x183791BC] = 1376944;
    MEMORY[0x183791C0] = 1442542;
    MEMORY[0x183791C4] = 1508141;
    MEMORY[0x183791C8] = 1573739;
    MEMORY[0x183791CC] = 1639338;
    MEMORY[0x183791D0] = 2161688;
    MEMORY[0x183791D4] = 1113612;
    MEMORY[0x183791D8] = 589574;
    MEMORY[0x183791DC] = 327555;
    MEMORY[0x183791E0] = 196545;
    MEMORY[0x183791E4] = 131041;
    MEMORY[0x183791E8] = 131056;
    MEMORY[0x183791F0] = -65520;
    MEMORY[0x183791F4] = -65505;
    MEMORY[0x183791F8] = -131009;
    MEMORY[0x183791FC] = -262019;
    MEMORY[0x18379200] = -524038;
    MEMORY[0x18379204] = -1048076;
    MEMORY[0x18379208] = -2096152;
    MEMORY[0x1837920C] = -2096152;
    MEMORY[0x18379A80] = 1;
    MEMORY[0x18378090] = 17;
    MEMORY[0x18370094] = 1;
    MEMORY[0x18370100] = 1;
    MEMORY[0x18370110] = 48;
    MEMORY[0x18370380] = 2047;
    MEMORY[0x18370390] = 263;
    MEMORY[0x18370394] = 264;
    MEMORY[0x18370398] = 265;
    MEMORY[0x1837039C] = 266;
    MEMORY[0x183703A0] = 267;
    MEMORY[0x183703A4] = 268;
    MEMORY[0x183703A8] = 269;
    MEMORY[0x183703AC] = 270;
    MEMORY[0x183703B0] = 261;
    MEMORY[0x183703B4] = 262;
    MEMORY[0x183703B8] = 5;
    MEMORY[0x18370410] = 1114112;
    MEMORY[0x18370448] = 78643217;
    MEMORY[0x18370580] = 113;
    MEMORY[0x18370600] = 2555;
    MEMORY[0x18370614] = 193;
    MEMORY[0x1837061C] = 1;
    MEMORY[0x18370620] = 33;
    MEMORY[0x18370624] = 65;
    MEMORY[0x18370628] = 97;
    MEMORY[0x18370630] = 193;
    MEMORY[0x1837063C] = 161;
    MEMORY[0x18370694] = 1182721;
    MEMORY[0x1837069C] = 1182721;
    MEMORY[0x183706A0] = 1182721;
    MEMORY[0x183706A4] = 1182721;
    MEMORY[0x183706A8] = 1182721;
    MEMORY[0x183706AC] = 2049;
    MEMORY[0x183706B0] = 1117185;
    MEMORY[0x18370B00] = 2555;
    MEMORY[0x18370B14] = 1;
    MEMORY[0x18370B1C] = 3;
    MEMORY[0x18370B20] = 4;
    MEMORY[0x18370B24] = 5;
    MEMORY[0x18370B28] = 6;
    MEMORY[0x18370B2C] = 7;
    MEMORY[0x18370B30] = 8;
    MEMORY[0x18370B3C] = 11;
    MEMORY[0x18370B90] = 1;
    MEMORY[0x18370B94] = 65537;
    MEMORY[0x18370B9C] = 65537;
    MEMORY[0x18370BA0] = 65537;
    MEMORY[0x18370BA4] = 65537;
    MEMORY[0x18370BA8] = 65537;
    MEMORY[0x18370BAC] = 1;
    MEMORY[0x18370BB0] = 65537;
    MEMORY[0x18370BBC] = 1;
    MEMORY[0x18370C10] = 14945208;
    MEMORY[0x18370C14] = 1170;
    MEMORY[0x18370C1C] = 900;
    MEMORY[0x18370C20] = 900;
    MEMORY[0x18370C24] = 900;
    MEMORY[0x18370C28] = 900;
    MEMORY[0x18370C2C] = 14945208;
    MEMORY[0x18370C30] = 1150;
    MEMORY[0x18370C3C] = 14943408;
    MEMORY[0x18370C90] = 2064;
    MEMORY[0x18370C94] = 51216;
    MEMORY[0x18370CAC] = 2065;
    MEMORY[0x18370CB0] = 12817;
    MEMORY[0x18370D80] = 252;
    MEMORY[0x18370D98] = 2051;
    MEMORY[0x18370D9C] = 8;
    MEMORY[0x18370DA0] = 16;
    MEMORY[0x18370DA4] = 32;
    MEMORY[0x18370DA8] = 64;
    MEMORY[0x18370DAC] = 384;
    MEMORY[0x18370EAC] = 3585;
    MEMORY[0x18370F18] = 50364417;
    MEMORY[0x18371080] = 33;
    MEMORY[0x18371090] = 2;
    MEMORY[0x18371094] = 3;
    MEMORY[0x18371098] = 4;
    MEMORY[0x1837109C] = 5;
    MEMORY[0x183710A0] = 6;
    MEMORY[0x183710A4] = 7;
    MEMORY[0x18371110] = 272;
    MEMORY[0x18371114] = 272;
    MEMORY[0x18371118] = 272;
    MEMORY[0x1837111C] = 272;
    MEMORY[0x18371120] = 272;
    MEMORY[0x18371124] = 16;
    MEMORY[0x18371194] = 196671;
    MEMORY[0x18371198] = 327805;
    MEMORY[0x1837119C] = 524476;
    MEMORY[0x183711A0] = 655610;
    MEMORY[0x183711A4] = 786745;
    MEMORY[0x183711A8] = 852343;
    MEMORY[0x183711AC] = 983478;
    MEMORY[0x183711B0] = 1049076;
    MEMORY[0x183711B4] = 1180211;
    MEMORY[0x183711B8] = 1245809;
    MEMORY[0x183711BC] = 1376944;
    MEMORY[0x183711C0] = 1442542;
    MEMORY[0x183711C4] = 1508141;
    MEMORY[0x183711C8] = 1573739;
    MEMORY[0x183711CC] = 1639338;
    MEMORY[0x183711D0] = 196608;
    MEMORY[0x183711D4] = 8388613;
    MEMORY[0x183711D8] = 10747914;
    MEMORY[0x183711DC] = 13107215;
    MEMORY[0x183711E0] = 13369364;
    MEMORY[0x183711E4] = 8454169;
    MEMORY[0x183711E8] = 10813470;
    MEMORY[0x183711EC] = 13172771;
    MEMORY[0x183711F0] = 13434920;
    MEMORY[0x183711F4] = 8519725;
    MEMORY[0x183711F8] = 10879026;
    MEMORY[0x183711FC] = 13238327;
    MEMORY[0x18371200] = 13500476;
    MEMORY[0x18371204] = 14286913;
    MEMORY[0x18371208] = 14286918;
    MEMORY[0x1837120C] = 14286923;
    MEMORY[0x18371210] = 196608;
    MEMORY[0x18371214] = 8388613;
    MEMORY[0x18371218] = 10747914;
    MEMORY[0x1837121C] = 13107215;
    MEMORY[0x18371220] = 13369364;
    MEMORY[0x18371224] = 8454169;
    MEMORY[0x18371228] = 10813470;
    MEMORY[0x1837122C] = 13172771;
    MEMORY[0x18371230] = 13434920;
    MEMORY[0x18371234] = 8519725;
    MEMORY[0x18371238] = 10879026;
    MEMORY[0x1837123C] = 13238327;
    MEMORY[0x18371240] = 13500476;
    MEMORY[0x18371244] = 14286913;
    MEMORY[0x18371248] = 14286918;
    MEMORY[0x1837124C] = 14286923;
    MEMORY[0x18371250] = 196608;
    MEMORY[0x18371254] = 8388613;
    MEMORY[0x18371258] = 10747914;
    MEMORY[0x1837125C] = 13107215;
    MEMORY[0x18371260] = 13369364;
    MEMORY[0x18371264] = 8454169;
    MEMORY[0x18371268] = 10813470;
    MEMORY[0x1837126C] = 13172771;
    MEMORY[0x18371270] = 13434920;
    MEMORY[0x18371274] = 8519725;
    MEMORY[0x18371278] = 10879026;
    MEMORY[0x1837127C] = 13238327;
    MEMORY[0x18371280] = 13500476;
    MEMORY[0x18371284] = 14286913;
    MEMORY[0x18371288] = 14286918;
    MEMORY[0x1837128C] = 14286923;
    MEMORY[0x18371290] = 196608;
    MEMORY[0x18371294] = 8388613;
    MEMORY[0x18371298] = 10747914;
    MEMORY[0x1837129C] = 13107215;
    MEMORY[0x183712A0] = 13369364;
    MEMORY[0x183712A4] = 8454169;
    MEMORY[0x183712A8] = 10813470;
    MEMORY[0x183712AC] = 13172771;
    MEMORY[0x183712B0] = 13434920;
    MEMORY[0x183712B4] = 8519725;
    MEMORY[0x183712B8] = 10879026;
    MEMORY[0x183712BC] = 13238327;
    MEMORY[0x183712C0] = 13500476;
    MEMORY[0x183712C4] = 14286913;
    MEMORY[0x183712C8] = 14286918;
    MEMORY[0x183712CC] = 14286923;
    MEMORY[0x183712D0] = 2161688;
    MEMORY[0x183712D4] = 1113612;
    MEMORY[0x183712D8] = 589574;
    MEMORY[0x183712DC] = 327555;
    MEMORY[0x183712E0] = 196545;
    MEMORY[0x183712E4] = 131041;
    MEMORY[0x183712E8] = 131056;
    MEMORY[0x183712F0] = -65520;
    MEMORY[0x183712F4] = -65505;
    MEMORY[0x183712F8] = -131009;
    MEMORY[0x183712FC] = -262019;
    MEMORY[0x18371300] = -524038;
    MEMORY[0x18371304] = -1048076;
    MEMORY[0x18371308] = -2096152;
    MEMORY[0x1837130C] = -2096152;
    MEMORY[0x18371A80] = 1;
    result = 406257808LL;
    MEMORY[0x18370090] = 17;
  }
  return result;
}




__int64 __fastcall lookup_drv_index(int a1)
{
  __int64 v1; // x1
  unsigned int v2; // w2
  __int64 v3; // x6

  v1 = 0LL;
  while ( 1 )
  {
    v2 = v1;
    if ( v1 == 1 )
      break;
    v3 = 48 * v1++;
    if ( *(_DWORD *)((char *)&_compound_literal_1_2 + v3) == a1 )
      return v2;
  }
  rpmh_core_verify(0LL);
  return 0xFFFFFFFFLL;
}



__int64 __fastcall mapOS_getGpioTable(__int64 a1)
{
  *(_QWORD *)a1 = g_pdcGpioInputs;
  *(_QWORD *)(a1 + 8) = g_pdcGpioMapping;
  *(_DWORD *)(a1 + 16) = 98;
  *(_DWORD *)(a1 + 20) = 98;
  return 0LL;
}



__int64 __fastcall mapOS_getInterruptTable(__int64 a1)
{
  *(_QWORD *)a1 = g_pdcInterruptMapping;
  *(_DWORD *)(a1 + 8) = 70;
  return 0LL;
}



__int64 __fastcall mem_assign(__int64 *a1, unsigned int a2, __int64 a3, unsigned int a4, int *a5, unsigned int a6)
{
  __int64 v12; // x3
  __int64 v13; // x5
  int v14; // w19
  int v15; // w21
  int v16; // w0
  int v18; // w6
  unsigned int i; // w4
  __int64 v21; // x8
  int *v22; // x4
  unsigned int v23; // w25
  unsigned int v24; // w24
  int *v25; // x22
  int v26; // w0
  __int64 v28; // x5
  int v29; // w6
  int v30; // w9
  int v31; // w0
  __int64 *v32; // x28
  __int64 j; // x23
  int k; // w0
  __int64 v35; // x20
  __int64 v36; // x27
  __int64 v37; // x26
  int v38; // w0
  __int64 v39; // x22
  char *v40; // x20
  __int64 v41; // x9
  __int64 v42; // x3
  __int64 v43; // x5
  int v44; // w2
  __int64 v45; // x6
  unsigned __int64 v46; // x11
  int v47; // w8
  __int64 m; // x1
  int v49; // w4
  __int64 v50; // x0
  __int64 v51; // x13
  __int64 v52; // x0
  int v53; // w3
  __int64 v54; // x2
  bool v55; // zf
  __int64 v57; // x4
  int v58; // w3
  unsigned int v59; // w19
  __int64 result; // x0
  __int64 v61; // x3
  __int64 v62; // x4
  _QWORD *v63; // [xsp+68h] [xbp+68h]
  __int64 v64; // [xsp+78h] [xbp+78h]
  __int64 v65; // [xsp+90h] [xbp+90h]
  int v66; // [xsp+98h] [xbp+98h]
  unsigned int v67; // [xsp+9Ch] [xbp+9Ch]

  qtiseclib_cb_spin_lock(&perm_lock_1439);
  v12 = a4;
  v13 = 0LL;
  v14 = 0;
  v15 = 0;
  while ( v13 != v12 )
  {
    v16 = *(_DWORD *)(a3 + 4 * v13);
    if ( v16 == 15 || v16 == 43 )
    {
      v18 = 0;
      for ( i = 0; i < a6 && i <= 0x2B; ++i )
      {
        v21 = 6LL * i;
        if ( v16 == a5[v21] )
          v18 = 1;
      }
      if ( !v18 )
      {
        if ( v16 == 15 )
        {
          v14 = 1;
          v15 = 30;
        }
        else
        {
          if ( v16 != 43 )
          {
LABEL_77:
            v59 = 32;
            goto LABEL_78;
          }
          v14 = 1;
          v15 = 35;
        }
      }
    }
    ++v13;
  }
  v22 = a5;
  v23 = 0;
  v24 = 0;
  v25 = &a5[6 * a6];
  while ( v22 != v25 )
  {
    v26 = *v22;
    if ( *v22 == 15 || v26 == 43 )
    {
      v28 = 0LL;
      v29 = 0;
      while ( v12 != v28 )
      {
        v30 = *(_DWORD *)(a3 + 4 * v28++);
        if ( v26 == v30 )
          v29 = 1;
      }
      if ( !v29 )
      {
        if ( v26 == 15 )
        {
          v15 = 30;
        }
        else
        {
          if ( v26 != 43 )
            goto LABEL_77;
          v15 = 35;
        }
        v31 = v22[1];
        v14 = 257;
        if ( (v31 & 2) != 0 )
          v23 = 2;
        if ( (v31 & 4) != 0 )
          v24 = 2;
      }
    }
    v22 += 6;
  }
  v32 = a1;
  v65 = a2;
  for ( j = 0LL; ; ++j )
  {
    v67 = j;
    if ( j == v65 )
      break;
    for ( k = 0; k != 2; ++k )
    {
      v35 = 16LL * k;
      if ( v15 == *(_DWORD *)((char *)&msm_mpu_ranges + v35) )
      {
        v36 = *v32;
        v37 = 0LL;
        v38 = 0;
        v39 = *v32 + v32[1];
        v40 = (char *)&msm_mpu_ranges + v35;
        while ( (unsigned __int8)v40[4] > (int)v37 )
        {
          v41 = *((_QWORD *)v40 + 1);
          v42 = 0LL;
          v43 = 48 * v37;
          v44 = -1;
          v45 = v41 + 48 * v37;
          v46 = *(_QWORD *)(v45 + 24);
          v47 = v46 - *((unsigned __int16 *)v40 + 3);
          for ( m = 16 * (v47 + 1LL); ; m += 16LL )
          {
            v49 = v47 + v42;
            if ( v47 + v42 >= v46 )
            {
              v49 = v44;
              goto LABEL_68;
            }
            v50 = *(_QWORD *)(v45 + 32) + 24 * (v47 + v42);
            v51 = *(_QWORD *)(v50 + 8);
            if ( v36 == v51 && v39 == *(_QWORD *)(v50 + 16) )
              break;
            if ( *(_DWORD *)(*(_QWORD *)(v45 + 16) + m + 4) )
              v55 = 0;
            else
              v55 = v51 == 0xFFFFFFFFLL;
            if ( v55 && *(_QWORD *)(v50 + 16) == 0xFFFFFFFFLL && v44 == -1 )
              v44 = v47 + v42;
            ++v42;
          }
          if ( v14 == 1 )
          {
            v63 = (_QWORD *)(v41 + 48 * v37);
            v64 = *((_QWORD *)v40 + 1);
            v66 = v47 + v42;
            qtiseclib_cb_log(40LL, "freeing RG for xpu 0x%x z:%d", *v63, (unsigned int)v49);
            v52 = 0xFFFFFFFFLL;
            v53 = 0;
            v54 = 0xFFFFFFFFLL;
            v49 = v66;
            v45 = (__int64)v63;
            v43 = 48 * v37;
            v41 = v64;
            goto LABEL_69;
          }
LABEL_68:
          v52 = v39;
          v54 = v36;
          v53 = v14;
LABEL_69:
          if ( v49 == -1 )
          {
            qtiseclib_cb_log(40LL, "AC Fatal Error no free RG xpu addr : 0x%x ", *(_QWORD *)(v41 + v43));
            v38 = 1;
          }
          else
          {
            *(_DWORD *)(*(_QWORD *)(v45 + 16) + 16LL * v49 + 20) = v53;
            v57 = *(_QWORD *)(v45 + 32) + 24LL * v49;
            v58 = *(_DWORD *)v57;
            *(_QWORD *)(v57 + 8) = v54;
            *(_QWORD *)(v57 + 16) = v52;
            XpuLockDownAssetDynamically(v45, 1u, *(_DWORD *)(v45 + 40), v58, v24, v23);
            v38 = 0;
          }
          ++v37;
        }
        if ( v38 )
        {
          qtiseclib_cb_log(10LL, "AC Fatal Error  %x", 96LL);
          dbg_err_fatal(4u);
        }
        break;
      }
    }
    v61 = *v32;
    v62 = *v32 + v32[1];
    v32 += 2;
    qtiseclib_cb_log(10LL, "mpu_master_mpus_range: %d %x %x %x %x", v67, v61, v62, v24, v23);
  }
  v59 = 0;
LABEL_78:
  qtiseclib_cb_spin_unlock(&perm_lock_1439);
  result = 0LL;
  if ( v59 )
  {
    qtiseclib_cb_log(10LL, "mem_assign failed %x", v59);
    return -1LL;
  }
  return result;
}



__int64 __fastcall mem_free(__int64 a1, _QWORD *a2, __int64 a3)
{
  void (__fastcall *v5)(__int64); // x1
  unsigned __int64 v6; // x21
  unsigned __int64 v7; // x1
  unsigned int v8; // w0
  unsigned int v9; // w1
  int v10; // w1
  __int64 v11; // x0
  _WORD *v12; // x1
  __int16 v13; // w2
  __int16 v14; // w3
  void (__fastcall *v15)(__int64); // x1

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Bu, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Cu, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Du, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Eu, "mem_magic_number->magic_num_index_array");
  if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x251u,
      "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
  if ( !a3 )
  {
    qtiseclib_cb_log(10LL, "NULL ptr occurenaces in mem_free()");
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x258u, "0");
  }
  if ( !*(_QWORD *)(a1 + 8) )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x25Eu, "heap_ptr->first_block");
  v5 = *(void (__fastcall **)(__int64))(a1 + 48);
  if ( v5 )
    v5(a1);
  v6 = a3 - 8;
  if ( ((a3 - 8) & 0xF) != 0 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x26Du, "(((uintptr_t)theBlock)%kMinChunkSize) == 0");
  v7 = *(_QWORD *)(a1 + 8);
  if ( v6 < v7 || v6 >= v7 + *(unsigned int *)(a1 + 28) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x270u,
      "((theBlock >= ((mem_heap_type*)heap_ptr)->first_block) && (((char*)(theBlock)) < ((char*)(((mem_heap_type*)heap_pt"
      "r)->first_block) + ((mem_heap_type*)(heap_ptr))->total_bytes)))");
  if ( (*(_BYTE *)(a3 - 5) & 0xF) != 0 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x274u, "!theBlock->free_flag");
  if ( *(_DWORD *)(a3 - 4) <= 7u )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x277u, "theBlock->forw_offset >= sizeBlockHeader");
  if ( *(unsigned __int8 *)(a3 - 6) > 0xFu )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x279u, "theBlock->extra < kMinChunkSize");
  if ( v6 + *(unsigned int *)(a3 - 4) > *(_QWORD *)(a1 + 8) + (unsigned __int64)*(unsigned int *)(a1 + 28) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x27Cu,
      "((((mem_block_header_type *)theBlock)->forw_offset + (char *)theBlock) <= ((((char*)((mem_heap_type*)heap_ptr)->fi"
      "rst_block) + ((mem_heap_type*)heap_ptr)->total_bytes)))");
  if ( *(unsigned __int16 *)(a1 + 74) != (unsigned __int16)(*(_WORD *)(a3 - 8) ^ *(_WORD *)(a3 - 6) ^ *(_WORD *)(a3 - 4) ^ *(_WORD *)(a3 - 2)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x280u,
      "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_used)");
  if ( (*(_BYTE *)(a3 - 5) & 0xF) == 0 )
  {
    if ( *(_DWORD *)(a3 - 4) - 8 - (unsigned int)*(unsigned __int8 *)(a3 - 6) > *(_DWORD *)(a1 + 32) )
      qtisec_assert(
        "noship_src/services/heap/memheap_lite.c",
        0x287u,
        "(theBlock->forw_offset - sizeBlockHeader - theBlock->extra) <= heap_ptr->used_bytes");
    v8 = *(unsigned __int8 *)(a3 - 6) - *(_DWORD *)(a3 - 4) + *(_DWORD *)(a1 + 32) + 8;
    v9 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 32) = v8;
    if ( v8 > v9 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x28Au, "heap_ptr->total_bytes >= heap_ptr->used_bytes");
    *(_BYTE *)(a3 - 5) = *(_BYTE *)(a3 - 5) & 0xF0 | 1;
    if ( v6 < *(_QWORD *)(a1 + 16) )
      *(_QWORD *)(a1 + 16) = v6;
    *(_WORD *)(a3 - 8) = *(_WORD *)(a3 - 6) ^ *(_WORD *)(a3 - 4) ^ *(_WORD *)(a3 - 2) ^ *(_WORD *)(a1 + 72);
    if ( !*(_DWORD *)(a1 + 32) )
    {
      v10 = *(_DWORD *)(a1 + 28);
      v11 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v11;
      mem_init_block_header_isra_0(v11, v10);
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + 3LL) = *(_BYTE *)(*(_QWORD *)(a1 + 8) + 3LL) & 0xF | 0x10;
      v12 = *(_WORD **)(a1 + 8);
      v13 = v12[1];
      v14 = v12[3];
      *(_DWORD *)(a1 + 24) = 1;
      *v12 = v13 ^ v12[2] ^ v14 ^ *(_WORD *)(a1 + 72);
    }
  }
  v15 = *(void (__fastcall **)(__int64))(a1 + 56);
  if ( v15 )
    v15(a1);
  return 1LL;
}



__int64 __fastcall mem_get_buffer_size(__int64 a1)
{
  if ( a1 )
    return (unsigned int)(*(_DWORD *)(a1 - 4) - 8);
  else
    return 0LL;
}



__int64 __fastcall mem_init_heap(int *a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  int v8; // w0
  __int64 v9; // x21
  __int64 i; // x0
  __int64 v11; // x4
  unsigned __int16 v12; // w1
  __int16 v13; // w1
  int v14; // w21
  _WORD *v15; // x1
  __int16 v16; // w2
  __int16 v17; // w3
  __int16 v18; // w0
  __int16 v19; // w2
  __int16 v20; // w0

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x138u, "heap_ptr");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x139u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Au, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Bu, "mem_magic_number->magic_num_index_array");
  if ( *((_WORD *)a2 + 8) )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Du, "mem_magic_number->magic_num_index < 1");
  v8 = *a1;
  if ( !*a1 || v8 != *(_DWORD *)(*a2 + 4LL * *((unsigned __int16 *)a1 + 38)) )
  {
    qtiseclib_cb_memset(a1, 0LL, 80LL);
    if ( !a3 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x147u, "heap_mem_ptr");
    if ( !a4 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x148u, "heap_mem_size");
    if ( a4 <= 0x1E )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x149u, "heap_mem_size >= (2*kMinChunkSize-1)");
    v9 = a3 + a4;
    while ( (a3 & 0xF) != 0 )
      ++a3;
    *((_QWORD *)a1 + 8) = a3;
    qtiseclib_cb_memset(a3, 0LL, 4LL);
    *((_QWORD *)a1 + 6) = mem_heap_enter_crit_sect;
    *((_QWORD *)a1 + 7) = mem_heap_leave_crit_sect;
    for ( i = a3 + 4; (i & 0xF) != 0; ++i )
      ;
    v11 = *a2;
    v12 = *(_WORD *)(a2[1] + 2LL * *((unsigned __int16 *)a2 + 8));
    *((_QWORD *)a1 + 1) = i;
    *((_QWORD *)a1 + 2) = i;
    *(_DWORD *)(v11 + 4LL * v12) = -1412571974;
    *((_WORD *)a1 + 38) = v12;
    *((_WORD *)a1 + 36) = -21555;
    *((_WORD *)a1 + 37) = -21555;
    v13 = *((_WORD *)a2 + 8);
    *a1 = -1412571974;
    *((_WORD *)a2 + 8) = v13 + 1;
    v14 = 16 * ((v9 - i) / 16);
    mem_init_block_header_isra_0(i, v14);
    *(_BYTE *)(*((_QWORD *)a1 + 1) + 3LL) = *(_BYTE *)(*((_QWORD *)a1 + 1) + 3LL) & 0xF | 0x10;
    v15 = (_WORD *)*((_QWORD *)a1 + 1);
    v16 = v15[1];
    v17 = v15[3];
    a1[6] = 1;
    a1[7] = v14;
    v18 = v15[2];
    a1[8] = 0;
    a1[9] = 0;
    v19 = v16 ^ v18;
    v20 = *((_WORD *)a1 + 36);
    a1[10] = 0;
    *v15 = v19 ^ v17 ^ v20;
  }
  return 1LL;
}



unsigned __int64 __fastcall mem_malloc(__int64 a1, _QWORD *a2, unsigned int a3)
{
  unsigned __int64 result; // x0
  void (__fastcall *v8)(__int64); // x1
  unsigned __int64 v9; // x21
  char v10; // w24
  __int16 *v11; // x2
  __int16 v12; // w3
  __int16 v13; // w4
  __int16 v14; // w1
  __int16 v15; // w0
  unsigned int v16; // w1
  const char *v17; // x2
  __int64 v18; // x25
  unsigned __int64 i; // x22
  unsigned __int64 v20; // x20
  unsigned int v21; // w0
  char v23; // w1
  _WORD *v24; // x1
  unsigned __int64 v25; // x20
  unsigned __int64 v26; // x1
  __int16 v27; // w1
  __int16 v28; // w2
  int v29; // w0
  char v30; // w0
  unsigned int v31; // w1
  unsigned int v32; // w0
  unsigned int v33; // w0
  void (__fastcall *v34)(__int64); // x1

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D2u, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D4u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D5u, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D6u, "mem_magic_number->magic_num_index_array");
  result = 0LL;
  if ( a3 )
  {
    result = 0LL;
    if ( a3 <= *(_DWORD *)(a1 + 28) && a3 <= 0xFFFFFFE7 )
    {
      v8 = *(void (__fastcall **)(__int64))(a1 + 48);
      v9 = (a3 + 23LL) & 0x1FFFFFFF0LL;
      v10 = v9 - a3 - 8;
      if ( v8 )
        v8(a1);
      if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
        qtisec_assert(
          "noship_src/services/heap/memheap_lite.c",
          0x1EFu,
          "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
      if ( !*(_QWORD *)(a1 + 8) )
        qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2CAu, "heap_ptr->first_block");
      v11 = *(__int16 **)(a1 + 16);
      v12 = v11[2];
      v13 = *v11;
      v14 = v11[1];
      v15 = v11[3];
      if ( (*((_BYTE *)v11 + 3) & 0xF) == 1 )
      {
        if ( *(unsigned __int16 *)(a1 + 72) != (unsigned __int16)(v12 ^ v15 ^ v13 ^ v14) )
        {
          v16 = 718;
          v17 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_free)";
          goto LABEL_25;
        }
      }
      else if ( *(unsigned __int16 *)(a1 + 74) != (unsigned __int16)(v13 ^ v14 ^ v12 ^ v15) )
      {
        v16 = 722;
        v17 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_used)";
LABEL_25:
        qtisec_assert("noship_src/services/heap/memheap_lite.c", v16, v17);
      }
      v18 = *(unsigned int *)(a1 + 24);
      for ( i = mem_get_next_block(a1, *(_QWORD *)(a1 + 16)); ; i = mem_get_next_block(a1, i) )
      {
        if ( v18 <= 0 )
        {
          v25 = 0LL;
          goto LABEL_53;
        }
        if ( !*(_DWORD *)(*(_QWORD *)(a1 + 16) + 4LL) )
          qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2DCu, "heap_ptr->next_block->forw_offset > 0");
        if ( !*(_DWORD *)(i + 4) )
          qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2DDu, "followingBlock->forw_offset > 0");
        if ( (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 3LL) & 0xF) != 0 )
          break;
LABEL_40:
        *(_QWORD *)(a1 + 16) = i;
        --v18;
      }
      while ( 1 )
      {
        v20 = *(_QWORD *)(a1 + 16);
        v21 = *(_DWORD *)(v20 + 4);
        if ( v9 <= v21 )
          break;
        if ( (*(_BYTE *)(i + 3) & 0xF) == 0 || i <= v20 )
          goto LABEL_40;
        --v18;
        v23 = *(_BYTE *)(v20 + 3);
        *(_DWORD *)(v20 + 4) = *(_DWORD *)(i + 4) + v21;
        *(_BYTE *)(v20 + 3) = v23 & 0xF | (16 * ((*(_BYTE *)(i + 3) >> 4) & 0xF));
        v24 = *(_WORD **)(a1 + 16);
        *v24 = v24[3] ^ *(_WORD *)(a1 + 72) ^ v24[1] ^ v24[2];
        --*(_DWORD *)(a1 + 24);
        *(_DWORD *)i = 0;
        *(_DWORD *)(i + 4) = 0;
        i = mem_get_next_block(a1, (__int64)v24);
      }
      if ( !v21 )
        qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1F6u, "freeBlock->forw_offset > 0");
      v26 = *(unsigned int *)(v20 + 4);
      if ( v9 < v26 )
      {
        mem_init_block_header_isra_0(v20 + v9, v26 - v9);
        *(_BYTE *)(v20 + v9 + 3) = *(_BYTE *)(v20 + v9 + 3) & 0xF | (16 * ((*(_BYTE *)(v20 + 3) >> 4) & 0xF));
        *(_BYTE *)(v20 + 3) &= 0xFu;
        v27 = *(_WORD *)(v20 + v9 + 2);
        v28 = *(_WORD *)(v20 + v9 + 6);
        v29 = *(_DWORD *)(a1 + 24) + 1;
        *(_DWORD *)(v20 + 4) = v9;
        *(_DWORD *)(a1 + 24) = v29;
        *(_WORD *)(v20 + v9) = v27 ^ *(_WORD *)(v20 + v9 + 4) ^ v28 ^ *(_WORD *)(a1 + 72);
      }
      v30 = *(_BYTE *)(v20 + 3);
      *(_BYTE *)(v20 + 2) = v10;
      *(_BYTE *)(v20 + 3) = v30 & 0xF0;
      *(_QWORD *)(a1 + 16) = mem_get_next_block(a1, v20);
      v31 = *(_DWORD *)(a1 + 28);
      v32 = a3 + *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 32) = v32;
      if ( v32 > v31 )
        qtisec_assert(
          "noship_src/services/heap/memheap_lite.c",
          0x210u,
          "heap_ptr->total_bytes >= heap_ptr->used_bytes");
      v33 = *(_DWORD *)(a1 + 32);
      if ( v33 > *(_DWORD *)(a1 + 36) )
        *(_DWORD *)(a1 + 36) = v33;
      if ( a3 > *(_DWORD *)(a1 + 40) )
        *(_DWORD *)(a1 + 40) = a3;
      *(_WORD *)v20 = *(_WORD *)(v20 + 2) ^ *(_WORD *)(v20 + 4) ^ *(_WORD *)(v20 + 6) ^ *(_WORD *)(a1 + 74);
      v25 = v20 + 8;
LABEL_53:
      v34 = *(void (__fastcall **)(__int64))(a1 + 56);
      result = v25;
      if ( v34 )
      {
        v34(a1);
        return v25;
      }
    }
  }
  return result;
}



unsigned __int64 __fastcall mem_realloc(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4)
{
  __int64 v9; // x1
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x23
  __int64 v12; // x2

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x33Fu, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x340u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x341u, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x342u, "mem_magic_number->magic_num_index_array");
  if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x343u,
      "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
  if ( !a3 )
    return mem_malloc(a1, a2, a4);
  if ( a4 )
  {
    v10 = mem_malloc(a1, a2, a4);
    v11 = v10;
    v9 = 0LL;
    if ( v10 )
    {
      LODWORD(v12) = *(_DWORD *)(a3 - 4) - 8;
      if ( (unsigned int)v12 > a4 )
        v12 = a4;
      else
        v12 = (unsigned int)v12;
      qtiseclib_cb_memcpy(v10, a3, v12);
      mem_free(a1, a2, a3);
      return v11;
    }
  }
  else
  {
    mem_free(a1, a2, a3);
    return 0LL;
  }
  return v9;
}



int *__fastcall msm_xpu_isr(__int64 a1, __int64 a2, int *a3)
{
  __int64 is_sdi_enable; // x0

  msm_xpu_print_log(a3);
  is_sdi_enable = dbg_is_sdi_enable();
  if ( (_BYTE)is_sdi_enable )
    dbg_err_fatal(4u);
  qtiseclib_cb_console_flush(is_sdi_enable);
  return a3;
}



__int64 __fastcall msm_xpu_print_log(int *a1)
{
  void **v2; // x1
  __int64 v3; // x0
  __int64 v4; // x25
  __int64 result; // x0
  int v6; // w28
  char *v7; // x19
  int v8; // w4
  int v9; // w0
  unsigned int v10; // w21
  unsigned int v11; // w20
  __int64 v12; // x5
  char *v13; // x1
  unsigned int *v14; // x24
  unsigned int v15; // t1
  __int64 v16; // [xsp+60h] [xbp+60h]
  int v17; // [xsp+6Ch] [xbp+6Ch]
  __int16 v18; // [xsp+70h] [xbp+70h] BYREF
  __int64 v19; // [xsp+78h] [xbp+78h] BYREF

  v19 = 0LL;
  if ( (unsigned __int8)dbg_is_sdi_enable() )
    qtiseclib_cb_switch_console_to_crash_state();
  qtiseclib_cb_log(40LL, "xpu: ISR begin");
  if ( *a1 )
  {
    if ( *a1 != 1 )
    {
      qtiseclib_cb_log(10LL, "XPU ERROR: Invalid!!");
      goto LABEL_9;
    }
    qtiseclib_cb_log(10LL, "XPU ERROR: Non Sec!!");
    v2 = &xpu_non_sec_intr_status_reg;
    v3 = 33300480LL;
  }
  else
  {
    qtiseclib_cb_log(10LL, "XPU ERROR: Sec!!");
    v2 = &xpu_sec_intr_status_reg;
    v3 = 33308672LL;
  }
  LODWORD(v19) = *(_DWORD *)v3 & (unsigned int)v2[1];
  HIDWORD(v19) = *(_DWORD *)v2[2] & (unsigned int)v2[3];
LABEL_9:
  v4 = 0LL;
  result = qtiseclib_cb_log(10LL, "XPU INTR 0:1 >> %08x:%08x", (unsigned int)v19, HIDWORD(v19));
  do
  {
    v6 = *(_DWORD *)((char *)&v19 + v4);
    if ( v6 )
    {
      v7 = (char *)&xpu_err_pos_to_hal_map + 64 * v4;
      do
      {
        if ( (v6 & *(_DWORD *)v7) != 0 )
        {
          v8 = (unsigned __int8)v7[4];
          if ( (unsigned int)(v8 - 1) <= 0x16 )
          {
            v9 = *a1;
            v18 = 32;
            if ( v9 )
            {
              if ( v9 == 1 )
                v10 = 2176;
              else
                v10 = 0;
            }
            else
            {
              v10 = 2048;
              LOBYTE(v18) = 83;
            }
            v11 = 0;
            v12 = 24LL;
            while ( v11 < g_xpu_base_addr_array_count )
            {
              v13 = (char *)&g_xpu_base_addr_array + (int)v11 * v12;
              if ( v8 == *(_DWORD *)v13 )
              {
                v16 = v12;
                v14 = (unsigned int *)(v10 + *((_QWORD *)v13 + 1));
                v17 = v8;
                qtiseclib_cb_log(10LL, "%sEAR0 0x%x", (const char *)&v18, *v14);
                qtiseclib_cb_log(10LL, "%sEAR1 0x%x", (const char *)&v18, v14[1]);
                qtiseclib_cb_log(10LL, "%sESR 0x%x", (const char *)&v18, v14[2]);
                qtiseclib_cb_log(10LL, "%sESYNR0 0x%x", (const char *)&v18, v14[4]);
                qtiseclib_cb_log(10LL, "%sESYNR1 0x%x", (const char *)&v18, v14[5]);
                qtiseclib_cb_log(10LL, "%sESYNR2 0x%x", (const char *)&v18, v14[6]);
                qtiseclib_cb_log(10LL, "%sESYNR3 0x%x", (const char *)&v18, v14[7]);
                qtiseclib_cb_log(10LL, "%sESYNR4 0x%x", (const char *)&v18, v14[8]);
                v14[3] = 0;
                v8 = v17;
                v12 = v16;
              }
              ++v11;
            }
          }
        }
        v15 = *((_DWORD *)v7 + 2);
        v7 += 8;
        result = v15;
      }
      while ( v15 );
    }
    v4 += 4LL;
  }
  while ( v4 != 8 );
  return result;
}



__int64 __fastcall NOC_Error_Handle_Interrupt(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // w7
  __int64 v5; // x20
  unsigned int v6; // w21
  const char *v7; // x0
  unsigned int i; // w22
  unsigned int v9; // w22
  int v10; // w6
  const char *v11; // x0
  unsigned int j; // w0
  unsigned int k; // w1
  __int64 v14; // x27
  const char **v15; // x19
  const char *v16; // x1
  const char *v17; // x2
  __int64 v18; // x3
  const char *v19; // x2
  __int64 v20; // x3
  const char *v21; // x2
  __int64 v22; // x3
  const char *v23; // x2
  __int64 v24; // x3
  const char *v25; // x2
  __int64 v26; // x3
  const char *v27; // x2
  __int64 v28; // x3
  const char *v29; // x2
  __int64 v30; // x3
  const char *v31; // x2
  __int64 v32; // x3
  int v33; // w1
  int v34; // w4
  const char *v35; // x2
  int v36; // w0
  __int64 v37; // x4
  const char *v38; // x2
  int v39; // w0
  __int64 v40; // x4
  const char *v41; // x2
  int v42; // w0
  __int64 v43; // x4
  const char *v44; // x2
  __int64 v45; // x24
  const char *v46; // x1
  __int64 v47; // x2
  int v48; // w0
  int v49; // w0
  int v50; // w0
  int v51; // w1
  unsigned __int16 *v52; // x0
  int v53; // w5
  __int64 v54; // x6
  int v55; // w3
  __int64 v56; // x5
  int v57; // w3
  __int64 v58; // x5
  int v59; // w3
  __int64 v60; // x2
  __int64 v61; // x0
  int v63; // [xsp+68h] [xbp+68h]
  int v64; // [xsp+6Ch] [xbp+6Ch]

  if ( !NOCInfo || !NOCInfoOEM )
  {
    qtiseclib_cb_log(10LL, "Invalid NOC info data structures!");
    return a3;
  }
  v4 = 0;
  v5 = 0LL;
  v6 = 0;
LABEL_17:
  if ( v6 < *(_DWORD *)(NOCERR_propdata + 12) )
  {
    v14 = NOCInfo;
    v15 = (const char **)(NOCInfo + 176LL * v6);
    if ( v15[3] != (const char *)(unsigned int)a3 )
      goto LABEL_16;
    v5 = NOCInfoOEM + 48LL * v6;
    if ( !v5 )
    {
      qtiseclib_cb_log(10LL, "Invalid Interrupt Vector!");
      return a3;
    }
    v7 = v15[2];
    if ( v7 )
    {
      v16 = v15[1];
      if ( *(_DWORD *)&v7[*((unsigned __int16 *)v16 + 3)] )
      {
        v17 = *(const char **)(NOCInfo + 176LL * v6);
        v18 = *(unsigned int *)&v7[*((unsigned __int16 *)v16 + 5)];
        *((_DWORD *)v15 + 18) = v18;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG0_LOW = 0x%08x", v17, v18);
        v19 = *(const char **)(v14 + 176LL * v6);
        v20 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 6)];
        *((_DWORD *)v15 + 19) = v20;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG0_HIGH = 0x%08x", v19, v20);
        v21 = *(const char **)(v14 + 176LL * v6);
        v22 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 7)];
        *((_DWORD *)v15 + 20) = v22;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG1_LOW = 0x%08x", v21, v22);
        v23 = *(const char **)(v14 + 176LL * v6);
        v24 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 8)];
        *((_DWORD *)v15 + 21) = v24;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG1_HIGH = 0x%08x", v23, v24);
        v25 = *(const char **)(v14 + 176LL * v6);
        v26 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 9)];
        *((_DWORD *)v15 + 22) = v26;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG2_LOW = 0x%08x", v25, v26);
        v27 = *(const char **)(v14 + 176LL * v6);
        v28 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 10)];
        *((_DWORD *)v15 + 23) = v28;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG2_HIGH = 0x%08x", v27, v28);
        v29 = *(const char **)(v14 + 176LL * v6);
        v30 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 11)];
        *((_DWORD *)v15 + 24) = v30;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG3_LOW = 0x%08x", v29, v30);
        v31 = *(const char **)(v14 + 176LL * v6);
        v32 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 12)];
        *((_DWORD *)v15 + 25) = v32;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG3_HIGH = 0x%08x", v31, v32);
        v4 = 1;
      }
    }
    for ( i = 0; i < *((_DWORD *)v15 + 8); ++i )
    {
      v33 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 8LL);
      if ( v33 != 0xFFFF )
      {
        v34 = *(_DWORD *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v33);
        if ( v34 )
        {
          v35 = *v15;
          *(_DWORD *)&v15[17][16 * i] = v34;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS0_LOW = 0x%08x", v35, i);
          v4 = 1;
        }
      }
      v36 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 10LL);
      if ( v36 != 0xFFFF )
      {
        v37 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v36);
        if ( (_DWORD)v37 )
        {
          v38 = *v15;
          *(_DWORD *)&v15[17][16 * i + 4] = v37;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS0_HIGH = 0x%08x", v38, i, v37);
          v4 = 1;
        }
      }
      v39 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 16LL);
      if ( v39 != 0xFFFF )
      {
        v40 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v39);
        if ( (_DWORD)v40 )
        {
          v41 = *v15;
          *(_DWORD *)&v15[17][16 * i + 8] = v40;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS1_LOW = 0x%08x", v41, i, v40);
          v4 = 1;
        }
      }
      v42 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 18LL);
      if ( v42 != 0xFFFF )
      {
        v43 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v42);
        if ( (_DWORD)v43 )
        {
          v44 = *v15;
          *(_DWORD *)&v15[17][16 * i + 12] = v43;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS1_HIGH = 0x%08x", v44, i, v43);
          v4 = 1;
        }
      }
    }
    v9 = 0;
    v10 = 0xFFFF;
    while ( 1 )
    {
      if ( v9 >= *((_DWORD *)v15 + 38) )
      {
        v11 = v15[2];
        if ( v11 )
          *(_DWORD *)&v11[*((unsigned __int16 *)v15[1] + 4)] = 1;
        for ( j = 0; j < *((_DWORD *)v15 + 38); ++j )
        {
          v51 = *(unsigned __int16 *)(*(_QWORD *)&v15[20][8 * j] + 8LL);
          if ( v51 != 0xFFFF )
            *(_DWORD *)(*(_QWORD *)&v15[21][8 * j] + (unsigned __int16)v51) = 1;
        }
        for ( k = 0; k < *((_DWORD *)v15 + 8); ++k )
        {
          v52 = *(unsigned __int16 **)&v15[5][8 * k];
          v53 = v52[4];
          if ( v53 != 0xFFFF )
          {
            v54 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v54 + v52[2]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k) | ~*(_DWORD *)(v54 + (unsigned __int16)v53);
          }
          v55 = v52[5];
          if ( v55 != 0xFFFF )
          {
            v56 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v56 + v52[3]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 4) | ~*(_DWORD *)(v56 + (unsigned __int16)v55);
          }
          v57 = v52[8];
          if ( v57 != 0xFFFF )
          {
            v58 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v58 + v52[6]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 8) | ~*(_DWORD *)(v58 + (unsigned __int16)v57);
          }
          v59 = v52[9];
          if ( v59 != 0xFFFF )
          {
            v60 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v60 + v52[7]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 12) | ~*(_DWORD *)(v60 + (unsigned __int16)v59);
          }
        }
LABEL_16:
        ++v6;
        goto LABEL_17;
      }
      v45 = 8LL * v9;
      v46 = v15[18];
      v47 = *(_QWORD *)&v15[20][v45];
      v48 = *(unsigned __int16 *)(v47 + 4);
      if ( v48 != v10 )
      {
        v49 = *(_DWORD *)(*(_QWORD *)&v15[21][8 * v9] + (unsigned __int16)v48);
        *(_DWORD *)&v46[8 * v9] = v49;
        if ( (v49 & 2) == 0 )
          goto LABEL_43;
        v4 = 1;
      }
      v50 = *(unsigned __int16 *)(v47 + 6);
      if ( v50 != v10 )
        *(_DWORD *)&v46[8 * v9 + 4] = *(_DWORD *)(*(_QWORD *)&v15[21][8 * v9] + (unsigned __int16)v50);
      v63 = v10;
      v64 = v4;
      qtiseclib_cb_log(10LL, "%s ERROR: NOC_POS%d ERRLOG_LOW = 0x%08x", *v15, v9, *(unsigned int *)&v46[8 * v9]);
      qtiseclib_cb_log(10LL, "%s ERROR: NOC_POS%d ERRLOG_HIGH = 0x%08x", *v15, v9, *(unsigned int *)&v15[18][v45 + 4]);
      v10 = v63;
      v4 = v64;
LABEL_43:
      ++v9;
    }
  }
  if ( v4 )
  {
    if ( (unsigned __int8)dbg_is_sdi_enable() )
    {
      if ( *(_BYTE *)(v5 + 9) )
      {
        qtiseclib_cb_log(10LL, "NOC error fatal");
        dbg_err_fatal(3u);
      }
    }
    else if ( *(_BYTE *)(v5 + 9) )
    {
      v61 = qtiseclib_cb_log(10LL, "NOC error fatal");
      qtiseclib_cb_console_flush(v61);
    }
  }
  return a3;
}



__int64 NOC_Error_Init()
{
  __int64 result; // x0
  __int64 v1; // x2
  unsigned int i; // w1
  __int64 v3; // x3
  unsigned int j; // w19
  __int64 v5; // x26
  __int64 v6; // x1
  unsigned int v7; // w2
  __int64 v8; // x0
  __int64 v9; // x7
  int v10; // w3
  int v11; // w3
  unsigned int k; // w2
  __int64 v13; // x3

  result = (__int64)NOC_Error_Platform_Get_Propdata();
  NOCERR_propdata = result;
  if ( result )
  {
    result = (__int64)NOC_Error_Platform_Get_Propdata_OEM();
    if ( result )
    {
      v1 = NOCERR_propdata;
      NOCInfo = *(_QWORD *)(NOCERR_propdata + 16);
      if ( NOCInfo )
      {
        NOCInfoOEM = *(_QWORD *)(result + 16);
        if ( NOCInfoOEM )
        {
          for ( i = 0; i < *(_DWORD *)(v1 + 24); ++i )
          {
            v3 = i;
            **(_DWORD **)(*(_QWORD *)(v1 + 32) + 8 * v3) = *(_DWORD *)(*(_QWORD *)(result + 24) + 4 * v3);
          }
          for ( j = 0; ; ++j )
          {
            result = *(unsigned int *)(NOCERR_propdata + 12);
            if ( j >= (unsigned int)result )
              break;
            v5 = 176LL * j;
            if ( (unsigned int)int_svc_register_isr(
                                 *(_QWORD *)(NOCInfo + v5 + 24),
                                 (__int64)"NOCERR",
                                 7uLL,
                                 (__int64)NOC_Error_Handle_Interrupt,
                                 *(_QWORD *)(NOCInfo + v5 + 24)) )
              qtisec_assert(
                "noship_src/drivers/systemdrivers/icb/src/common/NOC_error.c",
                0x1A8u,
                "0 == int_svc_register_isr(NOCInfo[i].intr_vector, \"NOCERR\",sizeof(\"NOCERR\"), NOC_Error_Handle_Interr"
                "upt, ((void*)((uint64_t)(NOCInfo[i].intr_vector))))");
            v6 = NOCInfoOEM + 48LL * j;
            if ( *(_BYTE *)(v6 + 8) )
            {
              v7 = 0;
              v8 = NOCInfo + v5;
              while ( v7 < *(_DWORD *)(v8 + 32) )
              {
                v9 = *(_QWORD *)(*(_QWORD *)(v8 + 40) + 8LL * v7);
                v10 = *(unsigned __int16 *)(v9 + 4);
                if ( v10 != 0xFFFF )
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8LL * v7) + (unsigned __int16)v10) = *(_DWORD *)(*(_QWORD *)(v6 + 16) + 16LL * v7);
                v11 = *(unsigned __int16 *)(v9 + 6);
                if ( v11 != 0xFFFF )
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8LL * v7) + (unsigned __int16)v11) = *(_DWORD *)(*(_QWORD *)(v6 + 16) + 16LL * v7 + 4);
                ++v7;
              }
              for ( k = 0; k < *(_DWORD *)(v8 + 56); ++k )
              {
                v13 = k;
                **(_DWORD **)(*(_QWORD *)(v8 + 64) + 8 * v13) = *(_DWORD *)(*(_QWORD *)(v6 + 32) + 4 * v13);
              }
              *(_DWORD *)(*(_QWORD *)(v8 + 16) + *(unsigned __int16 *)(*(_QWORD *)(v8 + 8) + 4LL)) = 1;
            }
          }
        }
      }
    }
  }
  return result;
}





__int64 __fastcall pcu_config_low_power_mode(__int64 *a1, int a2)
{
  __int64 v2; // x3
  __int64 i; // x2

  v2 = a1[4];
  for ( i = 0LL; v2 != i && *(_DWORD *)(a1[3] + 48 * i) != a2; ++i )
    ;
  if ( a2 >= 0 && v2 == i )
    return 5LL;
  pcu_config_seq_ctl(
    a1[1],
    *(unsigned __int8 *)(a1[3] + 48 * i + 28),
    *(_DWORD *)(a1[3] + 48 * i + 40),
    *(unsigned __int8 *)(a1[3] + 48 * i + 29));
  return 0LL;
}



__int64 __fastcall pcu_config_seq_ctl(__int64 result, int a2, int a3, int a4)
{
  if ( (a2 & 0x80000000) != 0 )
    *(_DWORD *)(result + 36) = 0;
  else
    *(_DWORD *)(result + 36) = ((a2 & 0xF) << 8) | a4 | (a3 << 16);
  return result;
}



__int64 __fastcall pcu_get_node(int a1, _QWORD *a2)
{
  if ( (unsigned __int64)a1 >= 0xD )
    return 1LL;
  *a2 = &(&target_pcu_node)[5 * a1];
  return 0LL;
}



__int64 pcu_init()
{
  pcu_sequencer_target_init();
  return pcu_seq_memory_init();
}



__int64 __fastcall pcu_node_init(__int64 a1)
{
  void (*v1)(void); // x0

  v1 = *(void (**)(void))(a1 + 16);
  if ( v1 )
    v1();
  return 0LL;
}



__int64 pcu_seq_memory_init()
{
  unsigned __int64 v0; // x19
  char **v1; // x0
  __int64 result; // x0

  v0 = 0LL;
  while ( v0 < 0xD )
  {
    v1 = &(&target_pcu_node)[5 * v0++];
    result = pcu_write_seq_memory((__int64)v1, 1);
    if ( (_DWORD)result )
      return result;
  }
  return 0LL;
}




_DWORD *__fastcall pcu_write_cmds(unsigned __int8 a1, int a2)
{
  _DWORD *result; // x0

  result = (_DWORD *)(4LL * ((a1 + 100859904) & 0xFFFFFFF));
  *result = a2;
  return result;
}



__int64 __fastcall pcu_write_seq_memory(__int64 a1, int a2)
{
  __int64 v4; // x23
  int max_cmd_size; // w0
  __int64 v6; // x20
  __int64 v7; // x5
  __int64 v8; // x19
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x21
  __int64 v11; // x4
  unsigned __int64 v12; // x2
  int v13; // w0
  int v14; // w1
  __int64 v16; // [xsp+68h] [xbp+68h]

  v4 = *(_QWORD *)(a1 + 32);
  max_cmd_size = get_max_cmd_size();
  v6 = 0LL;
  v7 = 48LL;
  ::max_cmd_size = max_cmd_size;
  while ( 1 )
  {
    if ( v6 == v4 )
      return 0LL;
    v8 = *(_QWORD *)(a1 + 24) + v6 * v7;
    if ( !*(_BYTE *)(v8 + 44) )
      break;
LABEL_18:
    ++v6;
  }
  if ( *(_DWORD *)(v8 + 24) )
  {
    if ( !(_DWORD)v6 )
      return 1LL;
    *(_DWORD *)(v8 + 40) = *(_DWORD *)(v8 - 8);
    goto LABEL_16;
  }
  if ( !*(_QWORD *)(v8 + 8) )
    goto LABEL_18;
  v9 = *(_QWORD *)(v8 + 16);
  if ( v9 + (unsigned int)cmd_word_count_1139 < ::max_cmd_size )
  {
    v10 = 0LL;
    *(_DWORD *)(v8 + 40) = cmd_word_count_1139;
    while ( v9 > v10 )
    {
      v11 = *(_QWORD *)(v8 + 8);
      v12 = v10 + 1;
      v13 = 8;
      v14 = *(unsigned __int8 *)(v11 + v10);
      do
      {
        if ( v12 < v9 )
          v14 |= *(unsigned __int8 *)(v11 + v12) << v13;
        v13 += 8;
        ++v12;
      }
      while ( v13 != 32 );
      v10 += 4LL;
      v16 = v7;
      pcu_write_cmds((unsigned int)cmd_word_count_1139 >> 2, v14);
      v7 = v16;
      cmd_word_count_1139 += 4;
    }
LABEL_16:
    if ( a2 )
      *(_BYTE *)(v8 + 44) = 1;
    goto LABEL_18;
  }
  return 3LL;
}



unsigned __int64 __fastcall pdc_getTriggerConfig(int a1, unsigned int a2)
{
  __int64 v3; // x0
  unsigned int v4; // w1

  if ( a1 )
  {
    if ( !g_pdcGpios[1] )
      qtisec_assert(
        "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
        0x185u,
        "((void *) 0) != (g_pdcGpios.map.mux_map)");
    if ( a2 >= g_cmd_set[1] )
      qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0x186u, "index < g_pdcGpios.numMux");
    v4 = 24;
    v3 = g_pdcGpios[1];
  }
  else
  {
    if ( !g_pdcInterrupts[0] )
      qtisec_assert(
        "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
        0x180u,
        "((void *) 0) != (g_pdcInterrupts.map)");
    if ( hmss_pcu_memory_base[0] <= a2 )
      qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0x181u, "index < g_pdcInterrupts.numInt");
    v3 = g_pdcInterrupts[0];
    v4 = 12;
  }
  return v3 + a2 * (unsigned __int64)v4;
}



__int64 __fastcall pdcGpio_config(int a1, _DWORD *a2, _DWORD *a3)
{
  unsigned __int16 *Entry; // x20
  __int64 result; // x0
  unsigned int v7; // w0
  __int64 v8; // x0
  int v9; // w1
  __int64 v10; // x2
  __int64 v11; // x1
  unsigned int v12; // [xsp+3Ch] [xbp+3Ch] BYREF

  if ( !a2 )
    return 19LL;
  if ( !a3 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0xECu, "((void *) 0) != (subsystemInterrupt)");
  Entry = gpio_findEntry(a1, &v12);
  result = 18LL;
  if ( Entry )
  {
    v7 = Entry[1];
    if ( v7 == 0xFFFF )
    {
      v9 = 0;
      v10 = g_pdcGpios[1];
      while ( v9 != HIDWORD(g_pdcGpios[2]) )
      {
        v8 = v10;
        v10 += 24LL;
        if ( !*(_QWORD *)(v10 - 16) )
        {
          Entry[1] = v9;
          *(_QWORD *)(v8 + 8) = Entry;
          goto LABEL_16;
        }
        ++v9;
      }
      return 20LL;
    }
    else
    {
      if ( v7 >= g_cmd_set[1] )
        qtisec_assert(
          "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
          0x116u,
          "gpioInput->mux_idx_num < g_pdcGpios.numMux");
      v8 = g_pdcGpios[1] + 24LL * Entry[1];
LABEL_16:
      *(_DWORD *)v8 = *a2;
      *(_DWORD *)(v8 + 4) = a2[1];
      v11 = v12;
      *a3 = *(_DWORD *)(v8 + 16);
      return pdcHAL_setGPIOConfig(Entry[1], v11, a2);
    }
  }
  return result;
}



__int64 __fastcall pdcGpio_disable(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  __int64 result; // x0

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  result = 19LL;
  if ( v2 != 0xFFFF )
    return pdcHAL_disable(v2, 1);
  return result;
}



__int64 __fastcall pdcGpio_enable(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  __int64 result; // x0

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  result = 19LL;
  if ( v2 != 0xFFFF )
    return pdcHAL_enable(v2, 1);
  return result;
}



__int64 __fastcall pdcGpio_unconfig(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  unsigned __int16 *v3; // x19
  __int64 result; // x0
  __int64 v5; // x1

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  v3 = Entry;
  result = 19LL;
  if ( v2 != 0xFFFF )
  {
    result = pdcHAL_disable(v2, 1);
    if ( !(_DWORD)result )
    {
      v5 = lmh_hsr_version[0] + 24LL * v3[1];
      *(_QWORD *)(v5 + 8) = 0LL;
      *(_DWORD *)(v5 + 4) = -1;
      v3[1] = -1;
    }
  }
  return result;
}



__int64 __fastcall pdcHAL_disable(unsigned int a1, int a2)
{
  return HALInternal_setInterruptState(a1, a2, 0);
}



__int64 __fastcall pdcHAL_enable(unsigned int a1, int a2)
{
  return HALInternal_setInterruptState(a1, a2, 1u);
}



__int64 __fastcall pdcHAL_setGPIOConfig(int a1, __int64 a2, _DWORD *a3)
{
  return pdcHAL_setTriggerConfig(a1, 1, a3);
}



int *__fastcall pdcHAL_setOwner(int a1, int a2, char a3)
{
  int *result; // x0

  if ( a2 )
    a1 += hmss_pcu_memory_base[0];
  result = (int *)(4LL * ((a1 + 46666112) & 0x3FFFFFFF));
  *result = a3 & 7;
  return result;
}



__int64 __fastcall pdcHAL_setTriggerConfig(int a1, int a2, _DWORD *a3)
{
  int v3; // w4

  if ( a2 )
    a1 += hmss_pcu_memory_base[0];
  v3 = a3[1];
  *(_DWORD *)(unsigned int)((v3 << 16) + 186646800 + 4 * a1) = *a3 & 7;
  *(_DWORD *)(unsigned int)(4 * a1 + 186664448) = v3 & 7;
  return 0LL;
}



__int64 pdc_initialize()
{
  __int64 result; // x0

  if ( (unsigned int)pdcMap_getInterruptTable((__int64)g_pdcInterrupts) )
    qtisec_assert(
      "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
      0x171u,
      "PDC_SUCCESS == pdcMap_getInterruptTable(&g_pdcInterrupts)");
  result = pdcMap_getGpioTable((__int64)g_pdcGpios);
  if ( (_DWORD)result )
    qtisec_assert(
      "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
      0x173u,
      "PDC_SUCCESS == pdcMap_getGpioTable(&g_pdcGpios)");
  return result;
}



__int64 __fastcall pdcInt_config(int a1, __int64 a2)
{
  unsigned int Entry; // w0
  _DWORD *v3; // x5
  _DWORD *v4; // x3

  if ( !a2 )
    return 19LL;
  Entry = int_findEntry(a1);
  if ( Entry >= LODWORD(g_pdcInterrupts[1]) )
    return 18LL;
  v4 = (_DWORD *)(g_pdcInterrupts[0] + 12LL * Entry);
  *v4 = *v3;
  v4[1] = v3[1];
  return pdcHAL_setTriggerConfig(Entry, 0, v3);
}



__int64 __fastcall pdcInt_disable(int a1)
{
  unsigned int Entry; // w0

  Entry = int_findEntry(a1);
  if ( Entry >= hmss_pcu_memory_base[0] )
    return 18LL;
  else
    return pdcHAL_disable(Entry, 0);
}



__int64 __fastcall pdcInt_enable(int a1)
{
  unsigned int Entry; // w0

  Entry = int_findEntry(a1);
  if ( Entry >= hmss_pcu_memory_base[0] )
    return 18LL;
  else
    return pdcHAL_enable(Entry, 0);
}



__int64 __fastcall pdcMap_getGpioTable(__int64 a1)
{
  if ( !a1 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/mapping.c", 0x48u, "((void *) 0) != (gpioMap)");
  *(_QWORD *)a1 = g_pdcGpioInputs;
  *(_QWORD *)(a1 + 8) = g_pdcGpioMapping;
  *(_DWORD *)(a1 + 16) = 98;
  *(_DWORD *)(a1 + 20) = 98;
  return 0LL;
}



__int64 __fastcall pdcMap_getInterruptTable(__int64 a1)
{
  if ( !a1 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/mapping.c", 0x3Fu, "((void *) 0) != (intMap)");
  *(_QWORD *)a1 = g_pdcInterruptMapping;
  *(_DWORD *)(a1 + 8) = 70;
  return 0LL;
}




__int64 __fastcall pdc_seq_copy_cmd_seq(__int64 a1)
{
  unsigned int v2; // w20
  __int64 v3; // x1
  __int64 v4; // x21
  __int64 v5; // x4
  int i; // w2
  __int64 v7; // x5
  __int16 v8; // w0
  __int16 v9; // w1

  v2 = 0;
LABEL_2:
  if ( (unsigned __int64)v2 >= *(_QWORD *)(a1 + 24) )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = v3 + 32LL * v2;
  if ( !*(_WORD *)(v4 + 8) )
    return 4294967294LL;
  v5 = *(_QWORD *)(a1 + 16);
  for ( i = 0; v2 != i; ++i )
  {
    v7 = v5;
    v5 += 32LL;
    if ( *(_QWORD *)v7 == *(_QWORD *)v4 )
    {
      *(_WORD *)(v4 + 24) = *(_WORD *)(v7 + 24);
LABEL_11:
      ++v2;
      goto LABEL_2;
    }
  }
  v8 = pdc_seq_hal_copy_cmd_seq(
         *(_QWORD *)(a1 + 48),
         *(_WORD *)(a1 + 112),
         *(_QWORD *)(v3 + 32LL * v2),
         *(unsigned __int16 *)(v3 + 32LL * v2 + 8));
  if ( v8 )
  {
    v9 = *(_WORD *)(a1 + 112);
    *(_WORD *)(v4 + 24) = v9;
    *(_WORD *)(a1 + 112) = v8 + v9;
    goto LABEL_11;
  }
  return 4294967292LL;
}



__int64 __fastcall pdc_seq_count(unsigned __int8 a1)
{
  int v1; // w3
  unsigned __int8 *v2; // x1
  __int64 result; // x0
  int v4; // t1

  v1 = a1;
  v2 = (unsigned __int8 *)g_pdc_seqs;
  result = 0LL;
  while ( v2 != (unsigned __int8 *)(g_pdc_seqs + 120LL * (unsigned int)g_pdc_seq_count) )
  {
    v4 = *v2;
    v2 += 120;
    if ( v4 == v1 )
      result = (unsigned int)(result + 1);
    else
      result = (unsigned int)result;
  }
  return result;
}




__int64 __fastcall pdc_seq_enable(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 48);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    pdc_seq_hal_enable(v2, a2 != 0);
    return 0LL;
  }
  return result;
}



__int64 __fastcall pdc_seq_enable_arc_timer(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 48);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    pdc_seq_hal_enable_arc_timer(v2, a2 != 0);
    return 0LL;
  }
  return result;
}



__int64 __fastcall pdc_seq_enable_profile_ts(__int64 a1, unsigned __int8 a2)
{
  int v2; // w22
  unsigned int v3; // w1
  int v5; // w21
  int i; // w20
  unsigned __int8 v7; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  if ( *(_QWORD *)(a1 + 48) )
  {
    v5 = pdc_seq_profile_ts_count(a1);
    for ( i = 0; i != v5; ++i )
    {
      v7 = i;
      pdc_seq_hal_enable_profile_ts(*(_QWORD *)(a1 + 48), v7, v2 != 0);
    }
    return 0;
  }
  return v3;
}



__int64 __fastcall pdc_seq_hal_cfg_br_addr(__int64 a1, unsigned __int16 a2, unsigned __int8 a3)
{
  if ( a2 > 3u )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 4LL * a2 + 17760) = a3;
  return 0LL;
}



__int64 __fastcall pdc_seq_hal_cfg_br_event_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1360) = a2;
  *(_DWORD *)(result + 1364) = a3;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_delay(__int64 a1, unsigned __int16 a2, int a3)
{
  if ( a2 > 0xFu )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 4LL * a2 + 17824) = a3;
  return 0LL;
}



__int64 __fastcall pdc_seq_hal_cfg_pwr_ctl_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1328) = a2;
  *(_DWORD *)(result + 1332) = a3;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_start_addr(__int64 result, unsigned __int16 a2)
{
  *(_DWORD *)(result + 72) = a2 | 0x80000000;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_start_addr_ex(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1312) = a2;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_wait_event_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1344) = a2;
  *(_DWORD *)(result + 1348) = a3;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_wakeup_time(__int64 result, __int64 a2)
{
  *(_DWORD *)(result + 64) = a2;
  *(_DWORD *)(result + 56) = HIDWORD(a2) | 0x80000000;
  return result;
}



__int64 __fastcall pdc_seq_hal_cfg_wakeup_time_ex(__int64 a1, __int64 a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_QWORD *)(result + 1296) = a2;
  return result;
}



__int64 __fastcall pdc_seq_hal_clk_gate_enable(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1280) = *(_DWORD *)(result + 1280) & 0x101 | ((a2 == 0) << 31);
  return result;
}



__int64 __fastcall pdc_seq_hal_copy_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w5
  unsigned int v5; // w4
  __int64 v6; // x8
  int v7; // w6
  int v8; // w10
  int v9; // w11
  char v10; // w7
  __int64 v11; // x5
  int v12; // w7
  int v13; // w9
  int v14; // w5
  __int64 v15; // x1

  a4 = (unsigned __int16)a4;
  v4 = 4 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 4104));
  if ( v4 <= a2 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v4 < v5 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)(unsigned __int16)v6 )
    {
      v9 = ((_BYTE)a2 + (_BYTE)v6) & 3;
      v10 = 16;
      if ( v9 != 2 )
      {
        v10 = 24;
        if ( v9 != 3 )
        {
          v10 = 8;
          if ( v9 != 1 )
          {
            v10 = 0;
            if ( (_WORD)v6 )
            {
              v11 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 4) + 0x200000LL;
              v12 = *(_DWORD *)(a1 + v11);
              v13 = v7 ^ v12;
              v7 = 0;
              *(_DWORD *)(a1 + v11) = v13 & v8 ^ v12;
              v10 = 0;
            }
          }
        }
      }
      v8 |= 255 << v10;
      v14 = *(unsigned __int8 *)(a3 + v6++);
      v7 |= v14 << v10;
    }
    v15 = 4 * (((unsigned __int16)v5 - 1) / 4) + 0x200000LL;
    *(_DWORD *)(a1 + v15) ^= (v7 ^ *(_DWORD *)(a1 + v15)) & v8;
  }
  return a4;
}



__int64 __fastcall pdc_seq_hal_enable(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1280) = *(_DWORD *)(result + 1280) & 0x80000100 | (a2 != 0);
  return result;
}



__int64 __fastcall pdc_seq_hal_enable_arc_timer(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1304) = a2 == 0;
  return result;
}



__int64 __fastcall pdc_seq_hal_enable_profile_ts(__int64 a1, unsigned __int8 a2, char a3)
{
  if ( a2 >= (unsigned int)((unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12) )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 20LL * a2 + 20480) = a3 != 0;
  return 0LL;
}



unsigned __int64 __fastcall pdc_seq_hal_profile_ts(__int64 a1, unsigned __int8 a2)
{
  if ( a2 >= (unsigned int)((unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12) )
    return 0LL;
  else
    return ((unsigned __int64)(*(_DWORD *)(a1 + 20LL * a2 + 4616) & 0xFFFFFF) << 32) | *(unsigned int *)(a1 + 20LL * a2 + 4612);
}



__int64 __fastcall pdc_seq_hal_profile_ts_count(__int64 a1)
{
  return (unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12;
}



__int64 __fastcall pdc_seq_handle_env_init(_QWORD *a1)
{
  unsigned int v1; // w3
  __int64 v2; // x2

  if ( !g_pdc_aoss_base )
    g_pdc_aoss_base = 184549376LL;
  if ( !g_pdc_ss_base )
    g_pdc_ss_base = 394264576LL;
  v1 = -2;
  if ( a1 )
  {
    v1 = 0;
    a1[6] = g_pdc_aoss_base + a1[4];
    v2 = a1[5];
    if ( v2 )
      a1[7] = g_pdc_ss_base + v2;
  }
  return v1;
}



__int64 __fastcall pdc_seq_handle_init(_QWORD *a1)
{
  __int64 result; // x0

  if ( !a1 || !a1[1] || !a1[2] || !a1[4] )
    return 0xFFFFFFFFLL;
  result = pdc_seq_handle_env_init(a1);
  if ( !(_DWORD)result )
  {
    result = pdc_seq_handle_target_init((__int64)a1);
    if ( !(_DWORD)result )
    {
      result = pdc_seq_handle_internal_cfg((__int64)a1);
      if ( !(_DWORD)result )
        return pdc_seq_copy_cmd_seq((__int64)a1);
    }
  }
  return result;
}



__int64 __fastcall pdc_seq_handle_internal_cfg(__int64 a1)
{
  __int64 v1; // x21
  unsigned int i; // w19
  unsigned int j; // w19

  v1 = *(_QWORD *)(a1 + 8);
  for ( i = 0; i < *(_DWORD *)(v1 + 8); ++i )
  {
    if ( (unsigned int)pdc_seq_hal_cfg_br_addr(*(_QWORD *)(a1 + 48), i, *(_BYTE *)(*(_QWORD *)v1 + i)) )
      return 4294967294LL;
  }
  for ( j = 0; j < *(_DWORD *)(v1 + 24); ++j )
  {
    if ( (unsigned int)pdc_seq_hal_cfg_delay(*(_QWORD *)(a1 + 48), j, *(_DWORD *)(*(_QWORD *)(v1 + 16) + 4LL * j)) )
      return 4294967294LL;
  }
  if ( (unsigned int)pdc_seq_hal_profile_ts_count(*(_QWORD *)(a1 + 48)) != 5 )
    return 4294967294LL;
  return 0LL;
}



__int64 __fastcall pdc_seq_handles(unsigned __int8 a1, unsigned int a2, __int64 a3)
{
  int v3; // w5
  bool v4; // zf
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 result; // x0

  v3 = a1;
  if ( a2 )
    v4 = a3 == 0;
  else
    v4 = 1;
  if ( v4 || a1 > 1u )
    return 0LL;
  v6 = 0LL;
  v7 = 120LL * (unsigned int)g_pdc_seq_count;
  result = 0LL;
  while ( v6 != v7 )
  {
    if ( *(unsigned __int8 *)(g_pdc_seqs + v6) == v3 )
    {
      if ( (unsigned int)result >= a2 )
        return result;
      *(_QWORD *)(a3 + 8LL * (unsigned int)result) = g_pdc_seqs + v6;
      result = (unsigned int)(result + 1);
    }
    v6 += 120LL;
  }
  return result;
}



__int64 __fastcall pdc_seq_handle_target_init(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 48) )
    return 0LL;
  return 0xFFFFFFFFLL;
}



__int64 __fastcall pdc_seq_mode_index(__int64 a1, unsigned __int16 a2)
{
  unsigned int i; // w2

  for ( i = 0; (unsigned __int64)i < *(_QWORD *)(a1 + 24); ++i )
  {
    if ( *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 32LL * i + 10) == a2 )
      return i;
  }
  return 4294967293LL;
}



__int64 __fastcall pdc_seq_profile_ts(__int64 a1)
{
  unsigned __int64 *v1; // x22
  __int64 v3; // x20
  int v4; // w23
  int i; // w21
  unsigned __int8 v6; // w1

  if ( !a1 || !*(_QWORD *)(a1 + 48) )
    return 0LL;
  v1 = (unsigned __int64 *)(a1 + 64);
  v3 = a1 + 64;
  v4 = pdc_seq_profile_ts_count(a1);
  for ( i = 0; i != v4; ++i )
  {
    v6 = i;
    *v1++ = pdc_seq_hal_profile_ts(*(_QWORD *)(a1 + 48), v6);
  }
  return v3;
}



__int64 __fastcall pdc_seq_profile_ts_count(__int64 a1)
{
  __int64 v1; // x0

  if ( a1 && (v1 = *(_QWORD *)(a1 + 48)) != 0 )
    return pdc_seq_hal_profile_ts_count(v1);
  else
    return 0LL;
}



__int64 __fastcall pdc_seq_set_lpm(_QWORD *a1, unsigned __int16 a2)
{
  unsigned int v2; // w2
  signed int v4; // w0
  __int64 v5; // x1
  __int64 v6; // x0
  __int16 v7; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = -1;
  if ( a1[6] )
  {
    v4 = pdc_seq_mode_index((__int64)a1, a2);
    v2 = v4;
    if ( v4 != -3 )
    {
      v5 = a1[2] + 32LL * v4;
      v6 = a1[7];
      v7 = *(_WORD *)(v5 + 24);
      if ( v6 )
        pdc_seq_hal_cfg_start_addr(v6, v7);
      else
        pdc_seq_hal_cfg_start_addr_ex(a1[6], v7);
      return 0;
    }
  }
  return v2;
}



__int64 __fastcall pdc_seq_set_wakeup_time(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 48) )
  {
    v4 = *(_QWORD *)(a1 + 56);
    if ( v4 )
      pdc_seq_hal_cfg_wakeup_time(v4, a2);
    else
      pdc_seq_hal_cfg_wakeup_time_ex(*(_QWORD *)(a1 + 48), a2);
    return 0LL;
  }
  return result;
}



__int64 pdc_seq_sys_init()
{
  unsigned int v0; // w19
  __int64 result; // x0
  _QWORD *v2; // x20
  int v3; // w0
  int v4; // w0

  v0 = 0;
  pdc_seq_driver_init();
  while ( 1 )
  {
    result = (unsigned int)g_pdc_seq_count;
    if ( v0 >= g_pdc_seq_count )
      break;
    v2 = (_QWORD *)(g_pdc_seqs + 120LL * v0);
    v3 = pdc_seq_handle_init(v2);
    while ( v3 )
      ;
    v4 = pdc_seq_enable((__int64)v2, 1);
    while ( v4 )
      ;
    ++v0;
  }
  return result;
}



__int64 pdc_seq_test()
{
  int v0; // w19
  __int64 result; // x0
  _QWORD *v2; // [xsp+28h] [xbp+28h] BYREF

  pdc_seq_driver_init();
  pdc_seq_handles(0, 1u, (__int64)&v2);
  v0 = pdc_seq_handle_init(v2);
  pdc_seq_set_lpm(v2, 2u);
  result = pdc_seq_set_wakeup_time((__int64)v2, 0x123456789ABCDLL);
  if ( v0 )
  {
    while ( 1 )
      ;
  }
  return result;
}




__int64 pdcTarget_preInit()
{
  __int64 result; // x0

  for ( result = 0LL; result != 98; ++result )
  {
    g_pdcGpioMapping[3 * (int)result + 1] = &g_pdcGpioInputs[2 * result];
    g_pdcGpioInputs[2 * (int)result + 1] = result;
  }
  return result;
}




char *__fastcall pdcTcs_getResources(unsigned int a1)
{
  if ( a1 > 3 )
    qtisec_assert("noship_src/drivers/pdc/tcs/src/pdcTcs.c", 0xC1u, "tcsNum < TCS_NUM_TOTAL");
  return (char *)&g_pdcTCSConfig + 96 * a1;
}



__int64 pdcTcs_initialize()
{
  int v0; // w19
  unsigned int v1; // w23
  char *v2; // x21
  char *v3; // x20
  char *v4; // x22
  int v5; // w24
  __int64 result; // x0
  unsigned __int64 v7; // x20
  __int64 i; // x5
  unsigned int v9; // w19
  char *v10; // x4
  int v11; // w1
  int v12; // w0
  int *v13; // x14
  unsigned int v14; // w0
  unsigned __int64 v15; // x2
  char **v16; // x2
  unsigned __int64 v17; // x2
  int v18; // w3
  __int64 v19[2]; // [xsp+40h] [xbp+40h]

  v0 = unk_1CC68;
  v1 = unk_1CC6C;
  v19[0] = 0LL;
  v19[1] = 0LL;
  v2 = (char *)off_1CC58;
  if ( unk_1CC6C > 4u )
    qtisec_assert("noship_src/drivers/pdc/tcs/src/pdcTcs.c", 0x81u, "(TCS_NUM_TOTAL >= TotalnTCS)");
  v3 = off_1CC60 + 8;
  v4 = off_1CC60 + 72;
  v5 = 0;
  do
  {
    result = cmd_db_query_addr(*((_QWORD *)v3 - 1));
    if ( (_DWORD)result )
    {
      result = (unsigned int)(*(_DWORD *)v3 + result);
      *(_DWORD *)v3 = result;
    }
    else
    {
      ++v5;
    }
    v3 += 16;
  }
  while ( v4 != v3 );
  if ( !v5 )
  {
    v7 = (unsigned int)(v0 + 4100);
    if ( (unsigned __int8)*(_DWORD *)v7 >> 5 != 4 )
      qtisec_assert(
        "noship_src/drivers/pdc/tcs/src/pdcTcs.c",
        0x9Bu,
        "4 == (((*((volatile uint32_t *) ((uintptr_t) ((pdc_res.subsytem_addr) + 0X1004 + (0x10000*(0)))))) & (0xe0)) >> 5)");
    if ( ((*(_DWORD *)v7 >> 8) & 0xFu) < v1 )
      qtisec_assert(
        "noship_src/drivers/pdc/tcs/src/pdcTcs.c",
        0x9Cu,
        "TotalnTCS <= (((*((volatile uint32_t *) ((uintptr_t) ((pdc_res.subsytem_addr) + 0X1004 + (0x10000*(0)))))) & (0xf00)) >> 8)");
    for ( i = 0LL; i != v1; ++i )
    {
      v10 = &v2[96 * i];
      v11 = 0;
      v12 = v0 + 200 * (unsigned __int16)i;
      v13 = (int *)(unsigned int)(v12 + 21768);
      v14 = v12 + 21776;
      do
      {
        v15 = *((unsigned int *)v10 + 3);
        if ( (v15 & 0x10) == 0 )
        {
          if ( (v15 & 8) == 0 )
            *((_DWORD *)v19 + i) |= 1 << v11;
          *(_DWORD *)(v14 - 4) = (((v15 >> 1) & 1) << 8) | ((((v15 ^ 4) >> 2) & 1) << 16);
          if ( (v15 & 1) != 0 )
            *v13 = (1 << v11) | *v13 & 0xF;
          v16 = &(&g_pdcResourceList)[2 * (unsigned __int8)*v10];
          *(_QWORD *)v10 = v16;
          *(_DWORD *)v14 = *((_DWORD *)v16 + 2) + *((_DWORD *)v10 + 4);
          *(_DWORD *)(v14 + 4) = *((_DWORD *)v10 + 2);
        }
        ++v11;
        v10 += 24;
        v14 += 16;
      }
      while ( v11 != 4 );
    }
    v9 = v0 + 21764;
    for ( result = 0LL; result != v1; ++result )
    {
      v17 = v9;
      v18 = *((_DWORD *)v19 + result);
      v9 += 200;
      *(_DWORD *)v17 = v18;
    }
  }
  return result;
}



__int64 __fastcall pm_app_ps_hold_cfg(unsigned int a1)
{
  __int64 result; // x0
  unsigned int v3; // w21
  unsigned int v4; // w19
  unsigned int i; // w20
  int pmic_model; // w0
  unsigned int v8; // [xsp+3Ch] [xbp+3Ch] BYREF

  v8 = 15;
  if ( a1 > 4 )
    return 2LL;
  result = 4LL;
  if ( a1 - 3 > 1 )
  {
    v3 = a1;
    result = pm_comm_channel_init_internal();
    if ( !(_DWORD)result )
    {
      result = pm_version_detect();
      v4 = result;
      if ( !(_DWORD)result )
      {
        for ( i = 0; i != 7; ++i )
        {
          pmic_model = pm_get_pmic_model(i);
          if ( pmic_model != 0x7FFFFFFF && pmic_model != 0 )
          {
            v4 |= pm_tgt_get_pshold_reset_cfg(i, v3, &v8);
            if ( v4 )
              return v4;
            if ( v8 != 15 )
              v4 = pm_pon_ps_hold_cfg(i, v8);
            v4 |= pm_pon_tgt_specific_pshold_cfg(i, v3);
          }
        }
        return v4;
      }
    }
  }
  return result;
}



__int64 pm_comm_channel_init_internal()
{
  int v0; // w0
  unsigned int v1; // w1

  v0 = SpmiBus_Init();
  v1 = 128;
  if ( !v0 )
  {
    spmi_initialized = 1;
    return 0;
  }
  return v1;
}



__int64 __fastcall pm_comm_read_byte(char a1, unsigned __int16 a2, char *a3, unsigned __int8 a4)
{
  int Long; // w0
  unsigned int v5; // w1
  int v7; // [xsp+1Ch] [xbp+1Ch] BYREF

  v7 = 0;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  Long = SpmiBus_ReadLong(a1, a4, a2, a3, 1u, (__int64 *)&v7);
  v5 = 0;
  if ( Long )
    return 128;
  return v5;
}



__int64 __fastcall pm_comm_read_byte_array(char a1, unsigned __int16 a2, unsigned int a3, char *a4, unsigned __int8 a5)
{
  int Long; // w0
  unsigned int v6; // w1
  int v8; // [xsp+1Ch] [xbp+1Ch] BYREF

  v8 = 0;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  Long = SpmiBus_ReadLong(a1, a5, a2, a4, a3, (__int64 *)&v8);
  v6 = 0;
  if ( Long )
    return 128;
  return v6;
}



__int64 __fastcall pm_comm_read_byte_mask(char a1, unsigned __int16 a2, char a3, char *a4, unsigned __int8 a5)
{
  __int64 result; // x0

  result = pm_comm_read_byte(a1, a2, a4, a5);
  if ( (_DWORD)result )
    return 128LL;
  *a4 &= a3;
  return result;
}



__int64 __fastcall pm_comm_write_byte(char a1, unsigned __int16 a2, char a3, unsigned __int8 a4)
{
  int v4; // w0
  unsigned int v5; // w1
  char v7; // [xsp+1Fh] [xbp+1Fh] BYREF

  v7 = a3;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  v4 = SpmiBus_WriteLong(a1, a4, a2, &v7, 1u);
  v5 = 0;
  if ( v4 )
    return 128;
  return v5;
}



__int64 __fastcall pm_comm_write_byte_array(
        char a1,
        unsigned __int16 a2,
        unsigned int a3,
        char *a4,
        unsigned __int8 a5)
{
  int v5; // w0
  unsigned int v6; // w1

  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128LL;
  v5 = SpmiBus_WriteLong(a1, a5, a2, a4, a3);
  v6 = 0;
  if ( v5 )
    return 128;
  return v6;
}



__int64 __fastcall pm_comm_write_byte_mask(char a1, unsigned __int16 a2, char a3, char a4, unsigned __int8 a5)
{
  int v5; // w21
  int v7; // w23
  char v11; // [xsp+4Bh] [xbp+4Bh] BYREF
  int v12; // [xsp+4Ch] [xbp+4Ch] BYREF

  v5 = a2;
  v11 = 0;
  v12 = 1;
  if ( (unsigned __int8)spmi_initialized > (unsigned int)(a2 == 0xFFFF)
    && ((v7 = a5, (unsigned int)SpmiBus_ReadLong(a1, a5, a2, &v11, 1u, (__int64 *)&v12))
     || (v11 = v11 & ~a3 | a3 & a4, !(unsigned int)SpmiBus_WriteLong(a1, v7, v5, &v11, 1u))) )
  {
    return 0LL;
  }
  else
  {
    return 128LL;
  }
}



__int64 __fastcall pm_get_pmic_model(unsigned __int8 a1)
{
  if ( (unsigned __int8)pm_version_initialized <= (unsigned int)(a1 > 6u) )
    return 0x7FFFFFFFLL;
  else
    return (unsigned int)pm_device_info_arr[3 * a1];
}



__int64 __fastcall pm_get_slave_id(unsigned __int8 a1, unsigned __int8 a2, unsigned int *a3)
{
  unsigned int v4; // w1

  if ( !a3 || (unsigned __int8)pm_version_initialized <= (unsigned int)(a2 > 1u) )
    return 4LL;
  if ( a1 != 7 )
  {
    if ( a1 <= 6u )
    {
      v4 = a2 + pm_primary_slave_id[a1];
      *a3 = v4;
      if ( v4 <= 0xD )
        return 0LL;
    }
    return 4LL;
  }
  *a3 = a2 + 14;
  return 0LL;
}



__int64 __fastcall pm_pon_get_reset_config_val(int a1, char *a2)
{
  char v2; // w0
  __int64 result; // x0

  switch ( a1 )
  {
    case 0:
      v2 = 1;
      goto LABEL_11;
    case 1:
      v2 = 4;
      goto LABEL_11;
    case 2:
      v2 = 5;
      goto LABEL_11;
    case 3:
      v2 = 6;
      goto LABEL_11;
    case 4:
      v2 = 7;
      goto LABEL_11;
    case 5:
      v2 = 8;
      goto LABEL_11;
    case 7:
      v2 = 9;
      goto LABEL_11;
    case 8:
      v2 = 2;
      goto LABEL_11;
    case 14:
      v2 = 15;
LABEL_11:
      *a2 = v2;
      result = 0LL;
      break;
    default:
      result = 4LL;
      break;
  }
  return result;
}



__int64 __fastcall pm_pon_gp_reset_cfg(unsigned __int8 a1, int a2, unsigned int a3)
{
  int slave_id; // w0
  void *v7; // x20
  unsigned int reset_config_val; // w19
  char v9; // w2
  char v11; // [xsp+2Ah] [xbp+2Ah] BYREF
  char v12; // [xsp+2Bh] [xbp+2Bh] BYREF
  unsigned int v13; // [xsp+2Ch] [xbp+2Ch] BYREF

  v12 = 0;
  v13 = 0;
  slave_id = pm_get_slave_id(a1, 0, &v13);
  if ( a3 > 0xE || slave_id != 0 )
    return 2;
  if ( a2 == 4 )
  {
    v7 = &pon_gp1_reg;
  }
  else
  {
    if ( a2 != 5 )
      return 2;
    v7 = &pon_gp2_reg;
  }
  reset_config_val = pm_pon_get_reset_config_val(a3, &v12);
  if ( !reset_config_val )
  {
    reset_config_val = pm_comm_read_byte(v13, *((_WORD *)v7 + 5), &v11, 0);
    if ( !reset_config_val )
    {
      v9 = *((_BYTE *)v7 + 12);
      v11 &= v9;
      if ( v11 )
      {
        reset_config_val = pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 5), v9, 0, 0);
        qtiseclib_cb_udelay(300LL);
      }
      reset_config_val |= pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 4), *((_BYTE *)v7 + 14), v12, 0);
      if ( v11 )
        reset_config_val |= pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 5), *((_BYTE *)v7 + 12), -1, 0);
    }
  }
  return reset_config_val;
}



__int64 pm_pon_init()
{
  int v0; // w19
  __int64 result; // x0
  __int16 v2; // w1
  char v3; // [xsp+25h] [xbp+25h] BYREF
  char v4; // [xsp+26h] [xbp+26h] BYREF
  char v5; // [xsp+27h] [xbp+27h] BYREF
  __int16 v6; // [xsp+28h] [xbp+28h] BYREF

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v0 = pm_comm_read_byte(0, 0x804u, &v3, 0);
  result = v0 | (unsigned int)pm_comm_read_byte(0, 0x805u, &v4, 0);
  if ( !(_DWORD)result )
  {
    result = 4LL;
    if ( v3 == 1 )
    {
      if ( v4 == 8 )
      {
        pon_ps_hold_reg = 2130;
        word_31152 = 2131;
        word_31154 = 255;
        v2 = 128;
      }
      else
      {
        pon_ps_hold_reg = 2138;
        word_31152 = 2139;
        word_31154 = 128;
        v2 = 15;
      }
      word_31156 = v2;
      result = pm_comm_read_byte(0, 0x801u, &v5, 0);
      if ( !(_DWORD)result )
      {
        if ( !v5 )
          word_31152 = pon_ps_hold_reg;
        if ( v4 == 8
          || (result = pm_comm_read_byte_array(0, 0x80Au, 2u, (char *)&v6, 0), !(_DWORD)result)
          && (!v6 || (result = pm_comm_write_byte_mask(0, 0x88Du, 1, 1, 0), !(_DWORD)result)) )
        {
          pm_pon_initialized = 1;
          return 0LL;
        }
      }
    }
  }
  return result;
}



__int64 __fastcall pm_pon_ps_hold_cfg(unsigned __int8 a1, unsigned int a2)
{
  unsigned int inited; // w1
  int slave_id; // w0
  char v6; // w19
  int v7; // w19
  unsigned int v9; // [xsp+3Ch] [xbp+3Ch] BYREF

  v9 = 0;
  inited = pm_comm_channel_init_internal();
  if ( !inited )
  {
    slave_id = pm_get_slave_id(a1, 0, &v9);
    inited = 2;
    if ( !slave_id )
    {
      inited = 4;
      if ( a2 <= 0xE && (pm_pon_initialized || (inited = pm_pon_init()) == 0) )
      {
        switch ( a2 )
        {
          case 0u:
            v6 = 1;
            goto LABEL_17;
          case 1u:
            v6 = 4;
            goto LABEL_17;
          case 2u:
            v6 = 5;
            goto LABEL_17;
          case 3u:
            v6 = 6;
            goto LABEL_17;
          case 4u:
            v6 = 7;
            goto LABEL_17;
          case 5u:
          case 6u:
            v6 = 8;
            goto LABEL_17;
          case 7u:
            v6 = 9;
            goto LABEL_17;
          case 8u:
            v6 = 2;
            goto LABEL_17;
          case 0xEu:
            v6 = 15;
LABEL_17:
            inited = pm_comm_write_byte(v9, word_31152, 0, 0);
            if ( !inited )
            {
              qtiseclib_cb_udelay(300LL);
              v7 = pm_comm_write_byte(v9, pon_ps_hold_reg, v6, 0);
              inited = v7 | pm_comm_write_byte(v9, word_31152, word_31154, 0);
            }
            break;
          default:
            inited = 4;
            break;
        }
      }
    }
  }
  return inited;
}



__int64 __fastcall pm_pon_tgt_specific_pshold_cfg(unsigned int a1, unsigned int a2)
{
  bool v2; // cc
  unsigned int pshold_gp1_reset_cfg; // w19
  unsigned __int8 v4; // w4
  unsigned int v6; // [xsp+2Ch] [xbp+2Ch] BYREF

  v2 = a1 > 6 || a2 > 4;
  pshold_gp1_reset_cfg = 2;
  v6 = 15;
  if ( !v2 )
  {
    pshold_gp1_reset_cfg = pm_tgt_get_pshold_gp1_reset_cfg(a1, a2, &v6);
    if ( v6 != 15 )
      pshold_gp1_reset_cfg |= pm_pon_gp_reset_cfg(v4, 4, v6);
  }
  return pshold_gp1_reset_cfg;
}



__int64 __fastcall pm_tgt_get_pshold_gp1_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  if ( a2 > 4 || a3 == 0LL || a1 > 6 )
    return 2LL;
  *a3 = pm_pon_pshold_gp1_reset_cfg_arr[7 * a2 + a1];
  return 0LL;
}



__int64 __fastcall pm_tgt_get_pshold_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  if ( a2 > 4 || a3 == 0LL || a1 > 6 )
    return 2LL;
  *a3 = pm_pon_pshold_reset_cfg_arr[7 * a2 + a1];
  return 0LL;
}



__int64 pm_version_detect()
{
  __int64 result; // x0
  int *v1; // x19
  __int64 v2; // x20
  int v3; // w21
  char v4[8]; // [xsp+40h] [xbp+40h] BYREF
  char v5; // [xsp+48h] [xbp+48h] BYREF

  qtiseclib_cb_memset(&v5, 0LL, 6LL);
  qtiseclib_cb_memset(v4, 0LL, 4LL);
  result = 0LL;
  if ( !pm_version_initialized )
  {
    v1 = pm_device_info_arr;
    v2 = 0LL;
    qtiseclib_cb_memset(pm_primary_slave_id, 255LL, 28LL);
    while ( 1 )
    {
      v3 = 2 * v2;
      result = pm_comm_read_byte_array(2 * (unsigned __int8)v2, 0x102u, 4u, v4, 0);
      if ( (_DWORD)result )
      {
        result = 0LL;
      }
      else if ( v4[2] == 81 )
      {
        *v1 = (unsigned __int8)v4[3];
        v1[1] = (unsigned __int8)v4[1];
        v1[2] = (unsigned __int8)v4[0];
        result = pm_comm_read_byte_array(v3, 0x100u, 6u, &v5, 0);
        pm_primary_slave_id[v2] = v3;
      }
      if ( v2 == 6 )
        break;
      ++v2;
      v1 += 3;
    }
    pm_version_initialized = 1;
  }
  return result;
}



__int64 __fastcall pwr_utils_hlvl(int a1, int a2, char *a3)
{
  int v3; // wzr
  __int64 v5; // x3
  __int64 result; // x0
  int v7; // w4
  char v8; // [xsp+Ch] [xbp-4h] BYREF

  if ( !a3 )
    a3 = &v8;
  if ( a1 >= (unsigned __int64)g_res_count || a2 < v3 )
  {
    result = 0xFFFFFFFFLL;
    *(_DWORD *)a3 = -1;
  }
  else
  {
    v5 = g_res + 24LL * a1;
    for ( result = 0LL; (unsigned __int64)(unsigned int)result < *(_QWORD *)(v5 + 16); result = (unsigned int)(result + 1) )
    {
      v7 = *(unsigned __int16 *)(*(_QWORD *)(v5 + 8) + 2LL * (unsigned int)result);
      if ( a2 <= v7 )
      {
        *(_DWORD *)a3 = v7;
        return result;
      }
    }
    *(_DWORD *)a3 = -2;
    return 0xFFFFFFFFLL;
  }
  return result;
}



__int64 __fastcall pwr_utils_hlvl_named_resource(__int64 a1, int a2, char *a3)
{
  int v5; // w0

  v5 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_hlvl(v5, a2, a3);
}



__int64 pwr_utils_lvl_init()
{
  unsigned int v0; // w20
  __int64 result; // x0
  __int64 v2; // x0
  __int64 v3; // x27
  __int64 v4; // x24
  unsigned int len; // w0
  unsigned int v6; // w19
  char *v7; // x2
  __int64 v8; // x19
  __int64 i; // x1
  unsigned __int8 v11; // [xsp+6Fh] [xbp+6Fh] BYREF

  g_res = (__int64)&resource_list;
  v0 = 0;
  g_res_count = 9LL;
  while ( 1 )
  {
    result = g_res_count;
    if ( g_res_count <= (unsigned __int64)v0 )
      break;
    v2 = 24LL * v0;
    v3 = *(_QWORD *)(g_res + v2);
    v4 = g_res + v2;
    len = cmd_db_query_len(v3);
    v11 = len;
    v6 = len;
    if ( len )
    {
      if ( len > 0x20 )
        qtisec_assert("noship_src/services/pwr_utils/pwr_utils_lvl.c", 0x74u, "data_len <= MAX_AUX_DATA_LEN");
      if ( (unsigned __int64)len + alloc_offset_1210 > 0x1FF )
        qtisec_assert(
          "noship_src/services/pwr_utils/pwr_utils_lvl.c",
          0x77u,
          "(alloc_offset + data_len) < (sizeof (lvl_buf)/sizeof (lvl_buf[0]))");
      v7 = (char *)&lvl_buf + 2 * alloc_offset_1210;
      alloc_offset_1210 += len;
      *(_QWORD *)(v4 + 8) = v7;
      cmd_db_query_aux_data(v3, &v11, (__int64)v7);
      if ( v6 != v11 )
        qtisec_assert("noship_src/services/pwr_utils/pwr_utils_lvl.c", 0x7Cu, "data_len == (uint32_t)aux_len");
      v8 = v6 >> 1;
      for ( i = 0LL; i != v8; ++i )
      {
        if ( !*(_WORD *)(*(_QWORD *)(v4 + 8) + 2 * i) && (_DWORD)i != 0 )
          break;
      }
      *(_QWORD *)(v4 + 16) = (unsigned int)i;
    }
    ++v0;
  }
  return result;
}



__int64 __fastcall pwr_utils_lvl_resource_idx(__int64 a1)
{
  unsigned int i; // w19

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( g_res && g_res_count )
  {
    for ( i = 0; g_res_count > (unsigned __int64)i; ++i )
    {
      if ( !(unsigned int)qtiseclib_cb_strcmp(*(_QWORD *)(g_res + 24LL * i)) )
        return i;
    }
  }
  return 0xFFFFFFFFLL;
}



__int64 __fastcall pwr_utils_named_resource_lvls_count(__int64 a1)
{
  int v1; // w0

  v1 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_resource_lvls_count(v1);
}



__int64 __fastcall pwr_utils_resource_lvls_count(int a1)
{
  if ( g_res_count <= (unsigned __int64)a1 )
    return 0xFFFFFFFFLL;
  else
    return *(unsigned int *)(g_res + 24LL * a1 + 16);
}



__int64 __fastcall pwr_utils_vlvl(int a1, int a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( g_res_count <= (unsigned __int64)a1 )
    return 0xFFFFFFFFLL;
  v2 = g_res + 24LL * a1;
  result = 0xFFFFFFFFLL;
  if ( (unsigned __int64)a2 < *(_QWORD *)(v2 + 16) )
    return *(unsigned __int16 *)(*(_QWORD *)(v2 + 8) + 2LL * a2);
  return result;
}



__int64 __fastcall pwr_utils_vlvl_named_resource(__int64 a1, int a2)
{
  int v3; // w0

  v3 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_vlvl(v3, a2);
}



      qtisec_assert(
        "noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c",
        0x307u,
        "0 == Clock_InitImage(&ClockDrvCtxt)");
    result = 1LL;
    byte_1A500 = 1;
  }
  return result;
}



__int64 __fastcall qtisec_free(__int64 a1)
{
  return mem_free((__int64)atfHeapDesc, &mem_magic_number, a1);
}




unsigned __int64 __fastcall qtiseclib_cpuss_reset_asm(int a1)
{
  if ( !a1 )
  {
    cpuss_aarch64_por_sysini(1LL);
    interconnect_aarch64_sysini(1LL);
  }
  return cluster_aarch64_sysini(1uLL);
}



__int64 __fastcall qtiseclib_invoke_isr(__int64 a1, __int64 a2)
{
  unsigned int v3; // w23
  char v4; // w20
  __int64 v5; // x1
  __int64 v6; // x21
  __int64 v7; // x19
  __int64 (__fastcall *v8)(_QWORD, __int64, __int64); // x20
  __int64 result; // x0
  __int64 v10; // x20
  _DWORD *v11; // x0
  _DWORD *v12; // x19

  v3 = a1;
  v4 = qtiseclib_cb_plat_my_core_pos(a1);
  qtiseclib_cb_spin_lock(&g_int_svc_fiq_lock);
  v5 = 0LL;
  while ( 1 )
  {
    v6 = (unsigned int)v5;
    if ( g_isrs[34 * v5] == v3 )
      break;
    if ( ++v5 == 32 )
    {
      v6 = 32LL;
      v7 = 0LL;
      v8 = 0LL;
      goto LABEL_5;
    }
  }
  v10 = v4 & 7;
  v11 = &g_isrs[34 * (unsigned int)v5 + 8 + v10];
  ++v11[2];
  v12 = &g_isrs[34 * (unsigned int)v5];
  *(_QWORD *)&g_isrs[34 * (unsigned int)v5 + 18 + 2 * v10] = timer_qtimer_read_time_raw();
  v8 = (__int64 (__fastcall *)(_QWORD, __int64, __int64))*((_QWORD *)v12 + 3);
  v7 = *((_QWORD *)v12 + 4);
LABEL_5:
  result = qtiseclib_cb_spin_unlock(&g_int_svc_fiq_lock);
  if ( v8 )
  {
    result = v8(v3, a2, v7);
    *(_QWORD *)&g_isrs[34 * v6 + 8] = result;
  }
  return result;
}



__int64 qtiseclib_is_debug_enabled_secure_io_access()
{
  return 0LL;
}



__int64 qtiseclib_kryo6_gold_reset_asm()
{
  return cpu_aarch64_sysini(1LL);
}



__int64 qtiseclib_kryo6_silver_reset_asm()
{
  return cpu_aarch64_sysini(1LL);
}



__int64 __fastcall qtiseclib_mem_assign(
        __int64 *a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        int *a5,
        unsigned int a6)
{
  return mem_assign(a1, a2, a3, a4, a5, a6);
}



void __noreturn qtiseclib_panic()
{
  dbg_err_fatal_handler(1u);
}



__int64 __fastcall qtiseclib_psci_init(unsigned __int64 a1)
{
  _QWORD *v1; // x19
  unsigned __int64 v2; // x20
  __int64 result; // x0
  _QWORD *v4; // x22
  __int64 (__fastcall **v5)(_QWORD *); // x0

  v1 = &unk_1CD38;
  set_boot_remap(a1);
  v2 = 0LL;
  pcu_init();
  result = (__int64)&unk_16000;
  while ( v2 < 9 )
  {
    v4 = v1 - 8;
    if ( (unsigned int)pcu_get_node(*((_DWORD *)v1 - 2), v1) )
    {
      qtiseclib_cb_log(10LL, "PSCI: Sequencer query failed (node: %s)", (&g_psci_asic_nodes)[10 * v2]);
      return 4294967290LL;
    }
    v5 = (__int64 (__fastcall **)(_QWORD *))*(v1 - 7);
    v1 += 10;
    result = (*v5)(v4);
    if ( (_DWORD)result )
      return result;
    ++v2;
  }
  result = (__int64)&(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(result)];
  do
  {
    *(_DWORD *)(result + 40) &= 0xFFFFFFEE;
    result = *(_QWORD *)(result + 48);
  }
  while ( result );
  return result;
}



char **__fastcall qtiseclib_psci_node_on_finish(__int64 a1)
{
  char **result; // x0
  __int64 i; // x1
  bool v4; // zf
  int j; // w19
  __int64 v6; // x20
  __int64 (__fastcall *v7)(__int64, __int64); // x2
  unsigned int v8; // w0
  __int64 v9[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v9, 0, sizeof(v9));
  result = &(&g_psci_asic_nodes)[10 * (int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = (int)i > 7 || result == 0LL;
    if ( v4 || !*(_BYTE *)(a1 + i) )
      break;
    v9[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v6 = v9[j];
    v7 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v6 + 8) + 16LL);
    if ( v7 )
    {
      v8 = v7(v9[j], a1);
      if ( v8 )
        qtiseclib_cb_log(10LL, "PSCI_PLAT: Node on finish (%s, %d)", *(const char **)v6, v8);
    }
    result = (char **)(*(_DWORD *)(v6 + 40) & 0xFFFFFFFE);
    *(_DWORD *)(v6 + 40) = (_DWORD)result;
  }
  return result;
}



char **__fastcall qtiseclib_psci_node_power_off(__int64 a1)
{
  return qtisec_psci_node_down(a1, 2u);
}



__int64 __fastcall qtiseclib_psci_node_power_on(__int64 a1)
{
  char **v2; // x0
  __int64 i; // x1
  int v4; // w19
  bool v5; // cc
  __int64 v6; // x20
  __int64 (__fastcall *v7)(__int64, __int64); // x2
  unsigned int v8; // w0
  unsigned int v9; // w21
  __int64 v11[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v11, 0, sizeof(v11));
  v2 = &(&g_psci_asic_nodes)[10 * (int)qtiseclib_cb_plat_core_pos_by_mpidr(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = i;
    v5 = v2 && (int)i <= 7;
    if ( !v5 || ((_DWORD)v2[5] & 0x10) == 0 )
      break;
    v11[i] = (__int64)v2;
    v2 = (char **)v2[6];
  }
  while ( 1 )
  {
    if ( --v4 == -1 )
      return 0;
    v6 = v11[v4];
    v7 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v6 + 8) + 8LL);
    if ( v7 )
    {
      v8 = v7(v11[v4], a1);
      v9 = v8;
      if ( v8 )
        break;
    }
    *(_DWORD *)(v6 + 40) &= ~0x10u;
  }
  qtiseclib_cb_log(10LL, "PSCI_PLAT: Node on (%s, %d)", *(const char **)v6, v8);
  return v9;
}



char **__fastcall qtiseclib_psci_node_suspend(__int64 a1)
{
  return qtisec_psci_node_down(a1, 1u);
}



char **__fastcall qtiseclib_psci_node_suspend_finish(__int64 a1)
{
  char **result; // x0
  __int64 i; // x1
  bool v4; // zf
  int j; // w19
  __int64 v6; // x21
  __int64 v7[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v7, 0, sizeof(v7));
  result = &(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = (int)i > 7 || result == 0LL;
    if ( v4 || !*(_BYTE *)(a1 + i) )
      break;
    v7[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v6 = v7[j];
    result = (char **)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(v6 + 8) + 32LL))(v6, a1, 1LL);
    if ( (_DWORD)result )
      result = (char **)qtiseclib_cb_log(
                          30LL,
                          "PSCI PLAT: Suspend finish (%s, %d)",
                          *(const char **)v6,
                          (unsigned int)result);
  }
  return result;
}



void __noreturn qtiseclib_psci_system_off()
{
  pm_app_ps_hold_cfg(2u);
  MEMORY[0xC264000] = 0;
  while ( 1 )
    ;
}



void __noreturn qtiseclib_psci_system_reset()
{
  pm_app_ps_hold_cfg(0);
  MEMORY[0xC264000] = 0;
  while ( 1 )
    ;
}



    if ( *a2 || (*a3 = v8, v11 = qtisec_malloc(4LL * (v8 & 0x3FFFFFFF)), (*a2 = v11) != 0) )
    {
      if ( v8 <= *a3 )
      {
        v12 = (_DWORD *)*a2;
        for ( i = *(_QWORD *)(v5 + 24); *(_DWORD *)i; i += 24LL )
        {
          if ( (*(_DWORD *)(v5 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(i + 14) != 255 )
            *v12++ = *(_DWORD *)i;
        }
        *a3 = v8;
        return 0LL;
      }
      *a3 = v8;
    }
    else
    {
      *a3 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}



char **__fastcall qtisec_psci_node_down(__int64 a1, unsigned int a2)
{
  char **result; // x0
  __int64 i; // x1
  bool v6; // zf
  int j; // w19
  __int64 v8; // x22
  __int64 v9[8]; // [xsp+40h] [xbp+40h] BYREF

  memset(v9, 0, sizeof(v9));
  result = &(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v6 = (int)i > 7 || result == 0LL;
    if ( v6 || !*(_BYTE *)(a1 + i) )
      break;
    if ( a2 == 2 )
      *((_DWORD *)result + 10) |= 0x10u;
    v9[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v8 = v9[j];
    result = (char **)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(v8 + 8) + 24LL))(v8, a1, a2);
    if ( (_DWORD)result )
      result = (char **)qtiseclib_cb_log(
                          30LL,
                          "PSCI PLAT: Node down (%s, %d, %d)",
                          *(const char **)v8,
                          (unsigned int)result,
                          a2);
  }
  return result;
}



unsigned __int64 __fastcall qtisec_realloc(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x19
  bool v5; // zf

  if ( !heapHasInit )
  {
    qtiseclib_cb_log(10LL, "Heap un-initialized !");
    return 0LL;
  }
  if ( a2 > 0xFFFF )
  {
    qtiseclib_cb_log(10LL, "Heap length 0x%x not supported !", a2);
    return 0LL;
  }
  v3 = mem_realloc((__int64)atfHeapDesc, &mem_magic_number, a1, a2);
  v5 = a2 == 0;
  v4 = v3;
  v5 = !v5 && v3 == 0;
  if ( v5 )
    qtiseclib_cb_log(10LL, "Heap Exhausted !");
  return v4;
}



unsigned __int64 __fastcall resource_command_sets_dirty(__int64 a1, int a2)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x2

  result = rpmh_resource_command_get_voter(a1, a2);
  if ( !result )
    return 0LL;
  v3 = result;
  LODWORD(result) = 2 * (*(_DWORD *)(result + 44) >= 2u);
  if ( *(_DWORD *)(v3 + 56) < 2u )
    return (unsigned int)result;
  else
    return (unsigned int)result | 4;
}






__int64 __fastcall rpmh_churn_all(__int64 a1, unsigned int a2)
{
  return rpmh_wait_for_cmd_constprop_5(a1, a2, 1u, 1u);
}



__int64 __fastcall rpmh_churn_single(__int64 a1, unsigned int a2)
{
  return rpmh_wait_for_cmd_constprop_5(a1, a2, 0, 1u);
}



__int64 __fastcall rpmh_clean_cmd(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // x19

  v2 = a1 + 1;
  qtiseclib_cb_memset(*a1, 0LL, 8LL * a2);
  return qtiseclib_cb_memset(v2, 0LL, 40LL);
}



__int64 __fastcall rpmh_client_command_add(__int64 a1)
{
  _DWORD *v2; // x20
  int v3; // w0
  unsigned int v4; // w1
  __int64 result; // x0

  v2 = (_DWORD *)inq_pop(*(unsigned int **)(a1 + 24));
  if ( !v2 )
  {
    v2 = (_DWORD *)rpmh_malloc(0x18u);
    rpmh_core_verify_ptr((__int64)v2);
    qtiseclib_cb_memset(v2, 0LL, 24LL);
  }
  v3 = *(_DWORD *)(a1 + 48) + 1;
  *(_DWORD *)(a1 + 48) = v3;
  *v2 = v3;
  inq_append(*(unsigned int **)(a1 + 16), (__int64)v2);
  v4 = *(_DWORD *)(a1 + 52);
  ++*(_DWORD *)(a1 + 56);
  LODWORD(result) = *(_DWORD *)(a1 + 48);
  if ( (unsigned int)result > v4 )
    result = v4;
  else
    result = (unsigned int)result;
  *(_DWORD *)(a1 + 52) = result;
  return result;
}



__int64 __fastcall rpmh_client_command_finish(__int64 a1, int a2)
{
  __int64 v4; // x0
  __int64 result; // x0
  __int64 v6; // [xsp+28h] [xbp+28h] BYREF

  v4 = *(_QWORD *)(a1 + 16);
  v6 = 0LL;
  result = (__int64)get_cmd_in_progress_isra_1_constprop_3(v4, &v6, a2);
  if ( (_BYTE)result )
  {
    result = *(unsigned __int8 *)(v6 + 8);
    if ( !*(_BYTE *)(v6 + 8) )
    {
      rpmh_client_command_remove(a1, a2);
      return check_for_events(a1, a2);
    }
  }
  return result;
}



__int64 __fastcall rpmh_client_command_remove(__int64 a1, int a2)
{
  _DWORD *v4; // x20
  int *v5; // x0
  int v6; // w0
  __int64 result; // x0
  unsigned int *v8[3]; // [xsp+38h] [xbp+38h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 16), v8);
  while ( 1 )
  {
    v4 = (_DWORD *)inq_it_deref((__int64)v8);
    if ( !v4 )
      rpmh_err_fatal("Inconsistent client cmds_in_progress state.");
    if ( a2 == *v4 )
      break;
    inq_it_next(v8);
  }
  inq_it_delete(v8);
  qtiseclib_cb_memset(v4, 0LL, 24LL);
  inq_append(*(unsigned int **)(a1 + 24), (__int64)v4);
  v5 = (int *)inq_head(*(_QWORD *)(a1 + 16));
  if ( v5 )
    v6 = *v5;
  else
    v6 = -1;
  *(_DWORD *)(a1 + 52) = v6;
  result = (unsigned int)(*(_DWORD *)(a1 + 56) - 1);
  *(_DWORD *)(a1 + 56) = result;
  return result;
}



__int64 __fastcall rpmh_client_handle_add(unsigned int **a1)
{
  __int64 v2; // x0
  __int64 v3; // x19

  v2 = inq_pop(a1[1]);
  if ( v2 )
  {
    v3 = v2;
    inq_append(*a1, v2);
  }
  else
  {
    v3 = rpmh_malloc(0x50u);
    rpmh_core_verify_ptr(v3);
    qtiseclib_cb_memset(v3, 0LL, 80LL);
    *(_DWORD *)(v3 + 52) = -1;
    inq_append(*a1, v3);
    *(_QWORD *)(v3 + 32) = inq_create(24);
    *(_QWORD *)(v3 + 40) = inq_create(24);
    *(_QWORD *)(v3 + 16) = inq_create(16);
    *(_QWORD *)(v3 + 24) = inq_create(16);
  }
  return v3;
}



void rpmh_client_init()
{
  __int64 v0; // x21
  char *v1; // x28
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x24
  char *v5; // x27
  __int64 *v6; // x20
  __int64 v7; // x22

  if ( LODWORD(rpmh[0]) != 1 )
  {
    LODWORD(rpmh[0]) = 1;
    LOBYTE(qtiseclib_cb_memcpy) = RPMH_STANDALONE;
    rpmh_os_init();
    rpmh_core_verify(1LL);
    if ( !(_BYTE)qtiseclib_cb_memcpy )
      tcs_init();
    v0 = 0LL;
    qtiseclib_cb_memset = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))rpmh_malloc(8u);
    while ( !(_DWORD)v0 )
    {
      v1 = (char *)&_compound_literal_1_2 + 48 * v0;
      v2 = *((unsigned int *)v1 + 2);
      if ( (_DWORD)v2 )
        rpmh_register_isr(v2, (__int64)rpmh_finish_amc, *((unsigned int *)&_compound_literal_1_2 + 12 * v0), 0);
      v3 = *((unsigned int *)v1 + 3);
      if ( (_DWORD)v3 )
        rpmh_register_isr(v3, (__int64)rpmh_epcb_timeout, *((unsigned int *)&_compound_literal_1_2 + 12 * v0), 1);
      v4 = 8 * v0++;
      v5 = (char *)qtiseclib_cb_memset;
      *(_QWORD *)&v5[v4] = rpmh_cmdq_create(0);
    }
    rpmh[4] = rpmh_clientq_create();
    rpmh_core_verify(1LL);
    if ( !HIDWORD(rpmh[0]) && !LOBYTE(rpmh[5]) )
    {
      v6 = (__int64 *)(MEMORY[0xC3F0000] + 204472320LL);
      do
      {
        v7 = *v6;
        qtiseclib_cb_udelay(1LL);
        ++LODWORD(rpmh[1]);
      }
      while ( (_DWORD)v7 != -1598026722 );
      HIDWORD(rpmh[0]) = 1;
    }
    rpmh_core_verify(1LL);
    rpmh_core_verify(1LL);
  }
}




__int64 __fastcall rpmh_client_wait_on_cmd(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v6; // x0
  int v8; // w20
  __int64 result; // x0
  __int64 v10; // x20
  __int64 v11; // x22
  unsigned int *v12; // x0
  __int64 v13; // [xsp+48h] [xbp+48h] BYREF

  v6 = *(_QWORD *)(a1 + 16);
  v13 = 0LL;
  v8 = a4;
  result = (__int64)get_cmd_in_progress_isra_1_constprop_3(v6, &v13, a2);
  if ( (_BYTE)result || a3 == 1 && (result = *(unsigned int *)(a1 + 52), a2 > (unsigned int)result) )
  {
    if ( v8 )
    {
      while ( !is_amc_finished(*(_DWORD *)a1) )
        ;
      rpmh_finish_amc_internal(*(_DWORD *)a1, 0);
      return rpmh_client_wait_on_cmd(a1, a2, a3, 1LL);
    }
    else
    {
      v10 = inq_pop(*(unsigned int **)(a1 + 40));
      if ( !v10 )
      {
        v10 = rpmh_malloc(0x20u);
        rpmh_core_verify_ptr(v10);
        qtiseclib_cb_memset(v10, 0LL, 32LL);
      }
      v11 = rpmh_event_create();
      v12 = *(unsigned int **)(a1 + 32);
      *(_DWORD *)v10 = a2;
      *(_QWORD *)(v10 + 8) = v11;
      *(_DWORD *)(v10 + 16) = a3;
      inq_append(v12, v10);
      rpmh_unlock();
      rpmh_event_wait(v11);
      rpmh_lock();
      return rpmh_event_destroy(v11);
    }
  }
  return result;
}




__int64 __fastcall rpmh_clz(int a1)
{
  __int64 result; // x0

  result = 0LL;
  do
  {
    if ( (a1 & 0x80000000) != 0 )
      break;
    result = (unsigned int)(result + 1);
    a1 *= 2;
  }
  while ( (_DWORD)result != 32 );
  return result;
}



__int64 __fastcall rpmh_cmdq_create(unsigned int a1)
{
  char *v1; // x20
  __int64 v2; // x19

  v1 = (char *)&_compound_literal_1_2 + 48 * a1;
  v2 = rpmh_malloc(0x20u);
  rpmh_core_verify_ptr(v2);
  qtiseclib_cb_memset(v2, 0LL, 32LL);
  *(_DWORD *)v2 = *((_DWORD *)v1 + 7);
  *(_QWORD *)(v2 + 8) = inq_create(40);
  *(_QWORD *)(v2 + 16) = inq_create(40);
  *(_QWORD *)(v2 + 24) = inq_create(40);
  return v2;
}



__int64 __fastcall rpmh_cmdq_send_cmd_at_head(__int64 a1)
{
  __int64 v2; // x0
  unsigned int v3; // w21
  __int64 v4; // x19
  __int64 v5; // x21
  int v6; // w22
  unsigned int *resource_command; // x23
  __int64 voter; // x23
  unsigned __int8 v9; // w0
  unsigned int *v11[3]; // [xsp+48h] [xbp+48h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 16), v11);
  v2 = inq_it_deref((__int64)v11);
  if ( !v2 )
    return 0;
  v4 = v2;
  v5 = 0LL;
  v6 = 1;
  rpmh_core_verify(*(_DWORD *)(v2 + 8) <= *(_DWORD *)a1);
  while ( *(_DWORD *)(v4 + 8) > (unsigned int)v5 )
  {
    resource_command = rpmh_find_resource_command(*(_DWORD *)(*(_QWORD *)v4 + 8 * v5));
    rpmh_core_verify_ptr((__int64)resource_command);
    if ( !cmdq_empty(a1) )
    {
      voter = rpmh_resource_command_get_voter((__int64)resource_command, **(_DWORD **)(v4 + 16));
      rpmh_core_verify_ptr(voter);
      if ( *(_DWORD *)(voter + 4) || *(_DWORD *)(*(_QWORD *)v4 + 4LL) == 2 && (unsigned int)cmdq_num_in_flight(a1) )
        v6 = 0;
    }
    ++v5;
  }
  if ( v6 && (v9 = tcs_send(v4, **(_DWORD **)(v4 + 16)), (v3 = v9) != 0) )
  {
    inq_it_delete(v11);
    inq_append(*(unsigned int **)(a1 + 8), v4);
  }
  else
  {
    return 0;
  }
  return v3;
}



__int64 __fastcall rpmh_cmdq_send_cmd_set(unsigned int *a1, int *a2, _DWORD *a3)
{
  __int64 v6; // x19
  __int64 v7; // x0
  unsigned int v8; // w0
  int v9; // w1
  unsigned int *v10; // x24
  __int64 v11; // x23
  int v12; // w25
  unsigned int v13; // w0
  unsigned int v14; // w26
  unsigned int v15; // w28
  unsigned int *resource_command; // x27
  unsigned int *v17; // x2
  __int64 voter; // x26
  unsigned int v19; // w22

  v6 = inq_pop(*((unsigned int **)a1 + 3));
  if ( !v6 )
  {
    v6 = rpmh_malloc(0x30u);
    rpmh_core_verify_ptr(v6);
    qtiseclib_cb_memset(v6, 0LL, 48LL);
  }
  if ( !*(_QWORD *)v6 )
  {
    v7 = rpmh_malloc(8 * *a1);
    *(_QWORD *)v6 = v7;
    rpmh_core_verify_ptr(v7);
    qtiseclib_cb_memset(*(_QWORD *)v6, 0LL, 8LL * *a1);
  }
  v8 = a3[1];
  v9 = 0;
  *(_QWORD *)(v6 + 16) = a2;
  *(_DWORD *)(v6 + 8) = v8;
  if ( a2 )
    v9 = a2[12];
  *(_DWORD *)(v6 + 24) = v9;
  v10 = a3 + 3;
  v11 = 0LL;
  v12 = 1;
  *(_DWORD *)(v6 + 12) = a3[2];
  *(_DWORD *)(v6 + 28) = *a3;
  *(_BYTE *)(v6 + 32) = 1;
  rpmh_core_verify(v8 <= *a1);
  rpmh_core_verify(a3[1] <= *a1);
  while ( 1 )
  {
    v13 = *(_DWORD *)(v6 + 8);
    if ( v13 <= (unsigned int)v11 )
      break;
    v14 = *v10;
    v15 = *((unsigned __int8 *)v10 + 8);
    resource_command = rpmh_find_resource_command(*v10);
    rpmh_core_verify_ptr((__int64)resource_command);
    v17 = (unsigned int *)(*(_QWORD *)v6 + 8 * v11);
    v17[1] = v15;
    *v17 = v14;
    if ( a2 )
    {
      voter = rpmh_resource_command_get_voter((__int64)resource_command, *a2);
      rpmh_core_verify_ptr(voter);
      if ( *(_DWORD *)(voter + 4) )
        v12 = 0;
    }
    ++v11;
    v10 += 3;
  }
  rpmh_core_verify(*a1 >= v13);
  if ( *a3 )
  {
    v19 = 0;
    rpmh_core_verify(0LL);
  }
  else
  {
    rpmh_core_verify_ptr((__int64)a2);
    v19 = *(_DWORD *)(v6 + 24);
    if ( v12 && (unsigned __int8)is_amc_free(*a2) )
    {
      inq_append(*((unsigned int **)a1 + 1), v6);
      tcs_send(v6, *a2);
    }
    else
    {
      rpmh_core_verify(1LL);
      inq_append(*((unsigned int **)a1 + 2), v6);
    }
  }
  return v19;
}



__int64 __fastcall rpmh_core_verify(__int64 result)
{
  if ( !(_BYTE)result )
  {
    while ( 1 )
      ;
  }
  return result;
}



__int64 __fastcall rpmh_core_verify_ptr(__int64 result)
{
  if ( !result )
  {
    while ( 1 )
      ;
  }
  return result;
}



__int64 __fastcall rpmh_create_handle(int a1, __int64 a2)
{
  return rpmh_create_handle_internal(a1, a2, 0);
}



__int64 __fastcall rpmh_create_handle_explicit(int a1, __int64 a2)
{
  return rpmh_create_handle_internal(a1, a2, 1u);
}



__int64 __fastcall rpmh_create_handle_internal(int a1, __int64 a2, unsigned __int8 a3)
{
  int v5; // w21
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x19
  __int64 v9; // x0

  v5 = a3;
  rpmh_lock();
  v6 = drv_valid(a1);
  rpmh_core_verify(v6);
  rpmh_core_verify(1LL);
  v7 = rpmh_client_handle_add((unsigned int **)memcpy);
  *(_DWORD *)v7 = a1;
  *(_QWORD *)(v7 + 8) = a2;
  v8 = v7;
  *(_DWORD *)(v7 + 48) = 0;
  if ( v5 )
  {
    v9 = rpmh_malloc(0x10u);
    *(_QWORD *)(v8 + 64) = v9;
    rpmh_core_verify_ptr(v9);
    qtiseclib_cb_memset(*(_QWORD *)(v8 + 64), 0LL, 16LL);
  }
  rpmh_unlock();
  return v8;
}




__int64 __fastcall rpmh_enter_sleep(int a1)
{
  __int64 v3; // x0
  unsigned int v4; // w22
  __int64 v5; // x0
  __int64 v6; // x22
  __int64 v7; // x0
  int *v8; // x24
  __int64 v9; // x21
  int *v10; // x22

  rpmh_lock();
  if ( !(_BYTE)qtiseclib_cb_memcpy )
  {
    v3 = drv_valid(a1);
    rpmh_core_verify(v3);
    v4 = lookup_drv_index(a1);
    rpmh_core_verify(1LL);
    tcs_clean_sleep_wake(a1);
    if ( *((_DWORD *)&_compound_literal_1_2 + 12 * v4 + 2) )
      rpmh_deregister_isr();
    v5 = *((_QWORD *)qtiseclib_cb_memset + v4);
    v6 = 0LL;
    v7 = cmdq_empty(v5);
    rpmh_core_verify(v7);
    add_explicit_cmd_set_for_sleep(1, a1);
    while ( HIDWORD(qtiseclib_cb_ic_raise_sgi) > (unsigned int)v6 )
    {
      v8 = (int *)((char *)qtiseclib_cb_spin_lock + 24 * v6);
      if ( (unsigned int)rpmh_resource_command_get_priority((__int64)v8, a1) == 1 )
        add_rc_for_sleep(v8, a1);
      ++v6;
    }
    v9 = 0LL;
    add_explicit_cmd_set_for_sleep(0, a1);
    while ( HIDWORD(rpmh[1]) > (unsigned int)v9 )
    {
      v10 = (int *)(rpmh[2] + 24 * v9);
      if ( (unsigned int)rpmh_resource_command_get_priority((__int64)v10, a1) != 1 )
        add_rc_for_sleep(v10, a1);
      ++v9;
    }
    tcs_prepare_sleep_commit(a1);
  }
  rpmh_core_verify(1LL);
  return rpmh_unlock();
}



__int64 rpmh_epcb_timeout()
{
  rpmh_core_verify(1LL);
  return rpmh_core_verify(0LL);
}




__int64 __fastcall rpmh_exit_sleep(int a1)
{
  __int64 v2; // x0
  __int64 v4; // x0
  __int64 v5; // x19
  __int64 i; // x20
  __int64 v7; // x0

  rpmh_lock();
  if ( !(_BYTE)qtiseclib_cb_memcpy )
  {
    v4 = drv_valid(a1);
    rpmh_core_verify(v4);
    v5 = 48LL * (unsigned int)lookup_drv_index(a1);
    for ( i = 0LL; HIDWORD(rpmh[1]) > (unsigned int)i; ++i )
    {
      v7 = rpmh[2] + 24 * i;
      rpmh_resource_command_exit_sleep(v7, a1);
    }
    v2 = *(unsigned int *)((char *)&_compound_literal_1_2 + v5 + 8);
    if ( (_DWORD)v2 )
      rpmh_register_isr(v2, (__int64)rpmh_finish_amc, *(unsigned int *)((char *)&_compound_literal_1_2 + v5), 0);
  }
  rpmh_core_verify(1LL);
  return rpmh_unlock();
}



unsigned int *__fastcall rpmh_find_resource_command(unsigned int a1)
{
  unsigned int v2; // w3
  unsigned int v3; // w2
  unsigned int v4; // w4
  unsigned int v6; // w1
  unsigned int *result; // x0

  v2 = HIDWORD(rpmh[1]);
  v3 = v2 - 1;
  if ( v2 )
  {
    v4 = 0;
    while ( v4 <= v3 && v3 < v2 )
    {
      v6 = (v4 + v3) >> 1;
      result = (unsigned int *)(rpmh[2] + 24LL * v6);
      if ( *result >= a1 )
      {
        if ( *result <= a1 )
          return result;
        v3 = v6 - 1;
      }
      else
      {
        v4 = v6 + 1;
      }
    }
  }
  return 0LL;
}



__int64 __fastcall rpmh_finish_amc(int a1)
{
  return rpmh_finish_amc_internal(a1, 1u);
}



__int64 __fastcall rpmh_finish_amc_internal(int a1, unsigned __int8 a2)
{
  int v2; // w21
  int finished_drv; // w20
  __int64 v5; // x0
  __int64 v6; // x22
  int active; // w20
  __int64 result; // x0
  __int64 v9; // [xsp+38h] [xbp+38h] BYREF

  v2 = a2;
  v9 = 0LL;
  if ( a2 )
    rpmh_lock();
  finished_drv = get_finished_drv(a1);
  if ( finished_drv == 0x3FFFFFFF )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    rpmh_core_verify(1LL);
    v5 = drv_valid(finished_drv);
    rpmh_core_verify(v5);
    v6 = 8LL * (unsigned int)lookup_drv_index(finished_drv);
    active = tcs_finish_active_amc(&v9, *(_QWORD *)(rpmh[3] + v6), finished_drv);
    rpmh_core_verify(active != 0);
    rpmh_core_verify(1LL);
    rpmh_client_command_finish(v9, active);
    while ( (unsigned __int8)rpmh_cmdq_send_cmd_at_head(*(_QWORD *)(rpmh[3] + v6)) )
      ;
  }
  result = rpmh_core_verify(1LL);
  if ( v2 )
    return rpmh_unlock();
  return result;
}




      && rpmh_get_timestamp() > (unsigned __int64)(*(_QWORD *)(*(_QWORD *)(rpmh_tcs + v6) + 24 * v1 + 8) + 192000LL) )
    {
      v2 = 1;
      rpmh_core_verify(1LL);
    }
    ++v1;
  }
  return v2;
}



__int64 __fastcall rpmh_get_wake_latency(int a1)
{
  return *((unsigned int *)&_compound_literal_1_2 + 12 * (int)lookup_drv_index(a1) + 4);
}



__int64 __fastcall rpmh_invalidate_explicit_cmds(__int64 a1)
{
  __int64 v2; // x0
  unsigned int v3; // w2

  rpmh_core_verify_ptr(*(_QWORD *)(a1 + 64));
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_DWORD *)(v2 + 4);
  *(_DWORD *)v2 = 0;
  qtiseclib_cb_memset(*(_QWORD *)(v2 + 8), 0LL, 204LL * v3);
  return tcs_clean_sleep_wake(*(_DWORD *)a1);
}




__int64 __fastcall rpmh_issue_command(__int64 a1, int a2, char a3, int a4, int a5)
{
  rpmh_lock();
  set_g_cmd_set_single(a4, a5, a3, a2);
  LODWORD(a1) = rpmh_issue_command_set_internal(a1, (unsigned int *)g_cmd_set, 0);
  rpmh_unlock();
  return (unsigned int)a1;
}



__int64 __fastcall rpmh_issue_command_set(__int64 a1, unsigned int *a2)
{
  return rpmh_issue_command_set_internal(a1, a2, 1u);
}



__int64 __fastcall rpmh_issue_command_set_internal(__int64 a1, unsigned int *a2, unsigned __int8 a3)
{
  int v4; // w23
  unsigned int *v6; // x25
  unsigned int v7; // w24
  unsigned int v8; // w21
  unsigned int v9; // w1
  unsigned int v10; // w0
  int v11; // w21
  __int64 v12; // x26
  int v13; // w2
  unsigned int v14; // t1
  unsigned __int8 v15; // w0
  unsigned int **v16; // x21
  int v17; // w0
  unsigned int v18; // w21
  __int64 v19; // x21
  unsigned int v20; // w1
  unsigned int v21; // w0
  int v23; // [xsp+64h] [xbp+64h]
  unsigned int *rc; // [xsp+68h] [xbp+68h]

  v4 = a3;
  rpmh_is_processing = 1;
  if ( a3 )
    rpmh_lock();
  v6 = a2 + 3;
  v7 = 0;
  v8 = lookup_drv_index(*(_DWORD *)a1);
  rpmh_core_verify(1LL);
  v9 = a2[1];
  v10 = *((_DWORD *)&_compound_literal_1_2 + 12 * v8 + 7);
  v11 = 0;
  a2[2] = 0;
  rpmh_core_verify(v9 <= v10);
  v12 = *(_QWORD *)(a1 + 64);
  while ( a2[1] > v7 )
  {
    v13 = v6[1];
    ++v7;
    v14 = *v6;
    v6 += 3;
    v23 = v13;
    rc = get_rc(v14);
    rpmh_core_verify(1LL);
    if ( rpmh_resource_command_update((__int64)rc, *a2, v23, *(_DWORD *)a1, v12 != 0) )
      v11 = 1;
  }
  if ( *a2 )
  {
    v18 = 0;
    if ( !v12 )
      goto LABEL_19;
    v19 = *(_QWORD *)(a1 + 64);
    v20 = *(_DWORD *)(v19 + 4);
    v21 = *(_DWORD *)v19 + 1;
    *(_DWORD *)v19 = v21;
    if ( v21 > v20 )
    {
      *(_QWORD *)(v19 + 8) = rpmh_realloc(*(_QWORD *)(v19 + 8), 204 * v21);
      *(_DWORD *)(v19 + 4) = *(_DWORD *)v19;
    }
    qtiseclib_cb_memcpy(*(_QWORD *)(v19 + 8) + 204LL * (unsigned int)(*(_DWORD *)v19 - 1), a2, 204LL);
    add_explicit_cmd_set_for_sleep(1, *(_DWORD *)a1);
    add_explicit_cmd_set_for_sleep(0, *(_DWORD *)a1);
    tcs_prepare_sleep_commit(*(_DWORD *)a1);
    goto LABEL_18;
  }
  if ( !v11 || LOBYTE(rpmh[5]) )
  {
    rpmh_core_verify(1LL);
LABEL_18:
    v18 = 0;
    goto LABEL_19;
  }
  v15 = is_tcs_stuck(*(_DWORD *)a1);
  rpmh_core_verify(v15 ^ 1u);
  rpmh_client_command_add(a1);
  while ( a2[1] > 0x10 )
    ;
  v16 = (unsigned int **)qtiseclib_cb_memset;
  v17 = lookup_drv_index(*(_DWORD *)a1);
  v18 = rpmh_cmdq_send_cmd_set(v16[v17], (int *)a1, a2);
  rpmh_core_verify(1LL);
LABEL_19:
  if ( v4 )
    rpmh_unlock();
  rpmh_wait_for_cmd_constprop_5(a1, v18, 1u, v4);
  rpmh_is_processing = 0;
  return v18;
}



__int64 rpmh_lock()
{
  return qtiseclib_cb_spin_lock(&rpmh_os);
}



unsigned __int64 __fastcall rpmh_malloc(unsigned int a1)
{
  return qtisec_malloc(a1);
}




unsigned __int64 __fastcall rpmh_realloc(__int64 a1, unsigned int a2)
{
  return qtisec_realloc(a1, a2);
}



void *__fastcall rpmh_register_isr(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  void *result; // x0

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      result = &unk_31000;
      tz_timeout_cb = a2;
    }
  }
  else
  {
    result = &unk_31000;
    tz_completion_cb = a2;
  }
  return result;
}



__int64 __fastcall rpmh_resource_command_exit_sleep(__int64 a1, int a2)
{
  __int64 voter; // x0
  int v3; // w4
  int v4; // w3

  voter = rpmh_resource_command_get_voter(a1, a2);
  if ( voter && *(_BYTE *)(voter + 52) )
  {
    v3 = *(_DWORD *)(voter + 56);
    v4 = *(_DWORD *)(voter + 48);
    *(_BYTE *)(voter + 28) = 1;
    *(_DWORD *)(voter + 24) = v4;
    if ( v3 != 1 )
    {
      *(_BYTE *)(voter + 52) = 0;
      *(_DWORD *)(voter + 48) = 0;
    }
    *(_BYTE *)(voter + 16) = 1;
    *(_DWORD *)(voter + 12) = v4;
  }
  return resource_command_dirty_update_isra_0(voter);
}



__int64 __fastcall rpmh_resource_command_finish(unsigned int a1, int a2)
{
  unsigned int *resource_command; // x19
  __int64 voter; // x19

  resource_command = rpmh_find_resource_command(a1);
  rpmh_core_verify_ptr((__int64)resource_command);
  voter = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  rpmh_core_verify_ptr(voter);
  *(_DWORD *)(voter + 4) = 0;
  return resource_command_dirty_update_isra_0(voter);
}



__int64 __fastcall rpmh_resource_command_get_priority(__int64 a1, int a2)
{
  return *(unsigned int *)(rpmh_resource_command_get_voter(a1, a2) + 8);
}



unsigned __int64 __fastcall rpmh_resource_command_get_voter(__int64 a1, int a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  unsigned int v6; // w0

  v2 = *(_QWORD *)(a1 + 8);
  v3 = 0LL;
  while ( v2 )
  {
    if ( *(_DWORD *)v2 == a2 )
      return v2;
    v3 = v2;
    v2 = *(_QWORD *)(v2 + 64);
  }
  v2 = rpmh_malloc(0x48u);
  qtiseclib_cb_memset(v2, 0LL, 72LL);
  *(_DWORD *)v2 = a2;
  v6 = lookup_drv_index(a2);
  *(_DWORD *)(v2 + 8) = cmd_db_query_priority(*(_DWORD *)a1, *((_BYTE *)&_compound_literal_1_2 + 48 * v6 + 4));
  if ( *(_QWORD *)(a1 + 8) )
  {
    rpmh_core_verify_ptr(v3);
    *(_QWORD *)(v3 + 64) = v2;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = v2;
  }
  return v2;
}



__int64 __fastcall rpmh_resource_command_init(_DWORD *a1, int a2)
{
  __int64 result; // x0

  result = qtiseclib_cb_memset(a1, 0LL, 24LL);
  *a1 = a2;
  return result;
}



    if ( rpmh_resource_command_update((__int64)rc, *a2, v23, *(_DWORD *)a1, v12 != 0) )
      v11 = 1;
  }
  if ( *a2 )
  {
    v18 = 0;
    if ( !v12 )
      goto LABEL_19;
    v19 = *(_QWORD *)(a1 + 64);
    v20 = *(_DWORD *)(v19 + 4);
    v21 = *(_DWORD *)v19 + 1;
    *(_DWORD *)v19 = v21;
    if ( v21 > v20 )
    {
      *(_QWORD *)(v19 + 8) = rpmh_realloc(*(_QWORD *)(v19 + 8), 204 * v21);
      *(_DWORD *)(v19 + 4) = *(_DWORD *)v19;
    }
    qtiseclib_cb_memcpy(*(_QWORD *)(v19 + 8) + 204LL * (unsigned int)(*(_DWORD *)v19 - 1), a2, 204LL);
    add_explicit_cmd_set_for_sleep(1, *(_DWORD *)a1);
    add_explicit_cmd_set_for_sleep(0, *(_DWORD *)a1);
    tcs_prepare_sleep_commit(*(_DWORD *)a1);
    goto LABEL_18;
  }
  if ( !v11 || LOBYTE(rpmh[5]) )
  {
    rpmh_core_verify(1LL);
LABEL_18:
    v18 = 0;
    goto LABEL_19;
  }
  v15 = is_tcs_stuck(*(_DWORD *)a1);
  rpmh_core_verify(v15 ^ 1u);
  rpmh_client_command_add(a1);
  while ( a2[1] > 0x10 )
    ;
  v16 = (unsigned int **)qtiseclib_cb_memset;
  v17 = lookup_drv_index(*(_DWORD *)a1);
  v18 = rpmh_cmdq_send_cmd_set(v16[v17], (int *)a1, a2);
  rpmh_core_verify(1LL);
LABEL_19:
  if ( v4 )
    rpmh_unlock();
  rpmh_wait_for_cmd_constprop_5(a1, v18, 1u, v4);
  rpmh_is_processing = 0;
  return v18;
}



__int64 __fastcall rpmh_resource_command_val_at_rpmh(unsigned int a1, int a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v4; // x19
  int v5; // w22
  unsigned int *resource_command; // x21
  __int64 voter; // x20
  unsigned __int64 v9; // x0
  unsigned __int64 v10; // x21
  unsigned __int64 v11; // x19
  unsigned int v12; // w0
  unsigned int v13; // w19
  __int64 v14; // x0

  v4 = a3;
  v5 = a4;
  resource_command = rpmh_find_resource_command(a1);
  rpmh_core_verify_ptr((__int64)resource_command);
  voter = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  rpmh_core_verify_ptr(voter);
  rpmh_core_verify(*(_DWORD *)(voter + 4) == 0);
  v9 = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  if ( v9 )
  {
    v10 = v9;
    v11 = v9 + 12 * v4;
    v12 = *(_DWORD *)(v11 + 32);
    if ( v12 <= 2 )
    {
      rpmh_core_verify(*(unsigned __int8 *)(v11 + 28));
      v13 = *(_DWORD *)(v11 + 24);
      goto LABEL_6;
    }
    if ( v12 == 4 )
    {
      rpmh_core_verify(*(unsigned __int8 *)(v10 + 28));
      v13 = *(_DWORD *)(v10 + 24);
LABEL_6:
      v14 = 1LL;
      goto LABEL_9;
    }
    rpmh_core_verify(0LL);
  }
  v13 = 0;
  v14 = 0LL;
LABEL_9:
  rpmh_core_verify(v14);
  *(_DWORD *)(voter + 12) = v13;
  *(_BYTE *)(voter + 16) = 1;
  if ( v5 )
    *(_DWORD *)(voter + 4) = 1;
  return v13;
}



__int64 rpmh_unlock()
{
  return qtiseclib_cb_spin_unlock(&rpmh_os);
}



__int64 __fastcall rsc_conf_hidden_tcs_ownership(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 2LL;
  v2 = *(_QWORD *)(a1 + 40);
  result = 2LL;
  if ( v2 )
  {
    rsc_hal_conf_hidden_tcs_owner(v2, a2);
    return 0LL;
  }
  return result;
}



__int64 __fastcall rsc_copy_cmd_seqs(__int64 a1)
{
  __int64 v2; // x23
  __int64 (__fastcall *v3)(__int64, unsigned __int16, __int64, unsigned int); // x20
  unsigned int i; // w21
  __int64 v5; // x1
  __int64 v6; // x22
  __int16 v7; // w0
  __int16 v8; // w1
  unsigned int v9; // w13
  __int64 v10; // x9
  __int64 v11; // x12
  __int64 v12; // x11
  unsigned __int16 v13; // w0
  unsigned int v14; // w10
  __int64 v15; // x15
  __int16 v16; // w14
  __int64 v17; // x11

  v2 = *(_QWORD *)(a1 + 40);
  if ( *(_BYTE *)(a1 + 1) == 8 )
    v3 = rsc_hal_copy_simple_cmd_seq;
  else
    v3 = rsc_hal_copy_extended_cmd_seq;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_DWORD *)(a1 + 16) )
    {
      v9 = 0;
      goto LABEL_15;
    }
    v5 = *(_QWORD *)(a1 + 8);
    v6 = v5 + 240LL * i;
    if ( *(_WORD *)(v6 + 8) )
      break;
LABEL_12:
    ;
  }
  v7 = ((__int64 (__fastcall *)(__int64, _QWORD, _QWORD))v3)(
         v2,
         *(unsigned __int16 *)(a1 + 56),
         *(_QWORD *)(v5 + 240LL * i));
  if ( v7 )
  {
    v8 = *(_WORD *)(a1 + 56);
    if ( *(_BYTE *)(a1 + 1) == 8 )
      *(_WORD *)(v6 + 18) = v8;
    else
      *(_WORD *)(v6 + 18) = 2 * (v8 & 0x7FFF);
    *(_WORD *)(a1 + 56) = v7 + v8;
    goto LABEL_12;
  }
  v9 = 3;
LABEL_15:
  v10 = 0LL;
  v11 = 240LL * *(unsigned int *)(a1 + 16);
  while ( v11 != v10 )
  {
    v12 = *(_QWORD *)(a1 + 8) + v10;
    if ( *(_BYTE *)(v12 + 20) || !*(_WORD *)(v12 + 8) )
    {
      v13 = rsc_mode_index(a1, *(_BYTE *)(v12 + 21));
      *(_WORD *)(v17 + 18) = v16 + *(_WORD *)(v15 + v13 * (unsigned __int64)v14 + 18);
    }
    v10 += 240LL;
  }
  return v9;
}




__int64 __fastcall rsc_enable_ts_events(__int64 a1, char a2)
{
  int i; // w19

  for ( i = 0; i != 4; ++i )
  {
    rsc_hal_enable_ts_unit(*(_QWORD *)(a1 + 40), i, a2);
    if ( !*(_BYTE *)(a1 + 88) )
      rsc_hal_get_ts_unit_h(*(_QWORD *)(a1 + 40), i);
  }
  return 0LL;
}



__int64 __fastcall rsc_get_count(unsigned __int8 a1)
{
  int v1; // w4
  unsigned int v2; // w1
  __int64 result; // x0
  __int64 v4; // x6

  v1 = a1;
  v2 = 0;
  result = 0LL;
  while ( g_rsc_count > (unsigned __int64)v2 )
  {
    v4 = 96LL * v2++;
    if ( *(unsigned __int8 *)(g_rscs + v4) == v1 )
      result = (unsigned int)(result + 1);
    else
      result = (unsigned int)result;
  }
  return result;
}



__int64 __fastcall rsc_get_handles(char a1, int a2, __int64 a3)
{
  bool v3; // zf
  unsigned int v5; // w1
  unsigned __int64 v6; // x5
  _BYTE *v7; // x8
  __int64 result; // x0

  if ( a2 )
    v3 = a3 == 0;
  else
    v3 = 1;
  if ( v3 || a1 != 0 )
    return 0LL;
  v5 = 0;
  v6 = g_rsc_count;
  result = 0LL;
  while ( v6 > v5 )
  {
    v7 = (_BYTE *)(g_rscs + 96LL * v5);
    if ( !*v7 )
    {
      *(_QWORD *)(a3 + 8LL * (unsigned int)result) = v7;
      result = (unsigned int)(result + 1);
    }
    ++v5;
  }
  return result;
}



__int64 __fastcall rsc_get_time_stamp(__int64 a1, unsigned __int8 a2)
{
  unsigned int v3; // w0
  unsigned int v4; // w3
  __int64 v5; // x0

  if ( !a1 || !*(_QWORD *)(a1 + 40) || !*(_BYTE *)(a1 + 88) )
    return 2LL;
  v3 = rsc_mode_index(a1, a2);
  v4 = 4;
  if ( v3 != 4 )
  {
    v4 = -1;
    v5 = *(_QWORD *)(a1 + 8) + 240LL * v3;
    ++*(_WORD *)(v5 + 232);
  }
  return v4;
}



__int64 __fastcall RscHalCheckAMCFinishedIRQ(unsigned int a1, int *a2)
{
  unsigned int v4; // w20
  _BYTE *v5; // x19
  int v6; // w1
  __int64 v7; // x0
  int v8; // w0

  if ( !a2 )
    return 4294967291LL;
  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
    return v4;
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    v6 = *((_DWORD *)v5 + 6);
    v7 = *((_QWORD *)v5 + 2);
    if ( !v6 )
    {
      v8 = *(_DWORD *)(v7 + 3332) & 0xF;
      goto LABEL_7;
    }
    if ( v6 == 2 )
    {
      v8 = (unsigned __int8)*(_DWORD *)(v7 + 134404);
LABEL_7:
      *a2 = v8;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalCheckTCSCmdCompletionStatus(
        unsigned int a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        _BYTE *a4)
{
  unsigned int v4; // w20
  _DWORD *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  unsigned int v10; // w21
  int v11; // w1

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = v5[8];
  if ( v6 && v6 > v4 )
  {
    v8 = v5[9];
    if ( v8 && v8 > a3 )
    {
      v7 = -5;
      if ( a4 )
      {
        v10 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v10 )
        {
          rpmh_core_verify(1LL);
          return v10;
        }
        else
        {
          v11 = v5[6];
          if ( v11 && v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          else
          {
            *a4 = 0;
            return 0;
          }
        }
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}



__int64 __fastcall RscHalCheckTCSCmdIssueStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4)
{
  unsigned int v4; // w20
  _DWORD *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  unsigned int v10; // w21
  int v11; // w1

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = v5[8];
  if ( v6 && v6 > v4 )
  {
    v8 = v5[9];
    if ( v8 && v8 > a3 )
    {
      v7 = -5;
      if ( a4 )
      {
        v10 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v10 )
        {
          rpmh_core_verify(1LL);
          return v10;
        }
        else
        {
          v11 = v5[6];
          if ( v11 && v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          else
          {
            *a4 = 0;
            return 0;
          }
        }
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}



__int64 __fastcall RscHalCheckTCSCmdTriggerStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4)
{
  unsigned int v4; // w20
  _BYTE *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  int v9; // w19
  unsigned int v11; // w21
  int v12; // w1
  __int64 v13; // x0
  __int64 v14; // x3
  __int64 v15; // x0
  int v16; // w0

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = *((_DWORD *)v5 + 8);
  if ( v6 && v6 > v4 )
  {
    v8 = *((_DWORD *)v5 + 9);
    if ( v8 && (v9 = a3, v8 > a3) )
    {
      v7 = -5;
      if ( a4 )
      {
        v11 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v11 )
        {
          rpmh_core_verify(1LL);
          return v11;
        }
        v12 = *((_DWORD *)v5 + 6);
        v13 = *((_QWORD *)v5 + 2);
        v14 = v13 + 3388;
        v15 = v13 + 134460;
        if ( v12 )
        {
          if ( v12 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          v16 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v15);
        }
        else
        {
          v16 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v14);
        }
        v7 = 0;
        *a4 = v16 & 1;
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}



__int64 __fastcall RscHalCheckTCSIdle_HLOS(unsigned int a1)
{
  unsigned int v1; // w19
  unsigned int i; // w0
  unsigned int j; // w0
  unsigned int k; // w0

  v1 = a1;
  if ( !numTcsPerHLOSDrv )
  {
    if ( (unsigned int)rscHalGetNumTcs(0x18200000uLL, a1, &numTcsPerHLOSDrv) )
    {
      rpmh_core_verify(1LL);
      rpmh_core_verify(0LL);
    }
    rpmh_core_verify(1LL);
    rpmh_core_verify(numTcsPerHLOSDrv != 0);
  }
  if ( v1 == 1 )
    goto LABEL_13;
  if ( !v1 )
  {
    v1 = 1;
    for ( i = 0; i < numTcsPerHLOSDrv; i = (unsigned __int8)(i + 1) )
    {
      v1 = *(_BYTE *)(int)(672 * i + 404753688) & 1;
      if ( (*(_DWORD *)(int)(672 * i + 404753688) & 1) == 0 )
        break;
    }
LABEL_13:
    for ( j = 0; j < numTcsPerHLOSDrv; j = (unsigned __int8)(j + 1) )
    {
      v1 = *(_BYTE *)(int)(672 * j + 404819224) & 1;
      if ( (*(_DWORD *)(int)(672 * j + 404819224) & 1) == 0 )
        break;
    }
    goto LABEL_17;
  }
  if ( v1 != 2 )
  {
    v1 = 1;
    goto LABEL_22;
  }
  v1 = 1;
LABEL_17:
  for ( k = 0; k < numTcsPerHLOSDrv; k = (unsigned __int8)(k + 1) )
  {
    v1 = *(_BYTE *)(int)(672 * k + 404884760) & 1;
    if ( (*(_DWORD *)(int)(672 * k + 404884760) & 1) == 0 )
      break;
  }
LABEL_22:
  rpmh_core_verify(1LL);
  rpmh_core_verify(1LL);
  return v1;
}



__int64 __fastcall RscHalClearAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v3; // x20
  unsigned int v4; // w1
  bool v5; // cc
  unsigned int v7; // w19
  int v8; // w1
  __int64 v9; // x0

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 )
    v5 = v4 > a2;
  else
    v5 = 0;
  if ( !v5 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  v7 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v7 )
  {
    rpmh_core_verify(1LL);
    return v7;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      *(_DWORD *)(v9 + 3336) = 1 << a2;
      return 0LL;
    }
    if ( v8 == 2 )
    {
      *(_DWORD *)(v9 + 134408) = 1 << a2;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalClearePCBTimedOut(unsigned int a1)
{
  unsigned int v2; // w21
  _BYTE *v3; // x19

  v2 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v2 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v3 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v3 + 6) )
    {
      v2 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v3 + 2) + 212LL) = 1;
    }
  }
  return v2;
}



__int64 __fastcall rsc_hal_conf_hidden_tcs_owner(__int64 result, char a2)
{
  *(_DWORD *)(result + 28) = *(_DWORD *)(result + 28) & 0x10000 | a2 & 3;
  return result;
}



__int64 __fastcall rsc_hal_config_br_addr(__int64 result, int a2, unsigned __int16 a3)
{
  *(_DWORD *)(result + 4LL * (a2 & 0x3FFFFFFF) + 1280) = a3;
  return result;
}



__int64 __fastcall RscHalConfigureCmdCompletion(unsigned int a1, unsigned __int8 a2, __int16 a3)
{
  unsigned int v3; // w19
  _BYTE *v4; // x22
  unsigned int v5; // w1
  int v7; // w21
  unsigned int v8; // w20
  int v9; // w1
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x19

  v3 = a2;
  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = *((_DWORD *)v4 + 8);
  if ( !v5 || v5 <= v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  LOWORD(v7) = a3;
  v8 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v8 )
  {
    rpmh_core_verify(1LL);
    return v8;
  }
  else
  {
    v9 = *((_DWORD *)v4 + 6);
    v10 = *((_QWORD *)v4 + 2);
    if ( !v9 )
    {
      v7 = (unsigned __int16)v7;
      v11 = v10 + 3344;
      v12 = (int)(672 * v3);
      goto LABEL_9;
    }
    if ( v9 == 2 )
    {
      v7 = (unsigned __int16)v7;
      v11 = v10 + 134416;
      v12 = (int)(672 * v3);
LABEL_9:
      *(_DWORD *)(v12 + v11) = v7;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalConvertAMCtoTCS(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) &= 0x1000000u;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalConvertTCStoAMC(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) = *(_DWORD *)(v11 + v10) & 0x1000000 | 0x10000;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall rsc_hal_copy_extended_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  int v4; // w5
  int v5; // w4
  __int64 v6; // x8
  int v7; // w6
  int v8; // w7
  __int64 v9; // x5
  int v10; // w9
  int v11; // w6
  int v12; // w6
  char v13; // w9
  int v14; // w5
  int v15; // w5
  __int64 v16; // x1

  a4 = (unsigned __int16)a4;
  v4 = 2 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
  if ( a2 >= (unsigned int)v4 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v5 > v4 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)v6 )
    {
      if ( (((_BYTE)a2 + (_BYTE)v6) & 1) != 0 )
      {
        v13 = 16;
        v14 = -65536;
      }
      else if ( (_WORD)v6 )
      {
        v9 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 2) + 1536LL;
        v10 = *(_DWORD *)(a1 + v9);
        v11 = (v7 ^ v10) & v8;
        v8 = 0;
        v12 = v11 ^ v10;
        v13 = 0;
        *(_DWORD *)(a1 + v9) = v12;
        v14 = 0xFFFF;
        v7 = 0;
      }
      else
      {
        v13 = 0;
        v14 = 0xFFFF;
      }
      v8 |= v14;
      v15 = *(unsigned __int16 *)(a3 + 2 * v6++);
      v7 |= v15 << v13;
    }
    v16 = 4 * (((unsigned __int16)v5 - 1) / 2) + 1536LL;
    *(_DWORD *)(a1 + v16) ^= (v7 ^ *(_DWORD *)(a1 + v16)) & v8;
  }
  return a4;
}



__int64 __fastcall rsc_hal_copy_simple_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  int v4; // w5
  int v5; // w4
  __int64 v6; // x7
  int v7; // w6
  int v8; // w10
  int v9; // w8
  __int64 v10; // x5
  int v11; // w8
  int v12; // w6
  int v13; // w8
  char v14; // w5
  int v15; // w8
  int v16; // w9
  __int64 v17; // x1

  a4 = (unsigned __int16)a4;
  v4 = 4 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
  if ( a2 >= (unsigned int)v4 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v5 > v4 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)v6 )
    {
      v9 = ((_BYTE)a2 + (_BYTE)v6) & 3;
      switch ( v9 )
      {
        case 2:
          v14 = 16;
          v15 = 16711680;
          break;
        case 3:
          v14 = 24;
          v15 = -16777216;
          break;
        case 1:
          v14 = 8;
          v15 = 65280;
          break;
        default:
          if ( (_WORD)v6 )
          {
            v10 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 4) + 1536LL;
            v11 = *(_DWORD *)(a1 + v10);
            v12 = (v7 ^ v11) & v8;
            v8 = 0;
            v13 = v12 ^ v11;
            v7 = 0;
            *(_DWORD *)(a1 + v10) = v13;
          }
          v14 = 0;
          v15 = 255;
          break;
      }
      v16 = *(unsigned __int16 *)(a3 + 2 * v6);
      v8 |= v15;
      ++v6;
      v7 |= v16 << v14;
    }
    v17 = 4 * (((unsigned __int16)v5 - 1) / 4) + 1536LL;
    *(_DWORD *)(a1 + v17) ^= (v7 ^ *(_DWORD *)(a1 + v17)) & v8;
  }
  return a4;
}



__int64 __fastcall RscHalDisableAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v2; // x21
  unsigned int v3; // w3
  char v5; // w20
  unsigned int v6; // w19
  int v7; // w1
  __int64 v8; // x0

  v2 = &GlobalRscHalCtxt[32 * a1];
  v3 = *((_DWORD *)v2 + 8);
  if ( v3 <= a2 || v3 == 0 )
    return 4294967294LL;
  v5 = a2;
  v6 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v6 )
  {
    rpmh_core_verify(1LL);
    return v6;
  }
  else
  {
    v7 = *((_DWORD *)v2 + 6);
    v8 = *((_QWORD *)v2 + 2);
    if ( !v7 )
    {
      *(_DWORD *)(v8 + 3328) &= 0xF & ~(1 << v5);
      return 0LL;
    }
    if ( v7 == 2 )
    {
      *(_DWORD *)(v8 + 134400) = (unsigned __int8)*(_DWORD *)(v8 + 134400) & ~(1 << v5);
      return 0LL;
    }
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalEnableAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v3; // x20
  unsigned int v4; // w1
  unsigned int v7; // w0
  unsigned int v8; // w19
  int v9; // w0
  __int64 v10; // x2

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 <= a2 || v4 == 0 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  v7 = isContextInitialized(GlobalRscHalCtxt, a1);
  v8 = v7;
  if ( v7 )
  {
    rpmh_core_verify(1LL);
    return v8;
  }
  else
  {
    v9 = *((_DWORD *)v3 + 6);
    v10 = *((_QWORD *)v3 + 2);
    if ( !v9 )
    {
      *(_DWORD *)(v10 + 3328) = *(_DWORD *)(v10 + 3328) & 0xF & ~(1 << a2) | (1 << a2);
      return 0LL;
    }
    if ( v9 == 2 )
    {
      *(_DWORD *)(v10 + 134400) = (unsigned __int8)*(_DWORD *)(v10 + 134400) & ~(1 << a2) | (1 << a2);
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall rsc_hal_enable_ts_unit(__int64 result, unsigned __int8 a2, char a3)
{
  *(_DWORD *)(result + 32LL * a2 + 516) = a3 & 1;
  return result;
}



__int64 __fastcall rscHalGetChipsetMappingTable(__int64 a1)
{
  if ( a1 )
  {
    *(_DWORD *)(a1 + 4) = DrvBaseAddressMappingTable_subsystem;
    return 0LL;
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}




__int64 __fastcall rsc_hal_get_delay_cntr_bitwidth(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) & 0x1F;
}



__int64 __fastcall rscHalGetDrvInfo(__int64 a1)
{
  unsigned int i; // w21
  unsigned int *v4; // x23
  __int64 v5; // x22
  char *v6; // x20
  __int64 v7; // x1
  unsigned __int64 v8; // x0
  int v9; // [xsp+58h] [xbp+58h] BYREF
  int v10; // [xsp+5Ch] [xbp+5Ch] BYREF

  v9 = 0;
  v10 = 0;
  if ( a1 && *(_DWORD *)(a1 + 4) )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= *(_DWORD *)(a1 + 4) )
        return 0LL;
      v4 = (unsigned int *)off_1D268;
      v5 = 12LL * i;
      v6 = (char *)off_1D268 + v5;
      v7 = a1 + 32LL * *(unsigned int *)((char *)off_1D268 + v5);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)((char *)off_1D268 + v5);
      v8 = *((unsigned int *)v6 + 1);
      *(_QWORD *)(v7 + 16) = v8;
      *(_DWORD *)(v7 + 24) = (unsigned __int8)v6[8];
      if ( (unsigned int)rscHalGetNumTcs(v8, v6[8], &v9) )
        break;
      *(_DWORD *)(a1 + 32LL * v4[3 * i] + 32) = v9;
      if ( (unsigned int)rscHalGetNumCmdsPerTcs(*((unsigned int *)v6 + 1), v6[8], &v10) )
        break;
      *(_DWORD *)(a1 + 32LL * v4[(unsigned __int64)v5 / 4] + 36) = v10;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
}



__int64 __fastcall rsc_hal_get_major_ver(_DWORD *a1)
{
  return (unsigned __int8)BYTE2(*a1);
}



__int64 __fastcall rsc_hal_get_minor_ver(_DWORD *a1)
{
  return (unsigned __int8)BYTE1(*a1);
}



__int64 __fastcall rscHalGetNumCmdsPerTcs(__int64 a1, unsigned __int8 a2, _DWORD *a3)
{
  bool v3; // zf

  if ( a1 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  else if ( a2 > 2u )
  {
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
  else
  {
    *a3 = *(_DWORD *)(((unsigned __int64)a2 << 16) + a1 + 12) >> 27;
    return 0LL;
  }
}



unsigned __int64 __fastcall rsc_hal_get_num_drvs(__int64 a1)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 8) >> 24) & 7;
}



__int64 __fastcall rsc_hal_get_num_seq_cmd_words(__int64 a1)
{
  return (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
}



__int64 __fastcall rscHalGetNumTcs(unsigned __int64 a1, char a2, _DWORD *a3)
{
  bool v3; // zf

  if ( a1 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  if ( !a2 )
  {
    LODWORD(a1) = *(_DWORD *)(a1 + 12) & 0x3F;
    goto LABEL_11;
  }
  if ( a2 == 2 )
  {
    a1 = ((unsigned __int64)*(unsigned int *)(a1 + 131084) >> 12) & 0x3F;
LABEL_11:
    *a3 = a1;
    return 0LL;
  }
  rpmh_core_verify(1LL);
  return 4294967288LL;
}



unsigned __int64 __fastcall rsc_hal_get_num_ts_events(__int64 a1)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 8) >> 8) & 0xF;
}



__int64 __fastcall rsc_hal_get_parentchild_cfg(__int64 a1)
{
  return *(_DWORD *)(a1 + 12) & 0xF8FFFFFF;
}



__int64 __fastcall rsc_hal_get_seq_override_start_addr_valid(__int64 a1)
{
  return *(_DWORD *)(a1 + 1024) >> 31;
}



__int64 __fastcall rsc_hal_get_seq_program_counter(__int64 a1)
{
  return *(_DWORD *)(a1 + 1032) & 0x3FF;
}



__int64 __fastcall rsc_hal_get_solver_cfg(__int64 a1)
{
  return *(_DWORD *)(a1 + 4) & 0x71F1F1F;
}



__int64 __fastcall rsc_hal_get_status0(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) & 0x101FFFF;
}



__int64 __fastcall rsc_hal_get_status1(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}



__int64 __fastcall rsc_hal_get_status2(__int64 a1)
{
  return *(_DWORD *)(a1 + 24) & 0xFFFFFF;
}



__int64 __fastcall rsc_hal_get_step_ver(_DWORD *a1)
{
  return (unsigned __int8)*a1;
}



unsigned __int64 __fastcall rsc_hal_get_ts_overflow(__int64 a1, unsigned __int8 a2)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 32LL * a2 + 528) >> 8) & 1;
}



__int64 __fastcall rsc_hal_get_ts_unit_h(__int64 a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 32LL * a2 + 524) & 0xFFFFFF;
}



__int64 __fastcall rsc_hal_get_ts_unit_l(__int64 a1, unsigned __int8 a2)
{
  return *(unsigned int *)(a1 + 32LL * a2 + 520);
}



__int64 __fastcall rsc_hal_get_ts_valid(__int64 a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 32LL * a2 + 528) & 1;
}



__int64 __fastcall RscHalIsePCBTimedOut(unsigned int a1, _BYTE *a2)
{
  unsigned int v4; // w21
  _BYTE *v5; // x19
  __int64 v6; // x1
  int v7; // w0

  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else if ( a2 )
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    v6 = *((_QWORD *)v5 + 2);
    if ( *((_DWORD *)v5 + 6) )
      v7 = *(_DWORD *)(v6 + 208 + ((unsigned __int64)(unsigned __int16)*((_DWORD *)v5 + 6) << 16));
    else
      v7 = *(_DWORD *)(v6 + 208);
    *a2 = v7 & 1;
  }
  else
  {
    v4 = -5;
    rpmh_core_verify(1LL);
  }
  return v4;
}



__int64 __fastcall RscHalIsTCSIdle(unsigned int a1, unsigned __int8 a2, _BYTE *a3)
{
  unsigned int v3; // w19
  char *v4; // x21
  unsigned int v5; // w1
  unsigned int v6; // w1
  unsigned int v8; // w20
  int v9; // w1
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x19

  v3 = a2;
  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = *((_DWORD *)v4 + 8);
  if ( v5 && v5 > v3 )
  {
    v6 = -5;
    if ( a3 )
    {
      v8 = isContextInitialized(GlobalRscHalCtxt, a1);
      if ( v8 )
      {
        rpmh_core_verify(1LL);
        return v8;
      }
      v9 = *((_DWORD *)v4 + 6);
      v10 = *((_QWORD *)v4 + 2);
      if ( v9 )
      {
        if ( v9 != 2 )
        {
          rpmh_core_verify(1LL);
          return (unsigned int)-8;
        }
        v11 = v10 + 134424;
        v12 = (int)(672 * v3);
      }
      else
      {
        v11 = v10 + 3352;
        v12 = (int)(672 * v3);
      }
      v6 = 0;
      *a3 = *(_BYTE *)(v12 + v11) & 1;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v6;
}



__int64 __fastcall RscHalReadConfig(unsigned int a1, _DWORD *a2, _DWORD *a3)
{
  bool v3; // zf
  unsigned int v8; // w0
  unsigned int v9; // w20
  _BYTE *v10; // x19

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  else
  {
    v8 = isContextInitialized(GlobalRscHalCtxt, a1);
    v9 = v8;
    if ( v8 )
    {
      rpmh_core_verify(1LL);
      return v9;
    }
    else
    {
      v10 = &GlobalRscHalCtxt[32 * a1];
      *a2 = *((_DWORD *)v10 + 8);
      *a3 = *((_DWORD *)v10 + 9);
      return 0LL;
    }
  }
}



__int64 __fastcall RscHalReadResponseData(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _DWORD *a4)
{
  unsigned int v4; // w20
  _BYTE *v5; // x21
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  int v9; // w19
  int v11; // w1
  __int64 v12; // x0
  __int64 v13; // x3
  __int64 v14; // x0
  int v15; // w0

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = *((_DWORD *)v5 + 8);
  if ( v6 && v6 > v4 )
  {
    v8 = *((_DWORD *)v5 + 9);
    if ( v8 && (v9 = a3, v8 > a3) )
    {
      v7 = -5;
      if ( a4 )
      {
        if ( (unsigned int)isContextInitialized(GlobalRscHalCtxt, a1) )
        {
          rpmh_core_verify(1LL);
          return (unsigned int)-6;
        }
        v11 = *((_DWORD *)v5 + 6);
        v12 = *((_QWORD *)v5 + 2);
        v13 = v12 + 3392;
        v14 = v12 + 134464;
        if ( v11 )
        {
          if ( v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          v15 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v14);
        }
        else
        {
          v15 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v13);
        }
        v7 = 0;
        *a4 = v15;
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}



__int64 __fastcall RscHalRegisterDrv(unsigned int a1)
{
  __int64 result; // x0
  unsigned int v3; // w2
  _BYTE *v4; // x1

  if ( a1 > 2 )
    goto LABEL_2;
  v3 = 0;
  if ( !GlobalRscHalCtxt[0] )
  {
    *(_DWORD *)&GlobalRscHalCtxt[4] = DrvBaseAddressMappingTable_subsystem;
    result = rscHalGetDrvInfo((__int64)GlobalRscHalCtxt);
    v3 = result;
    if ( (result & 0x80000000) != 0 )
      return result;
    GlobalRscHalCtxt[0] = 1;
  }
  v4 = &GlobalRscHalCtxt[32 * a1];
  if ( !*((_QWORD *)v4 + 2) )
  {
LABEL_2:
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  v4[28] = 1;
  return v3;
}



__int64 __fastcall rsc_hal_seq_busy(__int64 a1)
{
  return *(_DWORD *)(a1 + 1028) & 1;
}



__int64 __fastcall rsc_hal_set_seq_override_start_addr(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 1024) = *(_DWORD *)(result + 1024) & 0x80000000 | a2;
  return result;
}



__int64 __fastcall rsc_hal_set_seq_override_start_addr_valid(__int64 result, int a2)
{
  *(_DWORD *)(result + 1024) = *(_DWORD *)(result + 1024) & 0x3FF | (a2 << 31);
  return result;
}



__int64 __fastcall rsc_hal_set_trigger_seq(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 1120) = a2;
  return result;
}



__int64 __fastcall rsc_hal_set_trigger_start_address(__int64 result, unsigned __int16 a2)
{
  *(_DWORD *)(result + 1124) = a2;
  return result;
}



__int64 __fastcall rsc_hal_set_ts_unit_owner(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 512) = a2;
  return result;
}



__int64 __fastcall rscHalSetupDrv0Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  unsigned int v4; // w7
  __int64 v5; // x0

  if ( a1 )
  {
    if ( a3 )
    {
      v4 = *((_DWORD *)a3 + 1);
      v5 = 672 * a2 + a1;
      *(_DWORD *)(20LL * *a3 + 3380 + v5) = ((a3[1] & 7) << 16) | (unsigned __int16)*(_DWORD *)(20LL * *a3 + 3380 + v5);
      *(_DWORD *)(20LL * *a3 + 3380 + v5) = *(_DWORD *)(20LL * *a3 + 3380 + v5) & 0x70000 | *((unsigned __int16 *)a3 + 1);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x10F | ((v4 < 2) << 16);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x1000F | ((v4 != 0) << 8);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = a3[8] & 0xF | *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x10100;
      *(_DWORD *)(20LL * *a3 + 3384 + v5) = *((_DWORD *)a3 + 3);
      return 0LL;
    }
    else
    {
      rpmh_core_verify(1LL);
      return 4294967291LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}



__int64 __fastcall rscHalSetupDrv2Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  unsigned int v4; // w7
  __int64 v5; // x0

  if ( a1 )
  {
    if ( a3 )
    {
      v4 = *((_DWORD *)a3 + 1);
      v5 = 672 * a2 + a1;
      *(_DWORD *)(20LL * *a3 + 134452 + v5) = ((a3[1] & 7) << 16) | (unsigned __int16)*(_DWORD *)(20LL * *a3
                                                                                                + 134452
                                                                                                + v5);
      *(_DWORD *)(20LL * *a3 + 134452 + v5) = *(_DWORD *)(20LL * *a3 + 134452 + v5) & 0x70000 | *((unsigned __int16 *)a3
                                                                                                + 1);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x10F | ((v4 < 2) << 16);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x1000F | ((v4 != 0) << 8);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = a3[8] & 0xF | *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x10100;
      *(_DWORD *)(20LL * *a3 + 134456 + v5) = *((_DWORD *)a3 + 3);
      return 0LL;
    }
    else
    {
      rpmh_core_verify(1LL);
      return 4294967291LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}



__int64 __fastcall RscHalSetupTCS(__int64 a1)
{
  __int64 result; // x0
  unsigned int v3; // w0
  _BYTE *v4; // x21
  unsigned int v5; // w2
  unsigned int v6; // w1
  unsigned int IsTCSIdle; // w19
  unsigned __int8 *v8; // x19
  __int64 v9; // x22
  int v10; // w0
  unsigned int v11; // w21
  unsigned int i; // w21
  char v13; // [xsp+3Fh] [xbp+3Fh] BYREF

  v13 = 0;
  if ( !a1 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  v3 = *(_DWORD *)a1;
  if ( v3 > 2 )
  {
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  v4 = &GlobalRscHalCtxt[32 * v3];
  v5 = *((_DWORD *)v4 + 8);
  if ( !v5 || (v6 = *(unsigned __int8 *)(a1 + 4), v5 <= v6) )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(v3, v6, &v13);
  if ( IsTCSIdle )
  {
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  if ( !v13 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  v8 = *(unsigned __int8 **)(a1 + 16);
  result = 4294967291LL;
  v9 = *((_QWORD *)v4 + 2);
  if ( v8 && *(_DWORD *)(a1 + 8) )
  {
    v10 = *((_DWORD *)v4 + 6);
    if ( v10 )
    {
      v11 = 0;
      if ( v10 != 2 )
      {
        rpmh_core_verify(1LL);
        return 4294967288LL;
      }
      while ( v11 < *(_DWORD *)(a1 + 8) )
      {
        result = rscHalSetupDrv2Tcs(v9, *(_BYTE *)(a1 + 4), v8);
        if ( (_DWORD)result )
          return result;
        v8 += 16;
        ++v11;
      }
    }
    else
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
      {
        result = rscHalSetupDrv0Tcs(v9, *(_BYTE *)(a1 + 4), v8);
        if ( (_DWORD)result )
          return result;
        v8 += 16;
      }
    }
    return 0LL;
  }
  return result;
}



__int64 __fastcall RscHalToggleePCBTimeOut(unsigned int a1, char a2)
{
  unsigned int v4; // w21
  _BYTE *v5; // x19

  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v5 + 6) )
    {
      v4 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) = ((a2 & 1) << 20) | (unsigned __int16)*(_DWORD *)(*((_QWORD *)v5 + 2)
                                                                                                + 216LL);
    }
  }
  return v4;
}



__int64 __fastcall RscHalToggleTCSCmd(unsigned int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  _BYTE *v4; // x22
  unsigned int v5; // w19
  unsigned int v6; // w1
  unsigned int IsTCSIdle; // w20
  int v10; // w1
  __int64 v11; // x0
  __int64 v12; // x0
  __int64 v13; // x19
  char v14; // [xsp+4Fh] [xbp+4Fh] BYREF

  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = a2;
  v14 = 0;
  v6 = *((_DWORD *)v4 + 8);
  if ( !v6 || v6 <= v5 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v5, &v14);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v14 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v10 = *((_DWORD *)v4 + 6);
    v11 = *((_QWORD *)v4 + 2);
    if ( !v10 )
    {
      v12 = v11 + 3356;
      v13 = (int)(672 * v5);
      goto LABEL_12;
    }
    if ( v10 == 2 )
    {
      v12 = v11 + 134428;
      v13 = (int)(672 * v5);
LABEL_12:
      *(_DWORD *)(v13 + v12) = a3;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalTriggerTCS(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) &= 0x10000u;
      *(_DWORD *)(v11 + v10) = *(_DWORD *)(v11 + v10) & 0x10000 | 0x1000000;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}



__int64 __fastcall RscHalUpdateePCBTimeOutThreshold(unsigned int a1, unsigned __int16 a2)
{
  int v3; // w22
  unsigned int v4; // w21
  _BYTE *v5; // x19

  v3 = a2;
  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v5 + 6) )
    {
      v4 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) = *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) & 0x100000 | v3;
    }
  }
  return v4;
}



__int64 __fastcall RscHalVersionID(unsigned int a1, int *a2)
{
  unsigned int v5; // w20

  if ( a2 )
  {
    v5 = isContextInitialized(GlobalRscHalCtxt, a1);
    if ( v5 )
    {
      rpmh_core_verify(1LL);
      return v5;
    }
    else
    {
      *a2 = *(_DWORD *)(((unsigned __int64)(unsigned __int16)*(_DWORD *)&GlobalRscHalCtxt[32 * a1 + 24] << 16)
                      + *(_QWORD *)&GlobalRscHalCtxt[32 * a1 + 16]) & 0xFFFFFF;
      return 0LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
}



__int64 __fastcall rsc_init_base_address(__int64 a1)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 1LL;
  if ( !g_rsc_ss_base )
    g_rsc_ss_base = 394264576LL;
  v2 = *(_QWORD *)(a1 + 24);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    result = 0LL;
    *(_QWORD *)(a1 + 40) = g_rsc_ss_base + v2;
  }
  return result;
}



__int64 __fastcall rsc_instance_init(__int64 a1)
{
  unsigned int v2; // w20

  if ( (unsigned int)rsc_init_base_address(a1) )
    return 0xFFFFFFFFLL;
  rsc_read_internal_config(a1);
  rsc_read_id_info(a1);
  v2 = rsc_copy_cmd_seqs(a1);
  rsc_conf_hidden_tcs_ownership(a1, *(_BYTE *)(a1 + 32));
  return v2;
}



__int64 __fastcall rsc_mode_index(__int64 a1, unsigned __int8 a2)
{
  int v2; // w5
  __int64 v3; // x3
  unsigned int v4; // w2
  __int64 v5; // x4
  __int64 result; // x0
  __int64 v7; // x2
  int v8; // w3

  v2 = *(_DWORD *)(a1 + 16);
  v3 = 0LL;
  while ( 1 )
  {
    v4 = v3;
    if ( v3 == v2 )
      break;
    v5 = *(_QWORD *)(a1 + 8) + 240 * v3++;
    if ( *(_WORD *)(v5 + 16) == a2 )
      return v4;
  }
  v7 = *(_QWORD *)(a1 + 64);
  if ( v7 || (v8 = *(_DWORD *)(a1 + 72), result = 4LL, v8) )
  {
    result = 0LL;
    while ( (_DWORD)result != v2 )
    {
      if ( v7 && *(_WORD *)(v7 + 16) == a2 )
        return result;
      result = (unsigned int)(result + 1);
      v7 += 240LL;
    }
    return 4LL;
  }
  return result;
}



__int64 __fastcall rsc_program_dyn_cmd_seq(__int64 a1, __int64 a2, __int16 a3, _DWORD *a4)
{
  unsigned int v4; // w4
  __int64 (*v7)(void); // x4
  __int16 v10; // w24
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x2
  int v13; // w0
  __int16 v14; // w0

  if ( !a1 )
    return 1LL;
  v4 = 1;
  if ( *(_QWORD *)(a1 + 40) )
  {
    if ( *(_BYTE *)(a1 + 1) == 8 )
      v7 = (__int64 (*)(void))rsc_hal_copy_simple_cmd_seq;
    else
      v7 = (__int64 (*)(void))rsc_hal_copy_extended_cmd_seq;
    if ( (unsigned int)initial_dynmode_id_1266 <= 0xFF )
    {
      v10 = v7();
      v4 = 3;
      if ( v10 )
      {
        v11 = qtisec_realloc(*(_QWORD *)(a1 + 64), 240LL * (unsigned int)(*(_DWORD *)(a1 + 72) + 1));
        *(_QWORD *)(a1 + 64) = v11;
        v4 = -1;
        if ( v11 )
        {
          v12 = v11 + 240LL * *(unsigned int *)(a1 + 72);
          *(_QWORD *)v12 = a2;
          v13 = initial_dynmode_id_1266;
          *(_WORD *)(v12 + 8) = a3;
          *(_WORD *)(v12 + 16) = v13;
          initial_dynmode_id_1266 = v13 + 1;
          *a4 = (unsigned __int16)v13;
          *(_WORD *)(v12 + 232) = 0;
          v14 = *(_WORD *)(a1 + 56);
          if ( *(_BYTE *)(a1 + 1) == 8 )
            *(_WORD *)(v12 + 18) = v14;
          else
            *(_WORD *)(v12 + 18) = 2 * (v14 & 0x7FFF);
          v4 = 0;
          *(_WORD *)(a1 + 56) = v10 + v14;
          ++*(_DWORD *)(a1 + 72);
        }
      }
    }
    else
    {
      v4 = -1;
      *a4 = 255;
    }
  }
  return v4;
}



__int64 __fastcall rsc_read_id_info(__int64 a1)
{
  _BYTE *v2; // x20
  __int64 result; // x0

  v2 = *(_BYTE **)(a1 + 80);
  *v2 = rsc_hal_get_step_ver(*(_DWORD **)(a1 + 40));
  v2[1] = rsc_hal_get_minor_ver(*(_DWORD **)(a1 + 40));
  result = rsc_hal_get_major_ver(*(_DWORD **)(a1 + 40));
  v2[2] = result;
  return result;
}



__int64 __fastcall rsc_read_internal_config(__int64 result)
{
  unsigned __int16 v1; // w1
  __int64 v2; // x20
  __int64 v3; // x19

  v1 = rsc_params_count;
  if ( (unsigned __int16)rsc_params_count > 3u )
  {
    *(_QWORD *)(result + 80) = 0LL;
  }
  else
  {
    ++rsc_params_count;
    *(_QWORD *)(result + 80) = &rsc_params[16 * v1];
  }
  v2 = *(_QWORD *)(result + 80);
  if ( v2 )
  {
    v3 = result;
    *(_DWORD *)(v2 + 4) = rsc_hal_get_solver_cfg(*(_QWORD *)(result + 40));
    *(_DWORD *)(v2 + 12) = rsc_hal_get_parentchild_cfg(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 8) = rsc_hal_get_num_drvs(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 9) = rsc_hal_get_num_seq_cmd_words(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 10) = rsc_hal_get_num_ts_events(*(_QWORD *)(v3 + 40));
    result = rsc_hal_get_delay_cntr_bitwidth(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 11) = result;
  }
  return result;
}



__int64 __fastcall rsc_set_low_power_mode(__int64 a1, unsigned __int8 a2)
{
  unsigned int v2; // w2
  unsigned int v4; // w0
  unsigned int v5; // w21
  __int64 v6; // x20
  unsigned __int16 v7; // w2

  if ( !a1 )
    return 1LL;
  v2 = 1;
  if ( *(_QWORD *)(a1 + 40) )
  {
    v4 = rsc_mode_index(a1, a2);
    v2 = 2;
    if ( v4 != 4 )
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 8) + 240LL * v4;
      if ( *(_QWORD *)(v6 + 24) )
      {
        while ( v5 < *(unsigned __int16 *)(v6 + 32) )
        {
          v7 = *(_WORD *)(*(_QWORD *)(v6 + 24) + 2LL * v5);
          if ( v7 )
            rsc_hal_config_br_addr(*(_QWORD *)(a1 + 40), v5, v7);
          ++v5;
        }
      }
      rsc_hal_set_seq_override_start_addr_valid(*(_QWORD *)(a1 + 40), 1);
      rsc_hal_set_seq_override_start_addr(*(_QWORD *)(a1 + 40), *(_BYTE *)(v6 + 18));
      return 0;
    }
  }
  return v2;
}




__int64 __fastcall rsc_trigger_seq(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // x0
  __int64 v4; // x5
  __int64 v5; // x2
  unsigned int v6; // w4
  __int64 v7; // x4
  __int64 v8; // x19

  if ( !a1 )
    return 2LL;
  result = 2LL;
  v4 = *(_QWORD *)(a1 + 40);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 64);
    v6 = *(_DWORD *)(a1 + 72);
    if ( v5 || v6 )
    {
      v7 = v5 + 240LL * v6;
      while ( v7 != v5 )
      {
        if ( v5 && *(_WORD *)(v5 + 16) == a2 )
        {
          v8 = a1;
          rsc_hal_set_trigger_start_address(v4, *(_WORD *)(v5 + 18));
          rsc_hal_set_trigger_seq(*(_QWORD *)(v8 + 40), 0);
          rsc_hal_set_trigger_seq(*(_QWORD *)(v8 + 40), 1u);
          do
            result = rsc_hal_seq_busy(*(_QWORD *)(v8 + 40));
          while ( (_DWORD)result );
          return result;
        }
        v5 += 240LL;
      }
      return 2LL;
    }
  }
  return result;
}



__int64 __fastcall rsc_ts_init(__int64 a1)
{
  unsigned int v2; // w2

  if ( !a1 || !*(_QWORD *)(a1 + 40) )
    return 1LL;
  v2 = rsc_enable_ts_events(a1, 1);
  if ( v2 )
  {
    *(_BYTE *)(a1 + 88) = 0;
    return (unsigned int)-1;
  }
  else
  {
    *(_BYTE *)(a1 + 88) = 1;
  }
  return v2;
}



unsigned __int64 __fastcall scmi_construct_msg_hdr(unsigned __int8 a1, char a2, unsigned __int8 a3, __int16 a4)
{
  int v5; // [xsp+8h] [xbp-8h]

  LOBYTE(v5) = a1;
  BYTE1(v5) = BYTE1(v5) & 0xFC | a2 & 3;
  return a1 | (unsigned __int64)(unsigned __int16)((unsigned __int8)((unsigned __int16)(v5 & 0x3FF | (a3 << 10)) >> 8) << 8) | ((((v5 & 0xFFFC03FF | (a3 << 10)) >> 16) & 3 | (unsigned __int8)(4 * a4)) << 16) & 0xFFFFFF | ((unsigned __int64)(unsigned __int8)((unsigned __int16)(((v5 & 0xFFFC03FF | (a3 << 10)) >> 16) & 0xF003 | (4 * (a4 & 0x3FF))) >> 8) << 24);
}



__int64 __fastcall scmi_packet_init_payload(__int64 result)
{
  *(_DWORD *)(result + 20) = 4;
  return result;
}



__int64 __fastcall scmi_process_packet(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v4; // w1
  __int64 result; // x0
  __int64 v6; // x1

  v4 = (unsigned __int8)((unsigned __int64)*(unsigned int *)(a1 + 24) >> 10);
  if ( v4 == 20 )
  {
    result = handle_scmi_clk_mgmt_protocol_msg(a1);
    goto LABEL_11;
  }
  if ( v4 > 0x14 )
  {
    v6 = v4 - 128;
    if ( (unsigned int)v6 <= 2 )
    {
      result = handle_scmi_vendor_protocol_msg(a1, v6, a3);
      goto LABEL_11;
    }
LABEL_10:
    result = handle_scmi_unknown_protocol(a1);
    goto LABEL_11;
  }
  if ( v4 == 16 )
  {
    result = handle_scmi_base_protocol_msg(a1);
    goto LABEL_11;
  }
  if ( v4 != 19 )
    goto LABEL_10;
  result = handle_scmi_perf_dom_mgmt_protocol_msg();
LABEL_11:
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}



__int64 __fastcall scmi_read_packet(__int64 a1, __int64 a2, __int64 a3)
{
  if ( qtiseclib_cb_set_spi_routing )
    qtiseclib_cb_set_spi_routing(a1, qtiseclib_cb_set_spi_routing, a3);
  return 0LL;
}



__int64 __fastcall scmi_write_packet(__int64 a1)
{
  if ( (*(_DWORD *)(a1 + 16) & 1) == 0 || !qtiseclib_cb_strcmp )
    return 0LL;
  qtiseclib_cb_strcmp(0LL);
  return 0LL;
}



__int64 sec_core()
{
  __int64 result; // x0

  result = 1LL;
  MEMORY[0x17C10000] = 1;
  MEMORY[0x18000000] = 1;
  MEMORY[0x18010000] = 1;
  MEMORY[0x18020000] = 1;
  MEMORY[0x18030000] = 1;
  MEMORY[0x18040000] = 1;
  MEMORY[0x18050000] = 1;
  MEMORY[0x18060000] = 1;
  MEMORY[0x18070000] = 1;
  MEMORY[0x18080000] = 1;
  MEMORY[0x17800000] = 1;
  MEMORY[0x17E00004] = 0;
  MEMORY[0x18101C00] = 7;
  MEMORY[0x18100C00] = 7;
  MEMORY[0x18300024] = 3;
  MEMORY[0x18300028] = 15;
  MEMORY[0x18282040] = 3;
  MEMORY[0x18280040] = 3;
  MEMORY[0x18284040] = 3;
  MEMORY[0x182A0004] = 1;
  return result;
}



unsigned __int64 __fastcall set_boot_remap(unsigned __int64 a1)
{
  unsigned __int64 v1; // x2
  unsigned __int64 result; // x0

  v1 = a1 >> 2;
  result = a1 >> 34;
  MEMORY[0x17E0001C] = v1;
  MEMORY[0x17E00020] = result;
  return result;
}




__int64 SpmiBus_DeInit()
{
  spmiDrv[0] = 0;
  return 0LL;
}



__int64 SpmiBus_Init()
{
  __int64 result; // x0
  __int64 v1; // x0
  unsigned __int16 **v2; // x0
  unsigned __int16 *v3; // x1
  unsigned int v4; // w3
  unsigned int i; // w0
  unsigned __int64 v6; // x2
  __int64 v7; // x2

  result = 0LL;
  if ( !spmiDrv[0] )
  {
    result = SpmiOs_Init(&qword_316C8);
    if ( !(_DWORD)result )
    {
      v1 = qword_316C8;
      *(_BYTE *)(qword_316C8 + 1) = 0;
      v2 = *(unsigned __int16 ***)(v1 + 24);
      v3 = *v2;
      if ( (*((_DWORD *)*v2 + 5259264) & 0x400) == 0 )
      {
        v4 = *v2[5];
        for ( i = 0; i < v4; ++i )
        {
          v6 = (unsigned __int64)(unsigned __int16)i << 16;
          *(_DWORD *)((char *)v3 + v6 + 23068936) = 255;
          *(_DWORD *)((char *)v3 + v6 + 23068928) = 0;
          v7 = 2LL * (i & 0x3FFFFFFF);
          *(_DWORD *)&v3[v7 + 10507136] = 0;
          *(_DWORD *)&v3[v7 + 10617984] = 0;
        }
        *((_DWORD *)v3 + 5253120) &= ~1u;
        *((_DWORD *)v3 + 5253124) |= 1u;
        *((_DWORD *)v3 + 5253120) |= 1u;
        *((_DWORD *)v3 + 5254082) |= 1u;
        *((_DWORD *)v3 + 5253125) |= 3u;
        *((_DWORD *)v3 + 5254080) &= 0xFFFFFFFC;
        *((_DWORD *)v3 + 5254081) |= 0x800u;
        *((_DWORD *)v3 + 5254081) |= 0x200u;
        *((_DWORD *)v3 + 5254081) |= 0x100u;
        *((_DWORD *)v3 + 5254081) |= 0x80u;
        *((_DWORD *)v3 + 5254081) |= 0x20u;
        *((_DWORD *)v3 + 5254081) |= 8u;
        *((_DWORD *)v3 + 5254081) |= 1u;
        *((_DWORD *)v3 + 5308420) |= 1u;
        *((_DWORD *)v3 + 5254081) &= ~2u;
      }
      spmiDrv[0] = 1;
      return 0LL;
    }
  }
  return result;
}



__int64 __fastcall SpmiBus_ReadLong(char a1, int a2, int a3, char *a4, unsigned int a5, __int64 *a6)
{
  if ( spmiDrv[0] )
    return debugExecute_part_3(1, a2, a1, a3, a4, a5, a6);
  else
    return 14LL;
}



__int64 __fastcall SpmiBus_WriteLong(char a1, int a2, int a3, char *a4, unsigned int a5)
{
  if ( spmiDrv[0] )
    return debugExecute_part_3(0, a2, a1, a3, a4, a5, 0LL);
  else
    return 14LL;
}



__int64 __fastcall SpmiOs_Init(_QWORD *a1)
{
  if ( !pSpmiBlockInfo )
    return 13LL;
  *a1 = pSpmiBlockInfo;
  return 0LL;
}








__int64 __fastcall tcs_clean_sleep_wake(int a1)
{
  unsigned int v1; // w0
  char *v2; // x19
  __int64 v3; // x22
  unsigned int v4; // w20
  __int64 i; // x21
  __int64 result; // x0
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w1
  __int64 v10; // x0

  v1 = lookup_drv_index(a1);
  v2 = (char *)&_compound_literal_1_2 + 48 * v1;
  v3 = 8LL * v1;
  v4 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v1)) + 8LL);
  for ( i = 24LL * (int)v4; ; i += 24LL )
  {
    result = *((unsigned int *)v2 + 6);
    if ( (unsigned int)result <= v4 )
      break;
    v7 = *(_QWORD *)(rpmh_tcs + v3) + i;
    v8 = *(_QWORD *)(v7 + 16);
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 8) )
      {
        rpmh_core_verify((unsigned int)(*(_DWORD *)(v8 + 28) - 1) <= 1);
        rpmh_clean_cmd(*(_QWORD **)(v7 + 16), *((_DWORD *)v2 + 7));
      }
    }
    v9 = v4++;
    v10 = (unsigned int)RscHalToggleTCSCmd(*((_DWORD *)v2 + 1), v9, 0) == 0;
    rpmh_core_verify(v10);
  }
  return result;
}



__int64 __fastcall tcs_finish_active_amc(_QWORD *a1, __int64 a2, int a3)
{
  __int64 finished_amc; // x0
  __int64 v7; // x19
  unsigned __int8 *v8; // x20
  __int64 v9; // x0

  finished_amc = get_finished_amc(a3);
  if ( !finished_amc )
    return 0LL;
  v7 = *(_QWORD *)(finished_amc + 16);
  v8 = (unsigned __int8 *)finished_amc;
  rpmh_core_verify_ptr(v7);
  v9 = *(_QWORD *)(v7 + 16);
  LODWORD(v7) = *(_DWORD *)(v7 + 24);
  *a1 = v9;
  tcs_clean_up(a2, v8, a3, 0);
  return (unsigned int)v7;
}



__int64 __fastcall tcs_finish_amc(__int64 a1, int a2, int a3)
{
  __int64 result; // x0
  unsigned __int8 *v7; // x19

  result = get_finished_amc(a2);
  if ( result )
  {
    v7 = (unsigned __int8 *)result;
    rpmh_core_verify_ptr(*(_QWORD *)(result + 16));
    return tcs_clean_up(a1, v7, a2, a3);
  }
  return result;
}



__int64 tcs_init()
{
  __int64 v0; // x20
  __int64 result; // x0
  char *v2; // x22
  unsigned int v3; // w23
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // [xsp+70h] [xbp+70h]
  unsigned int v7; // [xsp+88h] [xbp+88h] BYREF
  unsigned int v8; // [xsp+8Ch] [xbp+8Ch] BYREF

  v0 = 0LL;
  v8 = 0;
  v7 = 0;
  rpmh_tcs = rpmh_malloc(8u);
  rpmh_core_verify_ptr(rpmh_tcs);
  qtiseclib_cb_memset(rpmh_tcs, 0LL, 8LL);
  tcs_mode = rpmh_malloc(4u);
  rpmh_core_verify_ptr(tcs_mode);
  qtiseclib_cb_memset(rpmh_tcs, 0LL, 4LL);
  while ( 1 )
  {
    result = 1LL;
    if ( (_DWORD)v0 )
      break;
    v2 = (char *)&_compound_literal_1_2 + 48 * v0;
    *(_DWORD *)(tcs_mode + 4 * v0) = 0;
    v3 = ***((_DWORD ***)v2 + 5);
    if ( *(_DWORD *)v2 <= 0x3FFFFEFFu )
    {
      v4 = (unsigned int)RscHalRegisterDrv(*(_DWORD *)v2) == 0;
      rpmh_core_verify(v4);
      v5 = (unsigned int)RscHalReadConfig(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), &v7, &v8) == 0;
      rpmh_core_verify(v5);
      rpmh_core_verify(*((_DWORD *)v2 + 6) <= v7);
      rpmh_core_verify(*((_DWORD *)v2 + 7) <= v8);
      rpmh_core_verify(v3 <= v7);
      RscHalUpdateePCBTimeOutThreshold(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), 0xFFFFu);
      RscHalToggleePCBTimeOut(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), 1);
    }
    v6 = rpmh_tcs;
    *(_QWORD *)(v6 + 8 * v0) = rpmh_malloc(24 * *((_DWORD *)v2 + 6));
    rpmh_core_verify_ptr(*(_QWORD *)(rpmh_tcs + 8 * v0));
    qtiseclib_cb_memset(*(_QWORD *)(rpmh_tcs + 8 * v0), 0LL, 24LL * *((unsigned int *)v2 + 6));
    rpmh_core_verify(*((_DWORD *)v2 + 7) == 16);
    if ( v3 < v7 )
      rpmh_core_verify(v7 >= v3 + 2);
    ++v0;
    tcs_update_mode(0, 0);
  }
  return result;
}



__int64 __fastcall tcs_prepare_sleep_add_cmd_set(int *a1, int a2)
{
  unsigned int v4; // w19
  int v5; // w0
  char *v6; // x21
  __int64 v7; // x19
  __int64 v8; // x0
  unsigned __int64 *v9; // x22
  unsigned __int64 v10; // x0
  __int64 v11; // x2
  int v12; // w5
  int v13; // w2
  __int64 v14; // x1
  int v15; // w0
  __int64 v16; // x0
  int *v17; // x3
  _DWORD *v18; // x7
  unsigned int v19; // w0
  int v20; // w3
  int v21; // w2

  v4 = lookup_drv_index(a2);
  v5 = tcs_slots_available(a2, *a1, a1[1]);
  if ( v5 == -1 )
    return 0LL;
  v6 = (char *)&_compound_literal_1_2 + 48 * v4;
  v7 = *(_QWORD *)(rpmh_tcs + 8LL * v4) + 24LL * v5;
  rpmh_core_verify_ptr(v7);
  rpmh_core_verify(*(_DWORD *)(v7 + 4) == 3);
  if ( !*(_QWORD *)(v7 + 16) )
  {
    v8 = rpmh_malloc(0x30u);
    *(_QWORD *)(v7 + 16) = v8;
    rpmh_core_verify_ptr(v8);
    qtiseclib_cb_memset(*(_QWORD *)(v7 + 16), 0LL, 48LL);
    v9 = *(unsigned __int64 **)(v7 + 16);
    v10 = rpmh_malloc(8 * *((_DWORD *)v6 + 7));
    v11 = *((unsigned int *)v6 + 7);
    *v9 = v10;
    qtiseclib_cb_memset(**(_QWORD **)(v7 + 16), 0LL, 8 * v11);
  }
  v12 = a1[1];
  v13 = 0;
  v14 = *(_QWORD *)(v7 + 16);
  while ( 1 )
  {
    v15 = *(_DWORD *)(v14 + 8);
    if ( v13 == v12 )
      break;
    v16 = (unsigned int)(v13 + v15);
    v17 = &a1[3 * v13++];
    v18 = (_DWORD *)(*(_QWORD *)v14 + 8 * v16);
    *v18 = v17[3];
    v18[1] = *((unsigned __int8 *)v17 + 20);
  }
  v19 = v13 + v15;
  v20 = *a1;
  v21 = a1[2];
  *(_BYTE *)(v14 + 32) = 0;
  *(_DWORD *)(v14 + 8) = v19;
  *(_DWORD *)(v14 + 12) = v21;
  *(_DWORD *)(v14 + 28) = v20;
  rpmh_core_verify(v19 <= *((_DWORD *)v6 + 7));
  return 1LL;
}



__int64 __fastcall tcs_prepare_sleep_commit(int a1)
{
  unsigned int v2; // w0
  char *v3; // x22
  __int64 v4; // x19
  unsigned int v5; // w20
  __int64 i; // x21
  __int64 result; // x0
  __int64 v8; // x0

  v2 = lookup_drv_index(a1);
  v3 = (char *)&_compound_literal_1_2 + 48 * v2;
  v4 = 8LL * v2;
  v5 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v2)) + 8LL);
  for ( i = 24LL * (int)v5; ; i += 24LL )
  {
    result = *((unsigned int *)v3 + 6);
    if ( (unsigned int)result <= v5 )
      break;
    v8 = *(_QWORD *)(*(_QWORD *)(rpmh_tcs + v4) + i + 16);
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 8) )
        tcs_send_internal(v8, a1, v5);
    }
    ++v5;
  }
  return result;
}



  if ( v6 && (v9 = tcs_send(v4, **(_DWORD **)(v4 + 16)), (v3 = v9) != 0) )
  {
    inq_it_delete(v11);
    inq_append(*(unsigned int **)(a1 + 8), v4);
  }
  else
  {
    return 0;
  }
  return v3;
}



__int64 __fastcall tcs_size(int a1)
{
  return *((unsigned int *)&_compound_literal_1_2 + 12 * (unsigned int)lookup_drv_index(a1) + 7);
}



__int64 __fastcall tcs_slots_available(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // w20
  char *v6; // x19
  unsigned int v7; // w2
  __int64 result; // x0
  __int64 v9; // x1
  _QWORD *v10; // x20
  __int64 v11; // x1
  __int64 v12; // x4

  v5 = lookup_drv_index(a1);
  v6 = (char *)&_compound_literal_1_2 + 48 * v5;
  rpmh_core_verify(*((_DWORD *)v6 + 7) >= a3);
  if ( a2 == 1 )
  {
    v9 = *(_QWORD *)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v5));
    v7 = *(_DWORD *)(v9 + 4);
    result = *(unsigned int *)(v9 + 8);
  }
  else if ( a2 == 2 )
  {
    v7 = *((_DWORD *)v6 + 6);
    result = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v5)) + 4LL);
  }
  else
  {
    rpmh_core_verify(0LL);
    v7 = 0;
    result = 0LL;
  }
  v10 = (_QWORD *)(rpmh_tcs + 8LL * v5);
  v11 = 24LL * (int)result;
  while ( v7 > (unsigned int)result )
  {
    v12 = *(_QWORD *)(*v10 + v11 + 16);
    if ( !v12 )
      return result;
    v11 += 24LL;
    if ( a3 <= *((_DWORD *)v6 + 7) - *(_DWORD *)(v12 + 8) )
      return result;
    result = (unsigned int)(result + 1);
  }
  return 0xFFFFFFFFLL;
}



__int64 __fastcall tcs_update_mode(unsigned int a1, unsigned int a2)
{
  __int64 v2; // x20
  __int64 v4; // x22
  char *v5; // x19
  __int64 v6; // x21
  __int64 i; // x20
  __int64 result; // x0
  __int64 v9; // x27
  unsigned int v10; // w1
  __int64 v11; // x28
  __int64 v12; // x0
  unsigned int v13; // w0
  unsigned int v14; // w0
  int v15; // w0
  unsigned int v16; // w0

  v2 = a1;
  v4 = 8LL * a1;
  v5 = (char *)&_compound_literal_1_2 + 48 * a1;
  rpmh_core_verify(*((_DWORD *)v5 + 8) > a2);
  *(_DWORD *)(tcs_mode + 4 * v2) = a2;
  v6 = 8LL * a2;
  for ( i = 0LL; ; ++i )
  {
    result = *((unsigned int *)v5 + 6);
    if ( (unsigned int)result <= (unsigned int)i )
      break;
    v9 = *(_QWORD *)(rpmh_tcs + v4);
    v10 = (unsigned __int8)(*((_DWORD *)v5 + 5) + i);
    v11 = v9 + 24 * i;
    *(_BYTE *)v11 = v10;
    v12 = (unsigned int)RscHalClearAMCFinishedIRQ(*((_DWORD *)v5 + 1), v10) == 0;
    rpmh_core_verify(v12);
    v13 = **(_DWORD **)(*((_QWORD *)v5 + 5) + v6);
    *(_QWORD *)(v11 + 8) = 0LL;
    if ( (unsigned int)i >= v13 )
    {
      v16 = *((_DWORD *)v5 + 1);
      *(_DWORD *)(v11 + 4) = 3;
      v15 = RscHalConvertAMCtoTCS(v16, *(_BYTE *)(v9 + 24 * i));
    }
    else
    {
      v14 = *((_DWORD *)v5 + 1);
      *(_DWORD *)(v11 + 4) = 0;
      v15 = RscHalConvertTCStoAMC(v14, *(_BYTE *)(v9 + 24 * i));
    }
    rpmh_core_verify(v15 == 0);
  }
  return result;
}



_QWORD *__fastcall timer_qtimer_get_frames_list(_QWORD *result, _DWORD *a2)
{
  bool v2; // zf

  if ( result )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( !v2 )
  {
    *result = &qtimer_frames;
    result = (_QWORD *)(&loc_8 + 1);
    *a2 = 9;
  }
  return result;
}



__int64 timer_qtimer_read_time_raw()
{
  return MEMORY[0x17C25000];
}



unsigned __int64 timer_qtimer_read_time_us()
{
  return 10LL * MEMORY[0x17C25000] / 0xC0uLL;
}



__int64 timer_qtimer_security_config()
{
  __int64 result; // x0

  MEMORY[0x17C20004] = 127;
  MEMORY[0x17C20040] = 63;
  MEMORY[0x17C20080] = 0;
  MEMORY[0x17C20084] = 0;
  MEMORY[0x17C20044] = 63;
  MEMORY[0x17C20088] = 0;
  MEMORY[0x17C2008C] = 0;
  MEMORY[0x17C20048] = 63;
  MEMORY[0x17C20090] = 0;
  MEMORY[0x17C20094] = 0;
  MEMORY[0x17C2004C] = 63;
  MEMORY[0x17C20098] = 0;
  MEMORY[0x17C2009C] = 0;
  MEMORY[0x17C20050] = 63;
  MEMORY[0x17C200A0] = 0;
  MEMORY[0x17C200A4] = 0;
  MEMORY[0x17C20054] = 63;
  MEMORY[0x17C200A8] = 0;
  MEMORY[0x17C200AC] = 0;
  MEMORY[0x17C20058] = 63;
  result = 398590128LL;
  MEMORY[0x17C200B0] = 0;
  MEMORY[0x17C200B4] = 0;
  return result;
}



void timer_sec_wdog_init()
{
  MEMORY[0xC230004] = 6;
  int_svc_register_isr(516, (__int64)"SEC_WDOG_BARK", 0xEuLL, (__int64)timer_sec_wdt_bark_handler, 0LL);
  timer_sec_wdog_start(6000, 22000);
}



__int64 timer_sec_wdog_pet()
{
  __int64 result; // x0

  MEMORY[0xC230000] = 1;
  cpuss_dsb();
  result = timer_qtimer_read_time_raw();
  g_sec_wdog_last_pet_time = result;
  return result;
}



void __fastcall timer_sec_wdog_start(int a1, int a2)
{
  unsigned int v2; // w0
  unsigned int v3; // w1

  if ( !a1 )
    a1 = 1;
  if ( !a2 )
    a2 = 1;
  v2 = 32 * a1;
  v3 = 32 * a2;
  MEMORY[0xC230004] &= ~1u;
  if ( v3 > 0xFFFFF )
    v3 = 0xFFFFF;
  if ( v2 > 0xFFFFF )
    v2 = 0xFFFFF;
  MEMORY[0xC23000C] = v2 | MEMORY[0xC23000C] & 0xFFF00000;
  while ( (MEMORY[0xC23000C] & 0x80000000) == 0 )
    ;
  MEMORY[0xC230010] = MEMORY[0xC230010] & 0xFFF00000 | v3;
  while ( (MEMORY[0xC230010] & 0x80000000) == 0 )
    ;
  MEMORY[0xC230004] |= 1u;
  MEMORY[0xC230004] |= 0x80000000;
  MEMORY[0xC230000] = 1;
  cpuss_dsb();
}



void timer_sec_wdog_stop()
{
  MEMORY[0xC230000] = 1;
  MEMORY[0xC230004] &= ~1u;
  cpuss_dsb();
}




__int64 Tlmm_PlatformInit()
{
  __int64 result; // x0

  result = 0xFFFFFFFFLL;
  MEMORY[0xF1AF00C] = -1;
  MEMORY[0xF1AF010] = -1;
  MEMORY[0xF1AF014] = -1;
  MEMORY[0xF1AF018] = -1;
  MEMORY[0xF1AF000] = -1;
  MEMORY[0xF1AF004] = -1;
  MEMORY[0xF1AF008] = -1;
  return result;
}



__int64 __fastcall translate_address(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // x0

  result = 0LL;
  *a3 = a2;
  return result;
}



__int64 update_addr_translation()
{
  __int64 result; // x0

  result = (unsigned __int8)query_dev_config_valid;
  if ( query_dev_config_valid )
    return get_addr_translation(icb_dev_config_0);
  return result;
}



__int64 __fastcall vmidmt_ClearError(__int64 *a1, char a2)
{
  bool v2; // zf
  __int64 v3; // x1
  int v4; // w1

  v2 = a2 == 0;
  v3 = *a1;
  if ( v2 )
  {
    *(_DWORD *)(v3 + 1100) = 0;
    v4 = *(_DWORD *)(v3 + 1100);
  }
  else
  {
    *(_DWORD *)(v3 + 76) = 0;
    v4 = *(_DWORD *)(v3 + 76);
  }
  if ( (v4 & 0xC00000A6) != 0 )
    return 7LL;
  else
    return 0LL;
}



__int64 vmidmt_config()
{
  __int64 result; // x0

  if ( (unsigned int)vmidmt_config_options()
    || (unsigned int)vmidmt_config_vmids()
    || (result = vmidmt_register_interrupts(), (_DWORD)result) )
  {
    qtiseclib_cb_log(10LL, "VMIDMT ERROR :(%x)", 1LL);
    while ( 1 )
      ;
  }
  return result;
}



__int64 __fastcall vmidmt_ConfigErrRep(__int64 a1, char a2, int a3)
{
  int v3; // w3
  bool v4; // zf
  unsigned int *v5; // x2
  unsigned int v6; // w1

  if ( (a3 & 0xFFFFFFE0) != 0 )
    return 5LL;
  v3 = 0;
  if ( (a3 & 1) != 0 )
    v3 = (*(_BYTE *)(a1 + 15) == 1) << 21;
  if ( (a3 & 2) != 0 )
    v3 |= 0x400u;
  if ( (a3 & 4) != 0 )
    v3 |= 0x20u;
  if ( (a3 & 8) != 0 )
    v3 |= 0x10u;
  v4 = (a3 & 0x10) == 0LL;
  v5 = *(unsigned int **)a1;
  if ( !v4 )
    v3 |= 4u;
  if ( a2 )
  {
    *v5 = *v5 & 0xFFDFFBCB | v3 & 0x200434;
    v6 = *v5;
  }
  else
  {
    v5[256] = v5[256] & 0xFDFFBCB | v3 & 0x200434;
    v6 = v5[256];
  }
  if ( v3 == (v6 & 0x200434) )
    return 0LL;
  else
    return 7LL;
}



__int64 vmidmt_config_options()
{
  unsigned int i; // w19
  __int64 result; // x0

  for ( i = 0; i < 3; ++i )
  {
    if ( g_vmidmt_cfg[24 * i + 17] )
    {
      result = vmidmt_config_options_per_master(i);
      if ( (_DWORD)result )
        return result;
    }
  }
  return 0LL;
}



__int64 __fastcall vmidmt_config_options_per_master(int a1)
{
  __int64 v1; // x22
  int v2; // w23
  __int64 Info_index; // x19
  __int64 *v4; // x19
  int v5; // w0
  unsigned int v6; // w1
  unsigned __int8 *v7; // x20
  __int64 v8; // x1
  int v9; // w20
  __int64 v11[2]; // [xsp+40h] [xbp+40h] BYREF
  int v12[8]; // [xsp+50h] [xbp+50h] BYREF
  __int64 v13[3]; // [xsp+70h] [xbp+70h] BYREF
  char v14; // [xsp+88h] [xbp+88h]
  char v15; // [xsp+89h] [xbp+89h]

  v1 = a1;
  v2 = g_vmidmt_cfg[24 * a1];
  Info_index = (unsigned __int8)vmidmt_getInfo_index(g_vmidmt_cfg[24 * a1]);
  v13[2] = (__int64)&acc_ctl;
  v14 = 0;
  v15 = 0;
  v11[1] = 65280LL;
  v13[0] = 0LL;
  v13[1] = 0LL;
  qtiseclib_cb_memset(v12, 0LL, 28LL);
  v11[0] = (__int64)v13;
  if ( v2 == 4 )
  {
    v15 = 0;
    v13[0] = (__int64)v12;
    v12[0] = 2;
  }
  v4 = (__int64 *)&g_vmidmt_info_cfg[24 * Info_index + 8];
  v5 = vmidmt_Init(v4, (__int64)v11, 0LL);
  v6 = -1;
  if ( !v5 )
  {
    v7 = &g_vmidmt_cfg[24 * v1];
    v8 = *((_QWORD *)v7 + 1);
    if ( v8 )
      vmidmt_ConfigSSDT((__int64)v4, v8, v7[16]);
    v9 = g_vmidmt_cfg[24 * v1 + 1];
    vmidmt_ConfigErrRep((__int64)v4, 0, v9);
    vmidmt_ConfigErrRep((__int64)v4, 1, v9);
    return 0;
  }
  return v6;
}



__int64 __fastcall vmidmt_ConfigSSDT(__int64 a1, __int64 a2, unsigned int a3)
{
  bool v4; // cc
  __int64 result; // x0
  unsigned int v6; // w3
  __int64 v7; // x2
  __int64 i; // x3
  __int64 v9; // x0
  int v10; // w5

  if ( a2 )
    v4 = a3 > 4;
  else
    v4 = 1;
  result = 5LL;
  if ( !v4 )
  {
    v6 = 1 << *(_BYTE *)(a1 + 12);
    result = 5LL;
    if ( v6 <= 0x1F )
    {
      if ( a3 > 1 )
        return result;
    }
    else if ( a3 > v6 >> 5 )
    {
      return result;
    }
    v7 = 4LL * a3;
    for ( i = 0LL; i != v7; i += 4LL )
    {
      v9 = (unsigned int)i;
      v10 = *(_DWORD *)(a2 + i);
      *(_DWORD *)(*(_QWORD *)a1 + 128LL + v9) &= v10;
    }
    return 0LL;
  }
  return result;
}



__int64 __fastcall vmidmt_ConfigVmidCtxt(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v3; // x8
  unsigned int v4; // w3
  __int64 result; // x0
  __int64 v6; // x3
  unsigned int v7; // w10
  __int64 v8; // x5
  __int64 v9; // x4
  __int64 v10; // x6
  int v11; // w3
  int v12; // w9
  __int64 *v13; // x11
  unsigned int v14; // w9
  int v15; // w7
  unsigned int v16; // w12
  int *v17; // x5
  unsigned int v18; // w7
  unsigned int i; // w6
  int v20; // t1
  unsigned int v21; // w13
  __int64 v23; // x1
  unsigned int v24; // w2
  _DWORD *v25; // x6
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x1
  int v29; // w1
  __int64 v30; // x2
  __int64 v31; // x1
  int v32; // w3
  __int64 v33; // x1
  __int64 v34; // x0
  __int64 v35; // x1
  unsigned int v36; // w7

  if ( !a3 )
    return 5LL;
  v3 = a1;
  if ( (1 << *(_BYTE *)(a1 + 13)) - 1 >= a2 || (v4 = *(unsigned __int16 *)(a1 + 8), result = 5LL, a2 < v4) )
  {
    v6 = *a3;
    if ( *a3 )
    {
      result = 5LL;
      if ( *(unsigned __int8 *)(v6 + 20) > 7u )
        return result;
      v7 = *(_DWORD *)v6 == 2;
    }
    else
    {
      v7 = 0;
    }
    v8 = *(_QWORD *)v3;
    v9 = 4LL * (a2 >> 5);
    v10 = *(_QWORD *)v3 + 128LL;
    v11 = 1 << a2;
    if ( v7 )
      v12 = ~v11;
    else
      v12 = 1 << a2;
    *(_DWORD *)(v9 + v10) ^= (v12 ^ *(_DWORD *)(v9 + v10)) & v11;
    if ( (v11 & *(_DWORD *)(v9 + v10)) != (v12 & v11) )
      return 7LL;
    v13 = a3;
    v14 = a2;
    if ( *(_BYTE *)(v3 + 15) == 1 )
    {
      v15 = *(_DWORD *)(v8 + 4);
      v16 = a2 | 0x80000000;
      v17 = (int *)(v8 + 2048);
      v18 = BYTE1(v15);
      for ( i = 0; (int)i < *(unsigned __int16 *)(v3 + 8); ++i )
      {
        v20 = *v17++;
        if ( v16 == v20 )
        {
          if ( v7 && v18 - 1 <= i || (v18 > i) > v7 )
            return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
          result = 0LL;
          if ( v18 <= i )
          {
            while ( v18 < i && (_DWORD)result == 0 )
              result = vmidmt_ShiftCtxt_isra_2(*(_QWORD *)v3, i - 1, i);
            if ( (_DWORD)result )
              return result;
            v23 = *(_QWORD *)v3;
            v24 = v18 + 1;
            *(_DWORD *)(v23 + 4) = ((unsigned __int8)(v18 + 1) << 8) | *(_DWORD *)(*(_QWORD *)v3 + 4LL) & 0x1000000;
            v18 = (unsigned __int8)BYTE1(*(_DWORD *)(v23 + 4));
            if ( v24 != v18 )
              return 7LL;
          }
          else
          {
            v21 = v18 - 1;
            while ( v21 > i )
            {
              if ( (_DWORD)result )
                return result;
              result = vmidmt_ShiftCtxt_isra_2(*(_QWORD *)v3, i + 1, i);
            }
            if ( (_DWORD)result )
              return result;
          }
          v25 = (_DWORD *)(4LL * (i & 0x3FFFFFFF) + *(_QWORD *)v3);
          v25[512] = 0;
          if ( v25[512] )
            return 7LL;
          v25[768] &= 0xCF030400;
          if ( (v25[768] & 0x30FCFBFF) != 0 )
            return 7LL;
          v25[896] = 0;
          if ( v25[896] )
            return 7LL;
          break;
        }
      }
      if ( v7 )
      {
        i = *(unsigned __int16 *)(v3 + 8) - 1;
        v27 = (int)(4 * i);
        while ( i != -1 )
        {
          v28 = *(_QWORD *)v3 + 2048LL;
          if ( (*(_DWORD *)(v28 + v27) & 0x80000000) == 0
            || (v29 = *(_DWORD *)(v28 + v27), v27 -= 4LL, v14 == (v29 & 0x7FFF)) )
          {
            if ( v18 - 1 > i )
              return 5LL;
            goto LABEL_51;
          }
          --i;
        }
        return 5LL;
      }
      v26 = 0LL;
      do
      {
        i = v26;
        v32 = v26;
        if ( v18 == v26 )
          break;
        v30 = 4 * v26;
        v31 = *(_QWORD *)v3 + 2048LL;
        if ( (*(_DWORD *)(v31 + 4 * v26) & 0x80000000) == 0 )
          break;
        ++v26;
      }
      while ( v14 != (*(_DWORD *)(v31 + v30) & 0x7FFF) );
      if ( v18 == v32 )
        return 5LL;
LABEL_51:
      v33 = *(_QWORD *)v3 + 2048LL;
      v34 = (int)(4 * i);
      *(_DWORD *)(v33 + v34) = v16;
      if ( v16 != *(_DWORD *)(v33 + v34) )
        return 7LL;
    }
    else
    {
      v18 = 0;
      i = 0;
    }
    if ( ((unsigned __int8)v7 & (v18 > i)) == 0 )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
    v35 = *(_QWORD *)v3;
    v36 = v18 - 1;
    *(_DWORD *)(v35 + 4) = *(_DWORD *)(*(_QWORD *)v3 + 4LL) & 0x1000000 | (v36 << 8);
    if ( v36 == (unsigned __int8)BYTE1(*(_DWORD *)(v35 + 4)) )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
    else
      return 7LL;
  }
  return result;
}



__int64 __fastcall vmidmt_ConfigVmidCtxtWithSIDList(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        __int64 *a5)
{
  __int64 result; // x0
  unsigned int v8; // w5
  __int64 v9; // x0
  unsigned int v10; // w6
  unsigned int v11; // w7
  int v12; // w10
  __int64 v15; // x2
  __int64 v16; // x0
  unsigned int v17; // w6

  if ( *(unsigned __int16 *)(a1 + 8) <= a2 || a5 == 0LL )
    return 5LL;
  if ( *a5 )
  {
    result = 5LL;
    if ( *(unsigned __int8 *)(*a5 + 20) > 7u )
      return result;
  }
  v8 = *(unsigned __int8 *)(a1 + 15);
  if ( v8 != 1 )
    return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)a1, a2, a5);
  if ( !a3 )
    return 5LL;
  if ( *(_BYTE *)(a1 + 13) )
    v8 = (1 << *(_BYTE *)(a1 + 13)) - 1;
  v9 = 0LL;
  v10 = 0;
  v11 = 0;
  while ( v9 != a4 )
  {
    v12 = *(_DWORD *)(a3 + 4 * v9);
    v11 |= v12;
    if ( a4 > (int)v9 + 1 )
      v10 |= v12 ^ *(_DWORD *)(a3 + 4LL * (unsigned int)(v9 + 1));
    ++v9;
  }
  result = 5LL;
  if ( v8 >= v11 && v8 >= v10 )
  {
    v15 = 4LL * (a2 & 0x3FFFFFFF);
    v16 = *(_QWORD *)a1 + 2048LL;
    v17 = v11 | 0x80000000 | (v10 << 16);
    *(_DWORD *)(v16 + v15) = v17;
    if ( v17 == *(_DWORD *)(v16 + v15) )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)a1, a2, a5);
    return 7LL;
  }
  return result;
}



__int64 vmidmt_config_vmids()
{
  char *v0; // x21
  unsigned int i; // w19
  char *v2; // x1
  unsigned __int8 v3; // w0
  unsigned int v4; // w0
  unsigned int v5; // w20

  v0 = (char *)&unk_15EBC;
  for ( i = 0; i < 0x55; ++i )
  {
    v2 = (char *)&g_vmid_map + 28 * (int)i;
    if ( v2[26] )
    {
      v3 = *((_BYTE *)&g_vmid_map + 28 * (int)i);
      v4 = v2[24] == 1 ? vmidmt_map_vmid_internal(v3) : vmidmt_map_multisid_vmid_internal(v3);
      v5 = v4;
      if ( v4 )
      {
        qtiseclib_cb_log(10LL, "VMIDMT Config ERROR for g_vmid_map[%d]", i);
        return v5;
      }
    }
    v0 += 28;
  }
  return 0;
}



__int64 __fastcall vmidmt_EnableClientP(int **a1, char a2)
{
  int *v2; // x0
  int v3; // w0

  v2 = *a1;
  if ( a2 )
  {
    *v2 &= ~1u;
    v3 = *v2;
  }
  else
  {
    v2[256] &= 0xFFFFFFEu;
    v3 = v2[256];
  }
  if ( (v3 & 1) != 0 )
    return 7LL;
  else
    return 0LL;
}



__int64 __fastcall vmidmt_GetError(__int64 result, unsigned __int8 a2, _DWORD *a3)
{
  __int64 v4; // x20
  int v5; // w21
  _DWORD *v6; // x1
  unsigned int v7; // w2
  int v8; // w4
  int v9; // w3
  unsigned __int64 v10; // x0
  int v11; // w1

  if ( a3 )
  {
    v4 = result;
    v5 = a2;
    qtiseclib_cb_memset(a3, 0LL, 44LL);
    v6 = *(_DWORD **)v4;
    if ( v5 )
    {
      v7 = v6[18] & 0xC00000A6;
      a3[2] = v6[16];
      if ( *(_BYTE *)(v4 + 14) )
        a3[3] = v6[17];
      v8 = v6[21];
      v9 = v6[20] & 0x1FF;
      v10 = (unsigned int)v6[22];
    }
    else
    {
      v7 = v6[274] & 0xC00000A6;
      a3[2] = v6[272];
      if ( *(_BYTE *)(v4 + 14) )
        a3[3] = v6[273];
      v8 = v6[277];
      v10 = (unsigned int)v6[278];
      v9 = v6[276] & 0x1FF;
    }
    if ( (v7 & 0x80000000) != 0 )
      *a3 |= 1u;
    if ( (v7 & 0x40000000) != 0 )
      *a3 |= 2u;
    if ( (v7 & 0x80) != 0 )
      *a3 |= 4u;
    if ( (v7 & 0x20) != 0 )
      *a3 |= 8u;
    if ( (v7 & 4) != 0 )
      *a3 |= 0x10u;
    if ( (v7 & 2) != 0 )
      *a3 |= 0x20u;
    if ( (v9 & 0x20) != 0 )
      a3[1] |= 1u;
    if ( (v9 & 0x10) != 0 )
      a3[1] |= 2u;
    if ( (v9 & 2) != 0 )
      a3[1] |= 4u;
    a3[4] = BYTE2(v8);
    a3[5] = v8 & 0x7FFF;
    a3[6] = (unsigned __int8)v10;
    a3[7] = BYTE2(v10);
    a3[8] = BYTE3(v10);
    v11 = (unsigned __int16)v10 >> 13;
    result = (v10 >> 8) & 0x1F;
    a3[9] = v11;
    a3[10] = result;
  }
  return result;
}



__int64 __fastcall vmidmt_getInfo_index(unsigned __int8 a1)
{
  int v1; // w4
  __int64 v2; // x1
  __int64 result; // x0

  v1 = a1;
  v2 = 0LL;
  result = 0xFFFFFFFFLL;
  while ( (int)v2 < (unsigned __int8)g_vmidmt_info_cfg_count )
  {
    if ( g_vmidmt_info_cfg[24 * v2] == v1 )
      result = (unsigned int)v2;
    else
      result = (unsigned int)result;
    ++v2;
  }
  return result;
}



__int64 __fastcall vmidmt_Init(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 *v4; // x9
  __int64 *v5; // x12
  __int64 v6; // x1
  unsigned __int64 v7; // x0
  unsigned int v8; // w10
  __int64 result; // x0
  __int64 *v10; // x1
  int v11; // w10
  __int64 v12; // x11
  unsigned int *v13; // x0
  int v14; // w2
  unsigned int v15; // w2
  unsigned int i; // w1
  unsigned int j; // w1
  __int64 v18; // x4
  __int64 v19; // x5
  unsigned int k; // w1
  __int64 v21; // x4
  unsigned int *v22; // x0
  unsigned int *v23; // x2
  unsigned int v24; // w0
  unsigned int v25; // w1
  _DWORD *v26; // x0
  __int64 v27; // x1

  v4 = a1;
  v5 = a3;
  v6 = *a1;
  v7 = *(unsigned int *)(*a1 + 32);
  *((_BYTE *)v4 + 15) = (v7 & 0x8000000) != 0;
  *((_BYTE *)v4 + 13) = (v7 >> 9) & 0xF;
  *((_WORD *)v4 + 4) = (unsigned __int8)v7;
  *((_BYTE *)v4 + 12) = BYTE1(*(_DWORD *)(v6 + 36)) & 0xF;
  *((_BYTE *)v4 + 14) = *(_DWORD *)(v6 + 40) & 0xF;
  *((_WORD *)v4 + 5) = (unsigned __int8)*(_DWORD *)(v6 + 52);
  *(_DWORD *)(v6 + 156) = -1;
  if ( a2 )
  {
    v8 = *(unsigned __int8 *)(a2 + 9);
    if ( v8 != 255 && v8 > (unsigned __int8)v7 )
      goto LABEL_4;
    v10 = *(__int64 **)a2;
    if ( !*(_QWORD *)a2 || *v10 && *(unsigned __int8 *)(*v10 + 20) > 7u )
      goto LABEL_4;
    result = vmidmt_SetDefaultConfig_isra_0_part_1((unsigned int **)v4, v10, 1);
    if ( (_DWORD)result )
      goto LABEL_17;
    v13 = (unsigned int *)*v4;
    v14 = *(unsigned __int8 *)(v12 + 8);
    v13[1] = ((v14 & 1) << 24) | *(_DWORD *)(*v4 + 4) & 0xFF00;
    if ( (HIBYTE(v13[1]) & 1) != v14
      || (v13[1] = v13[1] & 0x1000000 | (v11 << 8), (unsigned __int8)BYTE1(v13[1]) != v11) )
    {
      result = 7LL;
      goto LABEL_17;
    }
  }
  else
  {
    *(_DWORD *)v6 = 273;
    *(_QWORD *)(v6 + 4) = (unsigned __int8)v7 << 8;
    *(_DWORD *)(v6 + 16) = 0;
  }
  if ( !v5 )
  {
    v22 = (unsigned int *)*v4;
    v22[256] = 273;
    v22[258] = 0;
    v22[260] = 0;
    goto LABEL_30;
  }
  if ( *v5 && *(unsigned __int8 *)(*v5 + 20) > 7u )
  {
LABEL_4:
    result = 5LL;
    goto LABEL_17;
  }
  result = vmidmt_SetDefaultConfig_isra_0_part_1((unsigned int **)v4, v5, 0);
  if ( (_DWORD)result )
    goto LABEL_17;
LABEL_30:
  v23 = (unsigned int *)*v4;
  v23[36] = 1;
  v23[292] = 1;
  v23[19] = 0;
  v23[275] = 0;
  v24 = 1 << *((_BYTE *)v4 + 12);
  if ( v24 <= 0x1F )
  {
    v23[32] = -1;
  }
  else
  {
    v25 = v24 >> 5;
    result = 6LL;
    if ( v25 > 4 )
      goto LABEL_17;
    v26 = v23 + 32;
    v27 = (__int64)&v23[v25 + 32];
    do
      *v26++ = -1;
    while ( (_DWORD *)v27 != v26 );
  }
  result = 0LL;
LABEL_17:
  v15 = *((unsigned __int16 *)v4 + 4);
  if ( *((_BYTE *)v4 + 15) == 1 )
  {
    for ( i = 0; i < v15; ++i )
    {
      v18 = 4LL * (i & 0x3FFFFFFF);
      *(_DWORD *)(*v4 + 2048 + v18) = 0;
    }
  }
  for ( j = 0; j < v15; ++j )
  {
    v19 = 4LL * (j & 0x3FFFFFFF);
    *(_DWORD *)(*v4 + 3072 + v19) = 0x10000;
  }
  for ( k = 0; k < v15; ++k )
  {
    v21 = 4LL * (k & 0x3FFFFFFF);
    *(_DWORD *)(*v4 + 3584 + v21) = 0;
  }
  return result;
}



              if ( vmidmt_IsError(v10, 1) )
              {
                vmidmt_GetError((__int64)v10, 1u, &v12);
                qtiseclib_cb_log(10LL, "Error Flags: 0x%X", (unsigned int)v12);
                qtiseclib_cb_log(10LL, "Bus Flags: 0x%X", HIDWORD(v12));
                qtiseclib_cb_log(10LL, "Phys Addr: 0x%X 0x%X", HIDWORD(v13), (unsigned int)v13);
                qtiseclib_cb_log(10LL, "SSD Idx: 0x%X SID: 0x%X", (unsigned int)v14, HIDWORD(v14));
                qtiseclib_cb_log(10LL, "MID: 0x%X AVMID: 0x%X", (unsigned int)v15, HIDWORD(v15));
                qtiseclib_cb_log(10LL, "ATID: 0x%X ABID: 0x%X APID: 0x%X", (unsigned int)v16, HIDWORD(v16), v17);
                vmidmt_ClearError(v10, 1);
              }
              else
              {
                qtiseclib_cb_log(10LL, "VMIDMT ERROR: VMIDMT %d reported no error!!", v9);
              }
            }
          }
          v8 += 2;
        }
        while ( v8 != (char *)&unk_16BF1 );
      }
    }
    while ( v6 <= 0x1F );
  }
  return a3;
}



__int64 __fastcall vmidmt_map_multisid_vmid_internal(unsigned __int8 a1)
{
  int v1; // w7
  unsigned int v2; // w8
  __int64 v3; // x9
  unsigned int v4; // w10
  char v5; // w11
  int v6; // w12
  __int64 Info_index; // x19
  int **v8; // x19
  int v9; // w0
  unsigned int v10; // w1
  __int64 v12[2]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v13; // [xsp+38h] [xbp+38h]
  __int64 v14[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v15; // [xsp+50h] [xbp+50h]
  int v16; // [xsp+58h] [xbp+58h]

  v14[0] = 0LL;
  v14[1] = 0LL;
  v12[0] = 0LL;
  v12[1] = 0LL;
  v13 = 0LL;
  v15 = 0LL;
  v16 = 0;
  Info_index = (unsigned __int8)vmidmt_getInfo_index(a1);
  if ( v1 != 255 )
  {
    BYTE4(v15) = v1;
    LODWORD(v15) = 1;
  }
  if ( v6 )
    LODWORD(v14[0]) = 2;
  v12[0] = (__int64)v14;
  v8 = (int **)&g_vmidmt_info_cfg[24 * Info_index + 8];
  LOBYTE(v13) = v5;
  v9 = vmidmt_ConfigVmidCtxtWithSIDList((__int64)v8, v2, v3, v4, v12);
  v10 = -1;
  if ( !v9 )
  {
    vmidmt_EnableClientP(v8, 1);
    vmidmt_EnableClientP(v8, 0);
    return 0;
  }
  return v10;
}



__int64 __fastcall vmidmt_map_vmid_internal(unsigned __int8 a1)
{
  int v1; // w7
  unsigned int v2; // w8
  char v3; // w9
  int v4; // w10
  __int64 Info_index; // x19
  int **v6; // x19
  int v7; // w0
  unsigned int v8; // w1
  __int64 v10[2]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v11; // [xsp+38h] [xbp+38h]
  __int64 v12[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v13; // [xsp+50h] [xbp+50h]
  int v14; // [xsp+58h] [xbp+58h]

  v12[0] = 0LL;
  v12[1] = 0LL;
  v10[0] = 0LL;
  v10[1] = 0LL;
  v11 = 0LL;
  v13 = 0LL;
  v14 = 0;
  Info_index = (unsigned __int8)vmidmt_getInfo_index(a1);
  if ( v1 != 255 )
  {
    BYTE4(v13) = v1;
    LODWORD(v13) = 1;
  }
  if ( v4 )
    LODWORD(v12[0]) = 2;
  v10[0] = (__int64)v12;
  LOBYTE(v11) = v3;
  v6 = (int **)&g_vmidmt_info_cfg[24 * Info_index + 8];
  v7 = vmidmt_ConfigVmidCtxt((__int64)v6, v2, v10);
  v8 = -1;
  if ( !v7 )
  {
    vmidmt_EnableClientP(v6, 1);
    vmidmt_EnableClientP(v6, 0);
    return 0;
  }
  return v8;
}



__int64 vmidmt_register_interrupts()
{
  int v0; // w20
  int v1; // w20
  int v2; // w21
  __int64 result; // x0

  v0 = int_svc_register_isr(
         230,
         (__int64)"VMIDMT CTL Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_clt_sec_ctx);
  v1 = v0 | int_svc_register_isr(
              231,
              (__int64)"VMIDMT CTL NSec",
              0x10uLL,
              (__int64)vmidmt_error_handler,
              (__int64)&vmidmt_err_clt_nonsec_ctx);
  v2 = int_svc_register_isr(
         232,
         (__int64)"VMIDMT CFG Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_cfg_sec_ctx);
  result = v2 | (unsigned int)int_svc_register_isr(
                                233,
                                (__int64)"VMIDMT CFG NSec",
                                0x10uLL,
                                (__int64)vmidmt_error_handler,
                                (__int64)&vmidmt_err_cfg_nonsec_ctx) | v1;
  MEMORY[0x1FC5040] = -1;
  MEMORY[0x1FC3040] = -1;
  MEMORY[0x1FC4050] = -1;
  MEMORY[0x1FC2050] = -1;
  return result;
}






__int64 __fastcall write_output_payload_word(__int64 result, int a2)
{
  *(_DWORD *)(result + ((*(_DWORD *)(result + 20) - 1) & 0xFFFFFFFC) + 28) = a2;
  *(_DWORD *)(result + 20) += 4;
  return result;
}



__int64 __fastcall write_output_payload_word_at_offset(__int64 result, int a2, int a3)
{
  *(_DWORD *)(result + 4LL * a3 + 28) = a2;
  *(_DWORD *)(result + 20) += 4;
  return result;
}



__int64 __fastcall XpuEnableDomains(int **a1)
{
  int *v1; // x0
  int v2; // w1

  v1 = *a1;
  if ( !*v1 )
  {
    v2 = 1;
    if ( HIWORD(v1[255]) > 0x3002u )
    {
      v1[256] = 1;
      v2 = 3;
    }
    *v1 = v2;
    v1[4] = 271;
    v1[36] = 271;
    v1[32] = v2;
    v1[68] = 271;
    v1[64] = v2;
  }
  return 0LL;
}



__int64 __fastcall XpuLockDownAssetDynamically(__int64 a1, unsigned __int8 a2, int a3, int a4, int a5, int a6)
{
  __int64 v9; // x1
  __int64 v10; // x19
  __int64 result; // x0
  char v12; // w0

  v9 = a1 + 48LL * a2;
  do
  {
    if ( a1 == v9 )
      return 0xFFFFFFFFLL;
    v10 = a1;
    a1 += 48LL;
  }
  while ( *(_DWORD *)(a1 - 8) != a3 );
  if ( (*(_DWORD *)(v10 + 44) & 2) == 0 )
  {
    result = XpuEnableDomains((int **)v10);
    if ( (_DWORD)result )
      return result;
    *(_DWORD *)(v10 + 44) |= 2u;
  }
  cpuss_dmb();
  cpuss_isb();
  if ( (unsigned __int8)ACQCGetxPUType(v10) != 2
    || (result = XpuProgramMPUPartitions((_QWORD *)v10, a4), !(_DWORD)result) )
  {
    cpuss_dmb();
    cpuss_isb();
    result = XpuSetRGOwnership((_QWORD *)v10, a4);
    if ( !(_DWORD)result )
    {
      v12 = ACQCGetxPUType(v10);
      if ( v12 != 2 || (result = XpuProgramMPUPartitionsDynamicPerm((_QWORD *)v10, a4, a5, a6), !(_DWORD)result) )
      {
        cpuss_dmb();
        cpuss_isb();
        return 0LL;
      }
    }
  }
  return result;
}



__int64 __fastcall XpuLockDownAssets(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 result; // x0

  v2 = a1;
  v3 = a1 + 48LL * a2;
  while ( v2 != v3 )
  {
    if ( (*(_DWORD *)(v2 + 44) & 1) != 0 )
    {
      result = XpuEnableDomains((int **)v2);
      if ( (_DWORD)result )
        return result;
      cpuss_dmb();
      cpuss_isb();
      *(_DWORD *)(v2 + 44) |= 2u;
      if ( (unsigned __int8)ACQCGetxPUType(v2) == 2 )
      {
        result = XpuProgramMPUPartitions((_QWORD *)v2, 0xFFFFFF);
        if ( (_DWORD)result )
          return result;
      }
      cpuss_dmb();
      cpuss_isb();
      result = XpuSetRGOwnership((_QWORD *)v2, 0xFFFFFF);
      if ( (_DWORD)result )
        return result;
      if ( (unsigned __int8)ACQCGetxPUType(v2) == 2 )
      {
        result = XpuProgramMPUPartitionsPerm((_QWORD *)v2, 0xFFFFFF);
        if ( (_DWORD)result )
          return result;
      }
    }
    v2 += 48LL;
  }
  cpuss_dsb();
  cpuss_isb();
  return 0LL;
}



__int64 __fastcall XpuMasterMPuInit(__int64 a1, unsigned int a2)
{
  unsigned __int8 *v2; // x4
  unsigned __int8 *v3; // x6
  unsigned int v4; // w12
  __int64 v5; // x10
  unsigned int v6; // w7
  unsigned int v7; // w11
  int v8; // w3
  int **v9; // x0
  unsigned __int64 v10; // x9
  unsigned int v11; // w8
  int v12; // w2
  unsigned int v13; // w13
  __int64 v14; // x1
  unsigned __int64 v15; // x8
  unsigned int v16; // w1
  int i; // w3
  unsigned int v18; // w9
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x15
  __int64 result; // x0
  __int64 v22; // x5

  v2 = (unsigned __int8 *)(a1 + 4);
  v3 = (unsigned __int8 *)(a1 + 16LL * a2 + 4);
  v4 = 24;
  v5 = 0xFFFFFFFFLL;
  while ( v2 != v3 )
  {
    v6 = 0;
    v7 = 48;
    while ( v6 < *v2 )
    {
      v8 = *((unsigned __int16 *)v2 + 1);
      v9 = (int **)(*(_QWORD *)(v2 + 4) + v6 * (unsigned __int64)v7);
      v10 = (unsigned __int64)v9[1];
      v11 = v10 - v8;
      v12 = (HIWORD((*v9)[254]) & 0x3FF) - v8 + 1;
      while ( 1 )
      {
        v13 = v11 + v12;
        if ( v10 <= v11 )
          break;
        v14 = 4LL * v11++;
        *(_QWORD *)&v9[2][v14] = v8 - (_DWORD)v10 + v13;
      }
      v15 = (unsigned __int64)v9[3];
      v16 = v15 - v8;
      for ( i = v8 - v15; ; *(_DWORD *)v20 = i + v18 )
      {
        v18 = v16 + v12;
        if ( v15 <= v16 )
          break;
        v19 = v16++ * (unsigned __int64)v4;
        v20 = (unsigned __int64)v9[4] + v19;
        *(_QWORD *)(v20 + 8) = v5;
        *(_QWORD *)(v20 + 16) = v5;
      }
      if ( (*((_DWORD *)v9 + 11) & 2) == 0 )
      {
        result = XpuEnableDomains(v9);
        if ( (_DWORD)result )
          return result;
        *(_DWORD *)(*(_QWORD *)(v2 + 4) + v22 + 44) |= 2u;
      }
      ++v6;
    }
    v2 += 16;
  }
  return 0LL;
}



__int64 __fastcall XpuProgramMPUPartitions(_QWORD *a1, int a2)
{
  __int64 v2; // x5
  __int64 i; // x2
  __int64 v4; // x3
  __int64 v5; // x6
  unsigned __int64 v6; // x3

  v2 = 24LL * a1[3];
  for ( i = 0LL; i != v2; i += 24LL )
  {
    v4 = a1[4];
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(v4 + i) )
    {
      v5 = v4 + i;
      v6 = ((unsigned __int64)(*(_DWORD *)(v4 + i) & 0x1FFFFFF) << 7) + *a1;
      *(_QWORD *)(v6 + 4144) = *(_QWORD *)(v5 + 8);
      *(_QWORD *)(v6 + 4152) = *(_QWORD *)(v5 + 16);
    }
  }
  return 0LL;
}



__int64 __fastcall XpuProgramMPUPartitionsDynamicPerm(_QWORD *a1, int a2, int a3, int a4)
{
  __int64 v4; // x6
  __int64 i; // x4
  __int64 v6; // x5
  unsigned __int64 v7; // x5

  v4 = 24LL * a1[3];
  for ( i = 0LL; i != v4; i += 24LL )
  {
    v6 = a1[4];
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(v6 + i) )
    {
      v7 = ((unsigned __int64)(*(_DWORD *)(v6 + i) & 0x1FFFFFF) << 7) + *a1;
      *(_DWORD *)(v7 + 4116) = a3;
      *(_DWORD *)(v7 + 4124) = a4;
    }
  }
  return 0LL;
}



__int64 __fastcall XpuProgramMPUPartitionsPerm(_QWORD *a1, int a2)
{
  __int64 v2; // x4
  __int64 i; // x2
  _DWORD *v4; // x5
  _DWORD *v5; // x3
  _DWORD *v6; // x1
  _DWORD *v7; // x0

  v2 = a1[3];
  for ( i = 0LL; v2 != i; ++i )
  {
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(a1[4] + 24 * i) )
    {
      v4 = (_DWORD *)(a1[2] + 16 * i);
      if ( *v4 != 16777214 )
      {
        if ( *((_QWORD *)v4 + 1) )
        {
          v5 = (_DWORD *)(((unsigned __int64)(*(_DWORD *)(a1[4] + 24 * i) & 0x1FFFFFF) << 7) + *a1);
          v5[1029] = v4[2];
          v5[1031] = v4[3];
          if ( (v4[2] & 0x101) != 0 )
            v5[1028] = 1;
          if ( (v4[3] & 0x101) != 0 )
            v5[1030] = 1;
        }
      }
    }
  }
  v6 = (_DWORD *)(a1[2] + 16 * v2);
  if ( *v6 == 16777214 && *((_QWORD *)v6 + 1) )
  {
    v7 = (_DWORD *)*a1;
    v7[197] = v6[2];
    v7[199] = v6[3];
    if ( (v6[2] & 0x101) != 0 )
      v7[196] = 1;
    if ( (v6[3] & 0x101) != 0 )
      v7[198] = 1;
  }
  return 0LL;
}



__int64 xpu_register_interrupts()
{
  int v0; // w20

  v0 = int_svc_register_isr(227, (__int64)"SPI XPU Sec", 0xCuLL, (__int64)msm_xpu_isr, (__int64)&xpu_err_sec_ctx);
  return v0 | (unsigned int)int_svc_register_isr(
                              228,
                              (__int64)"SPI XPU NonSec",
                              0xCuLL,
                              (__int64)msm_xpu_isr,
                              (__int64)&xpu_err_non_sec_ctx);
}



__int64 __fastcall XpuSetRGOwnership(_QWORD *a1, int a2)
{
  __int64 v2; // x6
  __int64 i; // x3
  int *v4; // x5
  int v5; // w2

  v2 = a1[1];
  for ( i = 0LL; v2 != i; ++i )
  {
    v4 = (int *)(a1[2] + 16 * i);
    v5 = *v4;
    if ( *v4 == 16777214 )
    {
      *(_DWORD *)(*a1 + 768LL) = v4[1];
    }
    else if ( v5 == a2 || a2 == 0xFFFFFF )
    {
      *(_DWORD *)(*a1 + 4096LL + ((unsigned __int64)(v5 & 0x1FFFFFF) << 7)) = v4[1];
    }
  }
  return 0LL;
}



__int64 xpu_static_config()
{
  unsigned int v0; // w19

  if ( (unsigned int)XpuMasterMPuInit((__int64)&msm_mpu_ranges, 2u) )
    return (unsigned int)-1;
  v0 = XpuLockDownAssets((__int64)&msm_xpu_cfg, msm_xpu_cfg_count);
  if ( v0 )
  {
    return (unsigned int)-1;
  }
  else
  {
    ACTzTargetConfig();
    cpuss_dsb();
    MEMORY[0x1FC2040] = -1;
    MEMORY[0x1FC4040] = -1;
    MEMORY[0x1FC2044] = -1;
    MEMORY[0x1FC4044] = -1;
  }
  return v0;
}



