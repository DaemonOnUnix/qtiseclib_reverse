/* This file was generated by the Hex-Rays decompiler version 8.0.0.220729.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall cortex_a78_aarch64_sysini(__int64 result);
void e_1515634_wa();
void e_1875698_wa();
__int64 e_1503072_wa();
__int64 e_1467580_wa();
void e_1688305_wa();
void e_1492189_wa();
void e_1827429_wa();
void e_1821534_wa();
__int64 cortex_a78_amu_enable();
__int64 cortex_a78_amu_disable();
void e_1941498_wa();
__int64 e_1951500_wa();
unsigned __int64 __fastcall qtiseclib_cpuss_reset_asm(int a1);
__int64 qtiseclib_kryo6_gold_reset_asm();
__int64 qtiseclib_kryo6_silver_reset_asm();
unsigned __int64 cpuss_read_isr();
void cpuss_dsb();
void cpuss_dmb();
void cpuss_isb();
unsigned __int64 __fastcall hoya_10_cluster_aarch64_sysini(unsigned __int64 result);
__int64 __fastcall hoya_10_cpuss_aarch64_por_sysini(__int64 result);
__int64 __fastcall hoya_10_interconnect_aarch64_sysini(__int64 result);
unsigned __int64 __fastcall hoya_11_cluster_aarch64_sysini(unsigned __int64 result);
__int64 __fastcall hoya_11_cpuss_aarch64_por_sysini(__int64 result);
unsigned __int64 __fastcall hoya_20_cluster_aarch64_sysini(unsigned __int64 result);
__int64 __fastcall hoya_20_cpuss_aarch64_por_sysini(__int64 result);
unsigned __int64 __fastcall kryo400_gold_aarch64_config_wa_sysini(unsigned __int64 result, int a2);
__int64 __fastcall kryo400_gold_aarch64_sysini(__int64 result);
__int64 __fastcall kryo400_silver_aarch64_sysini(__int64 result);
__int64 __fastcall kryo500_silver_aarch64_sysini(__int64 result);
unsigned __int64 __fastcall cluster_aarch64_sysini(unsigned __int64 result);
__int64 __fastcall cpuss_aarch64_por_sysini(__int64 result);
__int64 __fastcall interconnect_aarch64_sysini(__int64 result);
__int64 __fastcall cpu_aarch64_sysini(__int64 result);
int *__fastcall msm_xpu_isr(__int64 a1, __int64 a2, int *a3);
__int64 xpu_register_interrupts();
__int64 xpu_static_config();
__int64 ac_init();
__int64 __fastcall mem_assign(__int64 *a1, unsigned int a2, __int64 a3, unsigned int a4, int *a5, unsigned int a6);
__int64 __fastcall qtiseclib_mem_assign(__int64 *a1, unsigned int a2, __int64 a3, unsigned int a4, int *a5, unsigned int a6);
__int64 __fastcall vmidmt_getInfo_index(unsigned __int8 a1);
_DWORD *__fastcall vmidmt_error_handler(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall vmidmt_map_vmid_internal(unsigned __int8 a1);
__int64 __fastcall vmidmt_map_multisid_vmid_internal(unsigned __int8 a1);
__int64 vmidmt_config_vmids();
__int64 __fastcall vmidmt_config_options_per_master(int a1);
__int64 vmidmt_config_options();
__int64 vmidmt_register_interrupts();
__int64 vmidmt_config();
__int64 ACTzTargetConfig();
__int64 __fastcall cpucp_clkdom_init(__int64 a1);
__int64 __fastcall Clock_InitImage(__int64 a1);
__int64 Clock_PostInitImage();
__int64 __fastcall Clock_DisableSource(__int64 a1);
__int64 Clock_IsBSPSupported();
__int64 Clock_InitRPMh();
__int64 __fastcall Clock_SetCXVoltage(int a1);
__int64 __fastcall Clock_VoltageRequest(unsigned int a1, unsigned int a2);
__int64 __fastcall Clock_EnableSource(__int64 a1);
__int64 __fastcall Clock_EnableClockDomain(__int64 a1);
__int64 __fastcall Clock_DisableClockDomain(__int64 a1);
__int64 __fastcall Clock_WriteRegRegion(__int64 result);
__int64 Clock_Init();
__int64 Clock_TZInitDone();
__int64 __fastcall Clock_GetClockId(__int64 a1, _QWORD *a2);
__int64 __fastcall Clock_EnableClock(__int64 a1);
__int64 __fastcall Clock_DisableClock(__int64 a1);
__int64 __fastcall Clock_IsClockOn(__int64 a1, _BYTE *a2);
__int64 __fastcall Clock_IsClockPowerDomainOn(__int64 a1, _BYTE *a2);
__int64 __fastcall Clock_SetClockFrequency(__int64 a1, int a2, unsigned int *a3);
__int64 __fastcall Clock_EnableClockGroup(unsigned int a1);
__int64 __fastcall Clock_DisableClockGroup(unsigned int a1);
__int64 Clock_SetRPMAvailable();
__int64 Clock_RPMRequest();
__int64 __fastcall Clock_GetRPMId(__int64 a1, _QWORD *a2);
__int64 __fastcall Clock_EnableDFS(__int64 a1);
__int64 __fastcall Clock_GetFrequencyPlan(__int64 a1, unsigned __int64 *a2, unsigned int *a3);
__int64 __fastcall cmd_db_conv_str_to_unit64(__int64 a1);
__int64 __fastcall cmd_db_query(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall cmd_db_query_addr(__int64 a1);
__int64 __fastcall cmd_db_query_priority(int a1, char a2);
__int64 __fastcall cmd_db_query_priority_res_id(__int64 a1, char a2);
__int64 __fastcall cmd_db_query_version(__int64 a1);
__int64 __fastcall cmd_db_query_len(__int64 a1);
__int64 __fastcall cmd_db_query_aux_data(__int64 a1, _BYTE *a2, __int64 a3);
__int64 __fastcall cmd_db_query_slv_id(__int64 a1);
bool cmd_db_init();
__int64 cmd_db_prep_access(void); // weak
__int64 cmd_db_access_done(void); // weak
__int64 __fastcall cmd_db_target_mem_init(_DWORD *a1);
__int64 cmd_db_tzbsp_init(void); // weak
__int64 __fastcall calculate_cpumasks(__int64 result);
void __fastcall __noreturn sgi15_isr_handler(); // weak
__int64 __fastcall dbg_halt_online_cpus(__int64 result);
void __fastcall __noreturn dbg_err_fatal_handler(unsigned int a1);
void __noreturn nsec_wdt_bite_isr_handler();
__int64 dbg_is_sdi_enable();
__int64 dbg_init();
void __noreturn qtiseclib_panic();
void __fastcall __noreturn dbg_err_fatal(unsigned int a1);
__int64 qtiseclib_is_debug_enabled_secure_io_access();
unsigned __int64 __fastcall HAL_clk_GenericConfigMuxOffs_part_0(unsigned __int64 result, unsigned int *a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6);
__int64 __fastcall HAL_clk_EnableClock(__int64 result);
__int64 __fastcall HAL_clk_DisableClock(__int64 result);
__int64 *__fastcall HAL_clk_EnableSource(__int64 *result);
__int64 __fastcall HAL_clk_DisableSource(__int64 a1);
__int64 __fastcall HAL_clk_IsClockOn(int **a1);
__int64 __fastcall HAL_clk_WaitForClockOn(int **a1);
_DWORD *__fastcall HAL_clk_ConfigClockMux(_DWORD *result, unsigned int *a2);
__int64 __fastcall HAL_clk_EnablePowerDomain(__int64 result);
_DWORD *__fastcall HAL_clk_DisablePowerDomain(_DWORD **a1);
__int64 __fastcall HAL_clk_IsPowerDomainOn(_DWORD **a1);
__int64 __fastcall HAL_clk_WaitForPowerDomainOn(_DWORD **a1);
__int64 __fastcall HAL_clk_EnableDFS(__int64 result);
unsigned __int64 __fastcall HAL_clk_ConfigDFSMux(unsigned __int64 result, __int64 a2);
__int64 __fastcall vmidmt_SetDefaultConfig_isra_0_part_1(unsigned int **a1, __int64 *a2, char a3);
__int64 __fastcall vmidmt_ShiftCtxt_isra_2(__int64 a1, int a2, int a3);
__int64 __fastcall vmidmt_ConfigCtxt_isra_4(__int64 a1, int a2, __int64 *a3);
__int64 __fastcall vmidmt_Init(__int64 *a1, __int64 a2, __int64 *a3);
__int64 __fastcall vmidmt_EnableClientP(int **a1, char a2);
__int64 __fastcall vmidmt_ConfigSSDT(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall vmidmt_ConfigVmidCtxt(__int64 a1, unsigned int a2, __int64 *a3);
__int64 __fastcall vmidmt_ConfigVmidCtxtWithSIDList(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, __int64 *a5);
__int64 __fastcall vmidmt_ConfigErrRep(__int64 a1, char a2, int a3);
bool __fastcall vmidmt_IsError(__int64 *a1, char a2);
__int64 __fastcall vmidmt_GetError(__int64 result, unsigned __int8 a2, _DWORD *a3);
__int64 __fastcall vmidmt_ClearError(__int64 *a1, char a2);
unsigned __int64 __fastcall qtisec_malloc(unsigned __int64 a1);
unsigned __int64 __fastcall qtisec_realloc(__int64 a1, unsigned __int64 a2);
__int64 __fastcall qtisec_free(__int64 a1);
__int64 cpucp_host_handle_irq();
__int64 __fastcall cpucp_host_clock_domain_enable(__int64 a1);
__int64 cpucp_host_error_handler();
__int64 cpucp_host_init();
__int64 cpucp_host_clock_domain_init();
__int64 cpucp_host_clock_domain_disable();
__int64 cpucp_host_send_message();
__int64 cpucp_host_recv_message();
__int64 __fastcall cpucp_iface_initialize(_QWORD *a1);
__int64 icbcfg_init();
__int64 __fastcall get_addr_translation(__int64 a1);
__int64 __fastcall get_device_configuration_isra_0(_QWORD *a1);
__int64 __fastcall get_system_memory_map(__int64 a1, _QWORD *a2);
__int64 __fastcall translate_address(__int64 a1, __int64 a2, _QWORD *a3);
bool __fastcall check_overlap(unsigned __int64 *a1, unsigned __int64 *a2);
__int64 __fastcall compare_ch_segments(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8);
__int64 __fastcall check_dupRegion(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8);
__int64 update_addr_translation();
__int64 __fastcall ICB_Get_Memmap(__int64 a1, _QWORD *a2);
__int64 __fastcall ICB_Get_AllowedMemRegion(__int64 a1, _QWORD *a2);
__int64 __fastcall ICB_Get_MCAddr(__int64 a1, __int64 a2, _QWORD *a3);
unsigned int *__fastcall aggregate_sw_node(unsigned int *result, _QWORD *a2);
__int64 __fastcall add_sw_node_request(int *a1, __int64 a2);
__int64 __fastcall remove_sw_node_request(int *a1, __int64 a2);
__int64 __fastcall remove_client_requests(__int64 a1);
__int64 icbuarb_init();
__int64 __fastcall icbuarb_create_client(int a1, int a2);
__int64 __fastcall icbuarb_issue_request(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall icbuarb_destroy_client(_QWORD *a1);
__int64 __fastcall icbuarb_target_init(__int64 a1);
__int64 icbuarb_target_d4_entry();
__int64 icbuarb_target_d4_exit();
_DWORD *__fastcall inq_create(int a1);
__int64 __fastcall inq_size(__int64 a1);
unsigned int *__fastcall inq_append(unsigned int *result, __int64 a2);
__int64 __fastcall inq_pop(unsigned int *a1);
__int64 __fastcall inq_head(__int64 a1);
__int64 __fastcall inq_it_begin(__int64 a1, _QWORD *a2);
unsigned int **__fastcall inq_it_next(unsigned int **result);
__int64 __fastcall inq_it_deref(__int64 a1);
unsigned int *__fastcall inq_it_insert(unsigned int **a1, __int64 a2);
__int64 __fastcall inq_it_delete(unsigned int **a1);
__int64 __fastcall int_svc_register_isr(int a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall int_svc_unregister_isr(int a1);
__int64 __fastcall qtiseclib_invoke_isr(__int64 a1, __int64 a2);
bool __fastcall int_svc_is_cpu_on(char a1);
__int64 __fastcall int_svc_core_pos_to_mpidr(unsigned int a1);
__int64 __fastcall int_svc_notify_cpu_state(__int64 a1);
__int64 int_svc_init();
__int64 lmh_target_config_init();
__int64 __fastcall lmh_c4_entry(_QWORD); // weak
__int64 __fastcall lmh_c4_exit(_QWORD); // weak
__int64 CPR11_SVSL1_QUOT_VMIN();
__int64 cpucp_prepare();
__int64 cpucp_unprepare();
__int64 cpucp_host_configure_shared_data();
__int64 cpucp_start();
__int64 cpucp_load_firmware();
__int64 __fastcall pdcMap_getInterruptTable(__int64 a1);
__int64 __fastcall pdcMap_getGpioTable(__int64 a1);
__int64 __fastcall mapOS_getInterruptTable(__int64 a1);
__int64 __fastcall mapOS_getGpioTable(__int64 a1);
__int64 __fastcall mem_get_next_block(__int64 a1, __int64 a2);
__int64 __fastcall mem_heap_leave_crit_sect(__int64 a1);
__int64 __fastcall mem_heap_enter_crit_sect(__int64 a1);
__int64 __fastcall mem_init_block_header_isra_0(__int64 a1, int a2);
__int64 __fastcall mem_init_heap(int *a1, __int64 *a2, __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall mem_malloc(__int64 a1, _QWORD *a2, unsigned int a3);
__int64 __fastcall mem_free(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall mem_get_buffer_size(__int64 a1);
unsigned __int64 __fastcall mem_realloc(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4);
__int64 __fastcall NOC_Error_Handle_Interrupt(__int64 a1, __int64 a2, __int64 a3);
__int64 NOC_Error_Init();
void *NOC_Error_Platform_Get_Propdata();
void *NOC_Error_Platform_Get_Propdata_OEM();
__int64 init_system_configuration();
void *pcu_sequencer_target_init();
__int64 get_max_cmd_size();
__int64 __fastcall pcu_config_seq_ctl(__int64 result, int a2, int a3, int a4);
_DWORD *__fastcall pcu_write_cmds(unsigned __int8 a1, int a2);
__int64 __fastcall pcu_node_init(__int64 a1);
__int64 __fastcall pcu_get_node(int a1, _QWORD *a2);
__int64 __fastcall pcu_config_low_power_mode(__int64 *a1, int a2);
__int64 __fastcall pcu_write_seq_memory(__int64 a1, int a2);
__int64 pcu_seq_memory_init();
__int64 pcu_init();
__int64 __fastcall int_findEntry(int a1);
unsigned __int16 *__fastcall gpio_findEntry(int a1, _DWORD *a2);
__int64 __fastcall pdcInt_config(int a1, __int64 a2);
__int64 __fastcall pdcInt_enable(int a1);
__int64 __fastcall pdcInt_disable(int a1);
__int64 __fastcall pdcGpio_unconfig(int a1);
__int64 __fastcall pdcGpio_config(int a1, _DWORD *a2, _DWORD *a3);
__int64 __fastcall pdcGpio_enable(int a1);
__int64 __fastcall pdcGpio_disable(int a1);
__int64 pdc_initialize();
unsigned __int64 __fastcall pdc_getTriggerConfig(int a1, unsigned int a2);
__int64 __fastcall HALInternal_setInterruptState(unsigned int a1, int a2, unsigned __int8 a3);
__int64 __fastcall pdcHAL_enable(unsigned int a1, int a2);
__int64 __fastcall pdcHAL_disable(unsigned int a1, int a2);
__int64 __fastcall pdcHAL_setTriggerConfig(int a1, int a2, _DWORD *a3);
__int64 __fastcall pdcHAL_setGPIOConfig(int a1, __int64 a2, _DWORD *a3);
int *__fastcall pdcHAL_setOwner(int a1, int a2, char a3);
int *pdcOS_initialize();
__int64 __fastcall pdc_seq_handle_env_init(_QWORD *a1);
__int64 __fastcall pdc_seq_hal_enable(__int64 a1, char a2);
__int64 __fastcall pdc_seq_hal_clk_gate_enable(__int64 a1, char a2);
__int64 __fastcall pdc_seq_hal_cfg_wakeup_time(__int64 result, __int64 a2);
__int64 __fastcall pdc_seq_hal_cfg_wakeup_time_ex(__int64 a1, __int64 a2);
__int64 __fastcall pdc_seq_hal_cfg_start_addr(__int64 result, unsigned __int16 a2);
__int64 __fastcall pdc_seq_hal_cfg_start_addr_ex(__int64 a1, unsigned __int8 a2);
__int64 __fastcall pdc_seq_hal_enable_arc_timer(__int64 a1, char a2);
__int64 __fastcall pdc_seq_hal_cfg_pwr_ctl_override(__int64 a1, int a2, int a3);
__int64 __fastcall pdc_seq_hal_cfg_wait_event_override(__int64 a1, int a2, int a3);
__int64 __fastcall pdc_seq_hal_cfg_br_event_override(__int64 a1, int a2, int a3);
__int64 __fastcall pdc_seq_hal_cfg_br_addr(__int64 a1, unsigned __int16 a2, unsigned __int8 a3);
__int64 __fastcall pdc_seq_hal_cfg_delay(__int64 a1, unsigned __int16 a2, int a3);
__int64 __fastcall pdc_seq_hal_profile_ts_count(__int64 a1);
__int64 __fastcall pdc_seq_hal_enable_profile_ts(__int64 a1, unsigned __int8 a2, char a3);
unsigned __int64 __fastcall pdc_seq_hal_profile_ts(__int64 a1, unsigned __int8 a2);
__int64 __fastcall pdc_seq_hal_copy_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4);
__int64 __fastcall pdc_seq_count(unsigned __int8 a1);
__int64 __fastcall pdc_seq_handles(unsigned __int8 a1, unsigned int a2, __int64 a3);
__int64 __fastcall pdc_seq_handle_internal_cfg(__int64 a1);
__int64 __fastcall pdc_seq_copy_cmd_seq(__int64 a1);
__int64 __fastcall pdc_seq_mode_index(__int64 a1, unsigned __int16 a2);
__int64 __fastcall pdc_seq_handle_init(_QWORD *a1);
__int64 __fastcall pdc_seq_enable(__int64 a1, char a2);
__int64 __fastcall pdc_seq_set_wakeup_time(__int64 a1, __int64 a2);
__int64 __fastcall pdc_seq_set_lpm(_QWORD *a1, unsigned __int16 a2);
__int64 __fastcall pdc_seq_profile_ts_count(__int64 a1);
__int64 __fastcall pdc_seq_enable_profile_ts(__int64 a1, unsigned __int8 a2);
__int64 __fastcall pdc_seq_profile_ts(__int64 a1);
__int64 __fastcall pdc_seq_enable_arc_timer(__int64 a1, char a2);
__int64 pdc_seq_sys_init();
__int64 pdc_seq_test();
void *pdc_seq_driver_init();
__int64 __fastcall pdc_seq_handle_target_init(__int64 a1);
__int64 pdcTarget_preInit();
int *pdcTarget_postInit();
__int64 pdcTcs_initialize();
char *__fastcall pdcTcs_getResources(unsigned int a1);
char **pdcTcs_getAllResourceList();
__int64 __fastcall pm_app_ps_hold_cfg(unsigned int a1);
__int64 pm_comm_channel_init_internal();
__int64 __fastcall pm_comm_read_byte(char a1, unsigned __int16 a2, char *a3, unsigned __int8 a4);
__int64 __fastcall pm_comm_read_byte_mask(char a1, unsigned __int16 a2, char a3, char *a4, unsigned __int8 a5);
__int64 __fastcall pm_comm_write_byte(char a1, unsigned __int16 a2, char a3, unsigned __int8 a4);
__int64 __fastcall pm_comm_write_byte_mask(char a1, unsigned __int16 a2, char a3, char a4, unsigned __int8 a5);
__int64 __fastcall pm_comm_write_byte_array(char a1, unsigned __int16 a2, unsigned int a3, char *a4, unsigned __int8 a5);
__int64 __fastcall pm_comm_read_byte_array(char a1, unsigned __int16 a2, unsigned int a3, char *a4, unsigned __int8 a5);
__int64 pm_pon_init();
__int64 __fastcall pm_pon_ps_hold_cfg(unsigned __int8 a1, unsigned int a2);
__int64 __fastcall pm_pon_get_reset_config_val(int a1, char *a2);
__int64 __fastcall pm_pon_gp_reset_cfg(unsigned __int8 a1, int a2, unsigned int a3);
__int64 __fastcall pm_tgt_get_pshold_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3);
__int64 __fastcall pm_tgt_get_pshold_gp1_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3);
__int64 __fastcall pm_pon_tgt_specific_pshold_cfg(unsigned int a1, unsigned int a2);
__int64 pm_version_detect();
__int64 __fastcall pm_get_pmic_model(unsigned __int8 a1);
__int64 __fastcall pm_get_slave_id(unsigned __int8 a1, unsigned __int8 a2, unsigned int *a3);
__int64 __fastcall qtiseclib_psci_init(unsigned __int64 a1);
__int64 __fastcall qtiseclib_psci_node_power_on(__int64 a1);
char **__fastcall qtiseclib_psci_node_on_finish(__int64 a1);
char **__fastcall qtisec_psci_node_down(__int64 a1, unsigned int a2);
char **__fastcall qtiseclib_psci_node_power_off(__int64 a1);
char **__fastcall qtiseclib_psci_node_suspend(__int64 a1);
char **__fastcall qtiseclib_psci_node_suspend_finish(__int64 a1);
void __noreturn qtiseclib_psci_system_off();
void __noreturn qtiseclib_psci_system_reset();
__int64 __fastcall cpu_power_on_finish(__int64 a1, __int64 a2);
__int64 __fastcall cpu_power_on(__int64 a1, __int64 a2);
__int64 __fastcall cpu_init(__int64 a1);
__int64 __fastcall l3_lpm_entry(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall l3_init(__int64 a1);
__int64 __fastcall cpu_lpm_exit(__int64 a1, unsigned __int8 *a2, int a3);
__int64 __fastcall cpu_lpm_entry(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall l3_lpm_exit(__int64 a1, __int64 a2);
__int64 pwr_utils_lvl_init();
__int64 __fastcall pwr_utils_lvl_resource_idx(__int64 a1);
__int64 __fastcall pwr_utils_hlvl(int a1, int a2, char *a3);
__int64 __fastcall pwr_utils_hlvl_named_resource(__int64 a1, int a2, char *a3);
__int64 __fastcall pwr_utils_resource_lvls_count(int a1);
__int64 __fastcall pwr_utils_named_resource_lvls_count(__int64 a1);
__int64 __fastcall pwr_utils_vlvl(int a1, int a2);
__int64 __fastcall pwr_utils_vlvl_named_resource(__int64 a1, int a2);
void __fastcall __noreturn qtisec_assert(const char *a1, unsigned int a2, const char *a3);
void (*qtiseclib_bl31_platform_setup())(void);
_DWORD *__fastcall get_cmd_in_progress_isra_1_constprop_3(__int64 a1, _QWORD *a2, int a3);
_QWORD *rpmh_clientq_create();
__int64 __fastcall rpmh_client_handle_add(unsigned int **a1);
__int64 __fastcall rpmh_client_command_add(__int64 a1);
__int64 __fastcall check_for_events(__int64 a1, int a2);
__int64 __fastcall rpmh_client_command_remove(__int64 a1, int a2);
__int64 __fastcall rpmh_client_command_finish(__int64 a1, int a2);
__int64 __fastcall rpmh_client_wait_on_cmd(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4);
__int64 rpmh_epcb_timeout();
int *__fastcall set_g_cmd_set_single(int a1, int a2, char a3, int a4);
__int64 __fastcall add_cmd_set_for_sleep_isra_0_constprop_3(int a1, int a2);
__int64 __fastcall add_rc_for_sleep(int *a1, int a2);
__int64 __fastcall rpmh_wait_for_cmd_constprop_5(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4);
__int64 __fastcall rpmh_create_handle_internal(int a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall rpmh_create_handle_explicit(int a1, __int64 a2);
__int64 __fastcall rpmh_create_handle(int a1, __int64 a2);
__int64 __fastcall rpmh_invalidate_explicit_cmds(__int64 a1);
unsigned int *__fastcall rpmh_find_resource_command(unsigned int a1);
unsigned int *__fastcall get_rc(unsigned int a1);
__int64 __fastcall add_explicit_cmd_set_for_sleep(int a1, int a2);
__int64 __fastcall rpmh_churn_all(__int64 a1, unsigned int a2);
__int64 __fastcall rpmh_churn_single(__int64 a1, unsigned int a2);
__int64 __fastcall rpmh_barrier_all(_QWORD, _QWORD); // weak
__int64 __fastcall rpmh_barrier_single(_QWORD, _QWORD); // weak
__int64 __fastcall rpmh_finish_amc_internal(int a1, unsigned __int8 a2);
__int64 __fastcall rpmh_finish_amc(int a1);
__int64 __fastcall rpmh_issue_command_set_internal(__int64 a1, unsigned int *a2, unsigned __int8 a3);
__int64 __fastcall rpmh_issue_command_set(__int64 a1, unsigned int *a2);
__int64 __fastcall rpmh_issue_command(__int64 a1, int a2, char a3, int a4, int a5);
__int64 __fastcall rpmh_enter_sleep(int a1);
__int64 __fastcall rpmh_exit_sleep(int a1);
__int64 __fastcall rpmh_get_wake_latency(int a1);
void rpmh_client_init();
__int64 __fastcall rpmh_clean_cmd(_QWORD *a1, unsigned int a2);
__int64 __fastcall rpmh_cmdq_create(unsigned int a1);
__int64 __fastcall rpmh_cmdq_send_cmd_set(unsigned int *a1, int *a2, _DWORD *a3);
unsigned int *__fastcall cmdq_finish_cmd(__int64 a1, __int64 a2, int a3, __int64 a4, int a5);
bool __fastcall cmdq_empty(__int64 a1);
__int64 __fastcall cmdq_num_in_flight(__int64 a1);
__int64 __fastcall rpmh_cmdq_send_cmd_at_head(__int64 a1);
__int64 rpmh_create_dal_event();
unsigned int *__fastcall rpmh_destroy_dal_event(__int64 a1);
__int64 rpmh_os_init(void); // weak
__int64 __fastcall rpmh_clock_toggle(_QWORD, _QWORD); // weak
__int64 rpmh_lock();
__int64 rpmh_unlock();
__int64 is_rpmh_busy();
__int64 __fastcall rpmh_core_verify(__int64 result);
__int64 __fastcall rpmh_core_verify_ptr(__int64 result);
void __fastcall __noreturn rpmh_err_fatal(_QWORD); // weak
void *__fastcall rpmh_register_isr(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 rpmh_deregister_isr(void); // weak
__int64 rpmh_get_timestamp(void); // weak
__int64 __fastcall rpmh_clz(int a1);
unsigned __int64 __fastcall rpmh_malloc(unsigned int a1);
unsigned __int64 __fastcall rpmh_realloc(__int64 a1, unsigned int a2);
__int64 __fastcall resource_command_dirty_update_isra_0(__int64 result);
__int64 __fastcall rpmh_resource_command_init(_DWORD *a1, int a2);
unsigned __int64 __fastcall rpmh_resource_command_get_voter(__int64 a1, int a2);
__int64 __fastcall rpmh_resource_command_get_priority(__int64 a1, int a2);
unsigned __int64 __fastcall resource_command_sets_dirty(__int64 a1, int a2);
bool __fastcall rpmh_resource_command_update(__int64 a1, unsigned int a2, int a3, int a4, unsigned __int8 a5);
__int64 __fastcall rpmh_resource_command_exit_sleep(__int64 a1, int a2);
__int64 __fastcall rpmh_resource_command_val_at_rpmh(unsigned int a1, int a2, unsigned int a3, unsigned __int8 a4);
__int64 __fastcall rpmh_resource_command_finish(unsigned int a1, int a2);
__int64 __fastcall tcs_update_mode(unsigned int a1, unsigned int a2);
__int64 tcs_init();
__int64 __fastcall drv_valid(int a1);
__int64 __fastcall lookup_drv_index(int a1);
__int64 __fastcall get_finished_amc(int a1);
__int64 __fastcall tcs_clean_up(__int64 a1, unsigned __int8 *a2, int a3, int a4);
__int64 __fastcall tcs_send_internal(__int64 a1, int a2, unsigned int a3);
__int64 __fastcall is_tcs_stuck(int a1);
__int64 __fastcall tcs_size(int a1);
__int64 __fastcall tcs_slots_available(int a1, int a2, unsigned int a3);
__int64 __fastcall tcs_prepare_sleep_add_cmd_set(int *a1, int a2);
__int64 __fastcall is_amc_free(int a1);
bool __fastcall is_amc_finished(int a1);
__int64 __fastcall get_finished_drv(int a1);
__int64 __fastcall tcs_finish_amc(__int64 a1, int a2, int a3);
__int64 __fastcall tcs_finish_active_amc(_QWORD *a1, __int64 a2, int a3);
__int64 __fastcall tcs_send(__int64 a1, int a2);
__int64 __fastcall tcs_clean_sleep_wake(int a1);
__int64 __fastcall tcs_prepare_sleep_commit(int a1);
__int64 __fastcall isContextInitialized(_BYTE *a1, unsigned int a2);
char *rscHalGetContext();
__int64 __fastcall rscHalGetNumTcs(unsigned __int64 a1, char a2, _DWORD *a3);
__int64 __fastcall rscHalGetNumCmdsPerTcs(__int64 a1, unsigned __int8 a2, _DWORD *a3);
__int64 __fastcall rscHalGetDrvInfo(__int64 a1);
__int64 __fastcall rscHalGetChipsetMappingTable(__int64 a1);
__int64 __fastcall RscHalRegisterDrv(unsigned int a1);
__int64 __fastcall RscHalVersionID(unsigned int a1, int *a2);
__int64 __fastcall RscHalReadConfig(unsigned int a1, _DWORD *a2, _DWORD *a3);
__int64 __fastcall RscHalIsePCBTimedOut(unsigned int a1, _BYTE *a2);
__int64 __fastcall RscHalClearePCBTimedOut(unsigned int a1);
__int64 __fastcall RscHalToggleePCBTimeOut(unsigned int a1, char a2);
__int64 __fastcall RscHalUpdateePCBTimeOutThreshold(unsigned int a1, unsigned __int16 a2);
__int64 __fastcall RscHalIsTCSIdle(unsigned int a1, unsigned __int8 a2, _BYTE *a3);
__int64 __fastcall RscHalTriggerTCS(unsigned int a1, unsigned __int8 a2);
__int64 __fastcall RscHalConvertTCStoAMC(unsigned int a1, unsigned __int8 a2);
__int64 __fastcall RscHalConvertAMCtoTCS(unsigned int a1, unsigned __int8 a2);
__int64 __fastcall RscHalToggleTCSCmd(unsigned int a1, unsigned __int8 a2, unsigned __int16 a3);
__int64 __fastcall RscHalEnableAMCFinishedIRQ(unsigned int a1, unsigned int a2);
__int64 __fastcall RscHalDisableAMCFinishedIRQ(unsigned int a1, unsigned int a2);
__int64 __fastcall RscHalCheckAMCFinishedIRQ(unsigned int a1, int *a2);
__int64 __fastcall RscHalClearAMCFinishedIRQ(unsigned int a1, unsigned int a2);
__int64 __fastcall RscHalCheckTCSCmdTriggerStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4);
__int64 __fastcall RscHalCheckTCSCmdIssueStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4);
__int64 __fastcall RscHalCheckTCSCmdCompletionStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4);
__int64 __fastcall RscHalReadResponseData(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _DWORD *a4);
__int64 __fastcall RscHalConfigureCmdCompletion(unsigned int a1, unsigned __int8 a2, __int16 a3);
__int64 __fastcall rscHalSetupDrv0Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3);
__int64 __fastcall rscHalSetupDrv2Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3);
__int64 __fastcall RscHalSetupTCS(__int64 a1);
__int64 __fastcall RscHalCheckTCSIdle_HLOS(unsigned int a1);
__int64 __fastcall rsc_init_base_address(__int64 a1);
__int64 __fastcall rsc_hal_get_major_ver(_DWORD *a1);
__int64 __fastcall rsc_hal_get_minor_ver(_DWORD *a1);
__int64 __fastcall rsc_hal_get_step_ver(_DWORD *a1);
__int64 __fastcall rsc_hal_get_solver_cfg(__int64 a1);
unsigned __int64 __fastcall rsc_hal_get_num_drvs(__int64 a1);
__int64 __fastcall rsc_hal_get_num_seq_cmd_words(__int64 a1);
unsigned __int64 __fastcall rsc_hal_get_num_ts_events(__int64 a1);
__int64 __fastcall rsc_hal_get_delay_cntr_bitwidth(__int64 a1);
__int64 __fastcall rsc_hal_get_parentchild_cfg(__int64 a1);
__int64 __fastcall rsc_hal_get_status0(__int64 a1);
__int64 __fastcall rsc_hal_get_status1(__int64 a1);
__int64 __fastcall rsc_hal_get_status2(__int64 a1);
__int64 __fastcall rsc_hal_set_ts_unit_owner(__int64 result, unsigned __int8 a2);
__int64 __fastcall rsc_hal_enable_ts_unit(__int64 result, unsigned __int8 a2, char a3);
__int64 __fastcall rsc_hal_get_ts_unit_l(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_hal_get_ts_unit_h(__int64 a1, unsigned __int8 a2);
unsigned __int64 __fastcall rsc_hal_get_ts_overflow(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_hal_get_ts_valid(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_hal_get_seq_override_start_addr_valid(__int64 a1);
__int64 __fastcall rsc_hal_set_seq_override_start_addr_valid(__int64 result, int a2);
__int64 __fastcall rsc_hal_set_seq_override_start_addr(__int64 result, unsigned __int8 a2);
__int64 __fastcall rsc_hal_set_trigger_seq(__int64 result, unsigned __int8 a2);
__int64 __fastcall rsc_hal_set_trigger_start_address(__int64 result, unsigned __int16 a2);
__int64 __fastcall rsc_hal_seq_busy(__int64 a1);
__int64 __fastcall rsc_hal_get_seq_program_counter(__int64 a1);
__int64 __fastcall rsc_hal_config_br_addr(__int64 result, int a2, unsigned __int16 a3);
__int64 __fastcall rsc_hal_copy_simple_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4);
__int64 __fastcall rsc_hal_copy_extended_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4);
__int64 __fastcall rsc_hal_conf_hidden_tcs_owner(__int64 result, char a2);
__int64 __fastcall rsc_get_count(unsigned __int8 a1);
__int64 __fastcall rsc_get_handles(char a1, int a2, __int64 a3);
__int64 __fastcall rsc_read_id_info(__int64 a1);
__int64 __fastcall rsc_read_internal_config(__int64 result);
__int64 __fastcall rsc_mode_index(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_copy_cmd_seqs(__int64 a1);
__int64 __fastcall rsc_enable_ts_events(__int64 a1, char a2);
__int64 __fastcall rsc_driver_init(_QWORD); // weak
__int64 __fastcall rsc_ts_init(__int64 a1);
__int64 __fastcall rsc_set_low_power_mode(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_program_dyn_cmd_seq(__int64 a1, __int64 a2, __int16 a3, _DWORD *a4);
__int64 __fastcall rsc_trigger_seq(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_get_time_stamp(__int64 a1, unsigned __int8 a2);
__int64 __fastcall rsc_conf_hidden_tcs_ownership(__int64 a1, char a2);
__int64 __fastcall rsc_instance_init(__int64 a1);
void **rsc_target_init();
unsigned int *__fastcall HAL_avs_Enable(unsigned int a1, int a2);
__int64 __fastcall HAL_avs_Ramp_En(unsigned int a1, char a2);
__int64 __fastcall HAL_avs_SetDelay(unsigned int a1, __int16 a2);
__int64 __fastcall HAL_avs_SetClockDivider(unsigned int a1, char a2);
__int64 __fastcall HAL_avs_SetVoltageStepSize(unsigned int a1, int a2, unsigned __int8 a3);
__int64 __fastcall HAL_avs_SetVoltageWidth(unsigned int a1, char a2);
__int64 __fastcall HAL_avs_GetVddSettleTimeUS(int a1, int a2);
__int64 __fastcall HAL_avs_SetVoltage(unsigned int a1, unsigned int a2);
__int64 __fastcall HAL_avs_SetPowerMode(unsigned int a1, int a2);
__int64 __fastcall HAL_avs_SetMaxVoltage(unsigned int a1, int a2);
__int64 __fastcall HAL_avs_SetMinVoltage(unsigned int a1, unsigned __int16 a2);
__int64 __fastcall HAL_avs_EnableCtl(unsigned int a1, unsigned __int8 a2);
__int64 __fastcall HAL_avs_RestoreBootVoltage(unsigned int a1);
__int64 HAL_avs_SecondaryRailInit();
__int64 *HAL_avs_Init();
__int64 __fastcall handle_scmi_base_protocol_msg(__int64 a1);
__int64 __fastcall handle_scmi_clk_mgmt_protocol_msg(__int64 a1);
__int64 __fastcall cpucp_scmi_send(unsigned __int8 a1, unsigned __int8 a2, __int64 a3, unsigned int a4, _DWORD *a5, __int64 a6, unsigned int *a7);
unsigned __int64 __fastcall scmi_construct_msg_hdr(unsigned __int8 a1, char a2, unsigned __int8 a3, __int16 a4);
__int64 __fastcall write_output_payload_word_at_offset(__int64 result, int a2, int a3);
__int64 __fastcall write_output_payload_word(__int64 result, int a2);
__int64 __fastcall get_input_payload_char_at_offset(__int64 a1, int a2);
__int64 __fastcall get_input_payload_word_at_offset(__int64 a1, int a2);
__int64 __fastcall scmi_packet_init_payload(__int64 result);
__int64 __fastcall scmi_process_packet(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall scmi_read_packet(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall scmi_write_packet(__int64 a1);
unsigned __int64 __fastcall set_boot_remap(unsigned __int64 a1);
__int64 sec_core();
void *smmu_init();
__int64 __fastcall debugExecute_part_3(int a1, int a2, char a3, int a4, char *a5, unsigned int a6, __int64 *a7);
__int64 SpmiBus_Init();
__int64 SpmiBus_DeInit();
__int64 __fastcall SpmiBus_ReadLong(char a1, int a2, int a3, char *a4, unsigned int a5, __int64 *a6);
__int64 __fastcall SpmiBus_WriteLong(char a1, int a2, int a3, char *a4, unsigned int a5);
__int64 __fastcall SpmiOs_Init(_QWORD *a1);
__int64 __fastcall SpmiOs_Wait(_QWORD); // weak
_QWORD *__fastcall timer_qtimer_get_frames_list(_QWORD *result, _DWORD *a2);
__int64 timer_qtimer_security_config();
__int64 timer_qtimer_read_time_raw();
unsigned __int64 timer_qtimer_read_time_us();
void __fastcall timer_sec_wdog_start(int a1, int a2);
void timer_sec_wdog_stop();
__int64 timer_sec_wdog_pet();
__int64 __fastcall timer_sec_wdt_bark_handler(int a1, __int64 a2, __int64 a3);
void timer_sec_wdog_init();
__int64 Tlmm_PlatformInit();
__int64 __fastcall XpuEnableDomains(int **a1);
__int64 __fastcall XpuProgramMPUPartitionsPerm(_QWORD *a1, int a2);
__int64 __fastcall XpuProgramMPUPartitionsDynamicPerm(_QWORD *a1, int a2, int a3, int a4);
__int64 __fastcall XpuProgramMPUPartitions(_QWORD *a1, int a2);
__int64 __fastcall XpuSetRGOwnership(_QWORD *a1, int a2);
__int64 __fastcall ACQCGetxPUType(__int64 a1);
__int64 __fastcall XpuLockDownAssets(__int64 a1, unsigned __int8 a2);
__int64 __fastcall XpuMasterMPuInit(__int64 a1, unsigned int a2);
__int64 __fastcall XpuLockDownAssetDynamically(__int64 a1, unsigned __int8 a2, int a3, int a4, int a5, int a6);
__int64 __fastcall msm_xpu_print_log(int *a1);
// __int64 __fastcall qtiseclib_cb_ic_raise_sgi(_QWORD, _QWORD); weak
// __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall qtiseclib_cb_set_spi_routing(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall qtiseclib_cb_strcmp(_QWORD); weak
// __int64 __fastcall handle_scmi_vendor_protocol_msg(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall qtiseclib_cb_plat_core_pos_by_mpidr(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD); weak
// __int64 handle_scmi_perf_dom_mgmt_protocol_msg(void); weak
// __int64 qtiseclib_cb_gic_pcpu_init(void); weak
// __int64 qtiseclib_cb_switch_console_to_crash_state(void); weak
// __int64 __fastcall handle_scmi_unknown_protocol(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_udelay(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_console_flush(_QWORD); weak
// __int64 __fastcall qtiseclib_cb_memmove(_QWORD, _QWORD, _QWORD); weak
// __int64 qtiseclib_cb_log(_QWORD, const char *, ...); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_8; // weak
_UNKNOWN loc_10; // weak
_UNKNOWN loc_18; // weak
_UNKNOWN power_up_sequence; // weak
_UNKNOWN loc_24; // weak
_UNKNOWN loc_28; // weak
_UNKNOWN loc_2C; // weak
_UNKNOWN loc_30; // weak
_UNKNOWN en_dbg_feat; // weak
_UNKNOWN loc_3C; // weak
int SPI_CONFIGURATION_DATA_SDM845 = 49152; // weak
int SPI_CONFIGURATION_DATA_SC7280 = 1146880; // weak
_UNKNOWN g_vmid_map; // weak
_UNKNOWN unk_15EBC; // weak
_UNKNOWN unk_16000; // weak
unsigned __int8 g_vmidmt_cfg[72] =
{
  40u,
  31u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  24u,
  31u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  25u,
  31u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char g_vmidmt_info_cfg_count = '\x03'; // weak
char msm_xpu_cfg_count = '\b'; // weak
void *xpu_non_sec_intr_status_reg = (void *)0x1FC2000LL; // weak
void *xpu_sec_intr_status_reg = (void *)0x1FC4000LL; // weak
_DWORD aClockVRegMapping[8] = { 0, 48, 64, 128, 0, 256, 320, 384 }; // weak
_DWORD pm_pon_pshold_gp1_reset_cfg_arr[36] =
{
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0
}; // weak
_DWORD pm_pon_pshold_reset_cfg_arr[36] =
{
  0,
  15,
  15,
  15,
  15,
  15,
  15,
  4,
  15,
  15,
  15,
  15,
  15,
  15,
  1,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0
}; // weak
_UNKNOWN qtimer_frames; // weak
_UNKNOWN target_info; // weak
_UNKNOWN xpu_err_non_sec_ctx; // weak
_UNKNOWN vmidmt_err_cfg_sec_ctx; // weak
_UNKNOWN vmidmt_err_cfg_nonsec_ctx; // weak
_UNKNOWN acc_ctl; // weak
_UNKNOWN vmidmt_err_clt_nonsec_ctx; // weak
unsigned __int8 g_vmidmt_info_cfg[72] =
{
  40u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  227u,
  1u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  24u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  96u,
  156u,
  0u,
  0u,
  0u,
  0u,
  0u,
  48u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  25u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  96u,
  172u,
  0u,
  0u,
  0u,
  0u,
  0u,
  48u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char byte_16BB1 = '\x02'; // weak
_UNKNOWN unk_16BF1; // weak
_UNKNOWN msm_xpu_cfg; // weak
_UNKNOWN msm_mpu_ranges; // weak
_UNKNOWN xpu_err_pos_to_hal_map; // weak
int g_xpu_base_addr_array_count = 21; // weak
_UNKNOWN g_xpu_base_addr_array; // weak
_UNKNOWN _compound_literal_1_2; // weak
__int64 (__fastcall *ClockDrvCtxt[12])() =
{
  &ClockTZBSPConfig,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  &cortex_a78_aarch64_sysini,
  (__int64 (__fastcall *)())0x200000000LL,
  &cortex_a78_aarch64_sysini,
  (__int64 (__fastcall *)())0x100000000LL,
  &cortex_a78_aarch64_sysini
}; // weak
char byte_1A500 = '\0'; // weak
int dword_1A524 = 0; // weak
__int64 qword_1A528 = 0LL; // weak
int dword_1A530 = 0; // weak
int dword_1A534 = 0; // weak
unsigned int dword_1A538[3] = { 0u, 2u, 0u }; // weak
int dword_1A544 = 0; // weak
int dword_1A548 = 0; // weak
int dword_1A550 = 0; // weak
int dword_1A554 = 0; // weak
_DWORD clkdom_init_status[4] = { 1, 1, 0, 0 }; // weak
_UNKNOWN clkdom_cpumasks; // weak
int dword_1A61C = 0; // weak
int dword_1A624 = 15; // weak
int dword_1A62C = 112; // weak
int dword_1A634 = 128; // weak
char first_time_1190 = '\x01'; // weak
char *dbg_err_fatal_str[6] =
{
  "None Error",
  "BL31 Error : PANIC",
  "BL31 Error : NS_WDT_BITE",
  "BL31 Error : NOC_ERROR",
  "BL31 Error : AC_ERROR",
  "BL31 Error : ASSERT"
}; // weak
_WORD g_pdcGpioInputs[196] =
{
  145,
  -1,
  0,
  -1,
  112,
  -1,
  39,
  -1,
  86,
  -1,
  48,
  -1,
  91,
  -1,
  34,
  -1,
  12,
  -1,
  15,
  -1,
  16,
  -1,
  18,
  -1,
  20,
  -1,
  21,
  -1,
  55,
  -1,
  43,
  -1,
  24,
  -1,
  150,
  -1,
  151,
  -1,
  153,
  -1,
  31,
  -1,
  0,
  -1,
  35,
  -1,
  11,
  -1,
  130,
  -1,
  25,
  -1,
  102,
  -1,
  40,
  -1,
  41,
  -1,
  23,
  -1,
  44,
  -1,
  45,
  -1,
  47,
  -1,
  7,
  -1,
  63,
  -1,
  78,
  -1,
  79,
  -1,
  22,
  -1,
  56,
  -1,
  0,
  -1,
  59,
  -1,
  60,
  -1,
  51,
  -1,
  142,
  -1,
  104,
  -1,
  141,
  -1,
  103,
  -1,
  54,
  -1,
  80,
  -1,
  81,
  -1,
  158,
  -1,
  4,
  -1,
  83,
  -1,
  143,
  -1,
  89,
  -1,
  77,
  -1,
  101,
  -1,
  92,
  -1,
  93,
  -1,
  156,
  -1,
  145,
  -1,
  3,
  -1,
  148,
  -1,
  75,
  -1,
  0,
  -1,
  116,
  -1,
  161,
  -1,
  119,
  -1,
  121,
  -1,
  123,
  -1,
  125,
  -1,
  127,
  -1,
  163,
  -1,
  129,
  -1,
  32,
  -1,
  131,
  -1,
  133,
  -1,
  136,
  -1,
  140,
  -1,
  90,
  -1,
  72,
  -1,
  0,
  -1,
  0,
  -1,
  0,
  -1,
  88,
  -1,
  8,
  -1,
  52,
  -1,
  36,
  -1,
  27,
  -1,
  28,
  -1,
  95,
  -1,
  157,
  -1,
  82,
  -1,
  117,
  -1,
  167,
  -1,
  128,
  -1,
  172,
  -1,
  174,
  -1
}; // weak
_UNKNOWN magic_num; // weak
void **off_1A820 = &configs_kodiak; // weak
_DWORD g_pdcInterruptMapping[210] =
{
  2,
  2,
  512,
  2,
  2,
  513,
  2,
  2,
  514,
  2,
  0,
  515,
  2,
  0,
  516,
  2,
  0,
  517,
  2,
  2,
  518,
  2,
  2,
  519,
  2,
  2,
  520,
  2,
  2,
  521,
  2,
  2,
  522,
  2,
  2,
  523,
  2,
  2,
  524,
  2,
  2,
  525,
  2,
  2,
  526,
  2,
  2,
  527,
  2,
  2,
  528,
  2,
  2,
  529,
  2,
  2,
  530,
  2,
  2,
  531,
  2,
  2,
  532,
  2,
  2,
  533,
  2,
  2,
  534,
  2,
  2,
  535,
  2,
  2,
  536,
  2,
  2,
  537,
  2,
  2,
  538,
  2,
  2,
  539,
  2,
  2,
  540,
  2,
  2,
  541,
  2,
  2,
  542,
  2,
  2,
  543,
  2,
  2,
  544,
  2,
  2,
  545,
  2,
  2,
  546,
  2,
  2,
  547,
  2,
  2,
  548,
  2,
  2,
  549,
  2,
  2,
  550,
  2,
  2,
  551,
  2,
  2,
  172,
  2,
  2,
  173,
  2,
  2,
  174,
  2,
  2,
  175,
  2,
  2,
  176,
  2,
  2,
  177,
  2,
  2,
  178,
  2,
  2,
  179,
  2,
  2,
  180,
  2,
  2,
  181,
  2,
  2,
  182,
  2,
  2,
  183,
  2,
  2,
  184,
  2,
  2,
  185,
  2,
  2,
  295,
  2,
  2,
  338,
  2,
  2,
  339,
  2,
  2,
  340,
  2,
  2,
  341,
  2,
  2,
  344,
  2,
  2,
  345,
  2,
  2,
  346,
  2,
  2,
  406,
  2,
  2,
  407,
  2,
  2,
  466,
  2,
  2,
  467,
  2,
  2,
  470,
  2,
  2,
  471,
  2,
  2,
  472,
  2,
  2,
  118
}; // weak
char lmh_enable = '\x01'; // weak
_QWORD g_pdcGpioMapping[294] =
{
  8589934594LL,
  0LL,
  552LL,
  8589934594LL,
  0LL,
  553LL,
  8589934594LL,
  0LL,
  554LL,
  8589934594LL,
  0LL,
  555LL,
  8589934594LL,
  0LL,
  556LL,
  8589934594LL,
  0LL,
  557LL,
  8589934594LL,
  0LL,
  558LL,
  8589934594LL,
  0LL,
  559LL,
  8589934594LL,
  0LL,
  560LL,
  8589934594LL,
  0LL,
  561LL,
  8589934594LL,
  0LL,
  562LL,
  8589934594LL,
  0LL,
  563LL,
  8589934594LL,
  0LL,
  564LL,
  8589934594LL,
  0LL,
  565LL,
  8589934594LL,
  0LL,
  566LL,
  8589934594LL,
  0LL,
  567LL,
  8589934594LL,
  0LL,
  568LL,
  8589934594LL,
  0LL,
  569LL,
  8589934594LL,
  0LL,
  570LL,
  8589934594LL,
  0LL,
  571LL,
  8589934594LL,
  0LL,
  572LL,
  8589934594LL,
  0LL,
  573LL,
  8589934594LL,
  0LL,
  574LL,
  8589934594LL,
  0LL,
  575LL,
  8589934594LL,
  0LL,
  576LL,
  8589934594LL,
  0LL,
  577LL,
  8589934594LL,
  0LL,
  578LL,
  8589934594LL,
  0LL,
  579LL,
  8589934594LL,
  0LL,
  580LL,
  8589934594LL,
  0LL,
  581LL,
  8589934594LL,
  0LL,
  582LL,
  8589934594LL,
  0LL,
  583LL,
  8589934594LL,
  0LL,
  584LL,
  8589934594LL,
  0LL,
  585LL,
  8589934594LL,
  0LL,
  586LL,
  8589934594LL,
  0LL,
  587LL,
  8589934594LL,
  0LL,
  588LL,
  8589934594LL,
  0LL,
  589LL,
  8589934594LL,
  0LL,
  590LL,
  8589934594LL,
  0LL,
  591LL,
  8589934594LL,
  0LL,
  592LL,
  8589934594LL,
  0LL,
  593LL,
  8589934594LL,
  0LL,
  594LL,
  8589934594LL,
  0LL,
  595LL,
  8589934594LL,
  0LL,
  596LL,
  8589934594LL,
  0LL,
  597LL,
  8589934594LL,
  0LL,
  598LL,
  8589934594LL,
  0LL,
  599LL,
  8589934594LL,
  0LL,
  600LL,
  8589934594LL,
  0LL,
  601LL,
  8589934594LL,
  0LL,
  602LL,
  8589934594LL,
  0LL,
  603LL,
  8589934594LL,
  0LL,
  604LL,
  8589934594LL,
  0LL,
  605LL,
  8589934594LL,
  0LL,
  641LL,
  8589934594LL,
  0LL,
  642LL,
  8589934594LL,
  0LL,
  643LL,
  8589934594LL,
  0LL,
  644LL,
  8589934594LL,
  0LL,
  645LL,
  8589934594LL,
  0LL,
  646LL,
  8589934594LL,
  0LL,
  647LL,
  8589934594LL,
  0LL,
  648LL,
  8589934594LL,
  0LL,
  649LL,
  8589934594LL,
  0LL,
  650LL,
  8589934594LL,
  0LL,
  651LL,
  8589934594LL,
  0LL,
  652LL,
  8589934594LL,
  0LL,
  653LL,
  8589934594LL,
  0LL,
  654LL,
  8589934594LL,
  0LL,
  655LL,
  8589934594LL,
  0LL,
  656LL,
  8589934594LL,
  0LL,
  657LL,
  8589934594LL,
  0LL,
  658LL,
  8589934594LL,
  0LL,
  659LL,
  8589934594LL,
  0LL,
  660LL,
  8589934594LL,
  0LL,
  661LL,
  8589934594LL,
  0LL,
  662LL,
  8589934594LL,
  0LL,
  663LL,
  8589934594LL,
  0LL,
  664LL,
  8589934594LL,
  0LL,
  665LL,
  8589934594LL,
  0LL,
  666LL,
  8589934594LL,
  0LL,
  667LL,
  8589934594LL,
  0LL,
  668LL,
  8589934594LL,
  0LL,
  669LL,
  8589934594LL,
  0LL,
  670LL,
  8589934594LL,
  0LL,
  671LL,
  8589934594LL,
  0LL,
  95LL,
  8589934594LL,
  0LL,
  748LL,
  8589934594LL,
  0LL,
  749LL,
  8589934594LL,
  0LL,
  750LL,
  8589934594LL,
  0LL,
  751LL,
  8589934594LL,
  0LL,
  752LL,
  8589934594LL,
  0LL,
  753LL,
  8589934594LL,
  0LL,
  754LL,
  8589934594LL,
  0LL,
  755LL,
  8589934594LL,
  0LL,
  756LL,
  8589934594LL,
  0LL,
  757LL,
  8589934594LL,
  0LL,
  758LL,
  8589934594LL,
  0LL,
  759LL
}; // weak
void *off_1BFF0 = &_compound_literal_37; // weak
void *off_1C360 = &_compound_literal_25_0; // weak
char *target_pcu_node = "C0"; // weak
void *off_1C6D8 = &silver_pll_pcu_modes; // weak
void *off_1C700 = &goldplus_pll_pcu_modes; // weak
void *off_1C728 = &goldplus_pll_pcu_modes; // weak
void *off_1C750 = &gold_rail_pcu_modes; // weak
_UNKNOWN g_pdc_seq_instances; // weak
int g_pdc_seq_instance_count = 1; // weak
void *off_1CC58 = &g_pdcTCSConfig; // weak
char *off_1CC60 = &g_pdcResourceList; // weak
_UNKNOWN unk_1CC68; // weak
_UNKNOWN unk_1CC6C; // weak
_UNKNOWN pon_gp1_reg; // weak
_UNKNOWN pon_gp2_reg; // weak
char *g_psci_asic_nodes = "C0"; // weak
_UNKNOWN unk_1CD38; // weak
char *resource_list = "cx.lvl"; // weak
__int64 (__fastcall *platform_init_functions[25])() =
{
  &sec_core,
  &timer_qtimer_security_config,
  &timer_sec_wdog_init,
  &icb_error_init,
  &rpmh_client_init,
  &cmd_db_tzbsp_init,
  &pdcTcs_initialize,
  &pdc_seq_sys_init,
  &pwr_utils_lvl_init,
  &icbuarb_init,
  &HAL_avs_Init,
  &Clock_Init,
  &icbcfg_init,
  &Tlmm_Init,
  &HAL_avs_SecondaryRailInit,
  &lmh_config_init,
  &ac_init,
  &smmu_init,
  &dbg_init,
  &Clock_TZInitDone,
  &pdcOS_initialize,
  &int_svc_init,
  &cpucp_start,
  &cpucp_clkdom_init,
  &cortex_a78_aarch64_sysini
}; // weak
char qtisec_build_string[41] = "QC_IMAGE_TS_STRING=23:00:53, May 17 2022"; // weak
char qtisec_variant_string[30] = "IMAGE_VARIANT_STRING=SC7180LC"; // weak
char qtisec_oem_string[39] = "OEM_IMAGE_VERSION_STRING=crm-ubuntu223"; // weak
char qtisec_version_string[66] = "QC_IMAGE_VERSION_STRING=QTISECLIB.CB.1.0-00063-SC7280AAAAAANAZT-2"; // weak
__int64 (__fastcall *rpmh_event_set)(_QWORD) = &rpmh_set_dal_event; // weak
__int64 (*rpmh_event_create)(void) = &rpmh_create_dal_event; // weak
__int64 (__fastcall *rpmh_event_destroy)(_QWORD) = &rpmh_destroy_dal_event; // weak
__int64 (__fastcall *rpmh_event_wait)(_QWORD) = &rpmh_wait_dal_event; // weak
int DrvBaseAddressMappingTable_subsystem = 1; // weak
void *off_1D268 = &DrvBaseAddressMapping_array_subsystem; // weak
__int64 g_rsc_count = 1LL; // weak
void *g_rsc_instances = (void *)0x1000LL; // weak
int initial_dynmode_id_1266 = 15; // weak
char bIsInit_1181 = '\x01'; // weak
_DWORD gHALAVSContext[8] = { 403701760, 824, 824, 19200, 403705856, 852, 852, 19200 }; // weak
int dword_1D6B8 = 1615331344; // weak
_UNKNOWN unk_1DA08; // weak
void *pSpmiBlockInfo = &spmiInfo; // weak
char *g_pdcResourceList = "cx.lvl"; // weak
_UNKNOWN g_pdcTCSConfig; // weak
__int64 g_sec_wdog_last_pet_time = 0LL; // weak
_UNKNOWN xpu_err_sec_ctx; // weak
_UNKNOWN perm_lock_1439; // weak
_UNKNOWN vmidmt_err_clt_sec_ctx; // weak
_UNKNOWN cpucp_clkdom_init_spinlock; // weak
char bSSCGDSCPrevEnabled; // weak
__int64 smem_query_db; // weak
int cmd_db_test_priority; // weak
int dword_1FCBC; // weak
int dword_1FCC0; // weak
int dword_1FCC4; // weak
int cmd_db_test_addr; // weak
int dword_1FCCC; // weak
_UNKNOWN cmd_db_test_data; // weak
__int64 cmd_db_addr; // weak
int g_fatal_err_code; // weak
_UNKNOWN g_dbg_svc_lock; // weak
_UNKNOWN atfHeap; // weak
__int64 mem_magic_number; // weak
__int64 qword_2FD10; // weak
__int16 word_2FD18; // weak
char heapHasInit; // weak
int atfHeapDesc[20]; // weak
_UNKNOWN magic_num_index_array; // weak
__int64 icb_dev_config; // weak
__int64 icb_dev_config_0; // weak
char icb_dev_config_valid; // weak
char query_dev_config_valid; // weak
__int64 addr_trans_segs[]; // weak
char byte_2FDA8; // weak
__int64 rpmh_handle; // weak
__int64 commit_queue; // weak
__int64 info; // weak
__int64 rpmh_wa_handle; // weak
__int64 mm_node; // weak
char initialized; // weak
_QWORD g_mpidr_map[8]; // weak
char g_int_swdog_target; // weak
_DWORD g_isrs[1088]; // weak
char g_int_cpu_on_state; // weak
_UNKNOWN g_int_svc_cpu_state_lock; // weak
_UNKNOWN g_int_svc_fiq_lock; // weak
char init_done_1195; // weak
char g_int_cpu_interruptible_state; // weak
_UNKNOWN unk_31000; // weak
__int64 NOCERR_propdata; // weak
__int64 NOCInfoOEM; // weak
__int64 NOCInfo; // weak
int cmd_word_count_1139; // weak
__int64 g_pdc_ss_base; // weak
__int64 g_pdc_aoss_base; // weak
__int64 g_pdc_seqs; // weak
int g_pdc_seq_count; // weak
char spmi_initialized; // weak
__int16 pon_ps_hold_reg; // weak
__int16 word_31152; // weak
__int16 word_31154; // weak
__int16 word_31156; // weak
char pm_pon_initialized; // weak
int pm_device_info_arr[]; // weak
char pm_version_initialized; // weak
_DWORD pm_primary_slave_id[8]; // weak
int g_psci_sys_cache_active; // weak
char rail_on_1712; // weak
__int64 g_apss_pdc; // weak
__int64 g_apss_rsc; // weak
__int64 alloc_offset_1210; // weak
__int64 g_res_count; // weak
__int64 g_res; // weak
_UNKNOWN lvl_buf; // weak
char RPMH_STANDALONE; // weak
char rpmh_is_processing; // weak
int numTcsPerHLOSDrv; // weak
__int64 g_rsc_ss_base; // weak
__int16 rsc_params_count; // weak
__int64 g_rscs; // weak
__int64 asAVSRegs[]; // weak
_UNKNOWN scmi_host_spinlock; // weak
char spmiDrv[]; // weak
char byte_316AC; // weak
char byte_316B0; // weak
__int16 word_316B2; // weak
int dword_316BC; // weak
char byte_316C0; // weak
int dword_316C4; // weak
__int64 qword_316C8; // weak
// extern char rsc_params[64]; weak
// extern _BYTE GlobalRscHalCtxt[104]; weak
// extern char g_msg_body[256]; weak
// extern _QWORD g_pdcGpios[3]; weak
// extern __int64 lmh_hsr_version[1]; weak
// extern int g_cmd_set[51]; weak
// extern int rpmh_os; weak
// extern _UNKNOWN unk_318AC; weak
// extern int max_cmd_size; weak
// extern __int64 g_pdcInterrupts[2]; weak
// extern int hmss_pcu_memory_base[2]; weak
// extern __int64 tz_completion_cb; weak
// extern __int64 tz_timeout_cb; weak
// extern __int64 tcs_mode; weak
// extern int g_msg[6]; weak
// extern int rsc_hal_read_back_val; weak
// extern __int64 rpmh_tcs; weak
// extern int ClockMutex; weak
// extern _QWORD rpmh[6]; weak
// extern __int64 (__fastcall *scmi_plat_ops)(_QWORD, _QWORD, _QWORD); weak
// extern _UNKNOWN scmi_num_clk_doms; weak


//----- (0000000000000000) ----------------------------------------------------
__int64 __fastcall cortex_a78_aarch64_sysini(__int64 result)
{
  unsigned __int64 StatusReg; // x0
  unsigned __int64 v2; // x0

  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    if ( MEMORY[0x1FC8000] == 1612185856LL )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFDFFFFFLL);
      __isb(0xFu);
    }
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 2, 0));
    if ( MEMORY[0x1FC8000] == 1612185856LL )
      v2 = StatusReg & 0xFFFFFFFFFFFFFC0FLL | 0x30;
    else
      v2 = StatusReg & 0xFFFFFFFFFFC0000FLL | 0x928C0;
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 2, 0), v2 & 0xFFFFFFF0FFFFFFF0LL | 0x10000000FLL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) != 0 )
    {
      if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) == 0x100000 )
      {
        if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 6)) & 1) != 1 )
          e_1688305_wa();
        e_1827429_wa();
        e_1821534_wa();
        e_1941498_wa();
        e_1951500_wa();
      }
      else if ( (_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xF0000F) == 1048577 )
      {
        e_1941498_wa();
        e_1951500_wa();
      }
    }
    else
    {
      e_1688305_wa();
      e_1515634_wa();
      e_1503072_wa();
      e_1467580_wa();
      e_1492189_wa();
      e_1827429_wa();
      e_1821534_wa();
      e_1941498_wa();
    }
    result = 1612185856LL;
  }
  else if ( !(_BYTE)result )
  {
    result = 1612185856LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000000238) ----------------------------------------------------
void e_1515634_wa()
{
  _WriteStatusReg(
    ARM64_SYSREG(3, 0, 15, 1, 0),
    _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 0)) & 0xFFFFFFFFFFFFF7FFLL | 0x800);
  __isb(0xFu);
}

//----- (0000000000000250) ----------------------------------------------------
void e_1875698_wa()
{
  _WriteStatusReg(
    ARM64_SYSREG(3, 0, 15, 1, 0),
    _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 0)) & 0xFFFFFFFFFFDFFFFFLL | 0x200000);
  __isb(0xFu);
}

//----- (0000000000000268) ----------------------------------------------------
__int64 e_1503072_wa()
{
  __int64 result; // x0

  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 0LL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xEE070F14uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFFF0FFFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x4005027FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xE8400000uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFF00000uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x4001027FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 2uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xE8C00040uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFF00040uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x4001027FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 3uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xE8400000uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFF00000uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x4004027FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 4uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xE8C00040uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFF00040uLL);
  result = 0x4004027FFLL;
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x4004027FFuLL);
  __isb(0xFu);
  return result;
}

//----- (000000000000030C) ----------------------------------------------------
__int64 e_1467580_wa()
{
  __int64 result; // x0

  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 0LL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0xF3D08000uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0xFFF0F0FFuLL);
  result = 0x80000002003FFLL;
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x80000002003FFuLL);
  __isb(0xFu);
  return result;
}

//----- (0000000000000330) ----------------------------------------------------
void e_1688305_wa()
{
  _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1), _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
  __isb(0xFu);
}

//----- (0000000000000348) ----------------------------------------------------
void e_1492189_wa()
{
  _WriteStatusReg(
    ARM64_SYSREG(3, 0, 15, 9, 0),
    _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 9, 0)) & 0xFFFFFFFFFFFFFEFFLL | 0x100);
  __isb(0xFu);
}

//----- (0000000000000360) ----------------------------------------------------
void e_1827429_wa()
{
  _WriteStatusReg(
    ARM64_SYSREG(3, 0, 15, 1, 4),
    _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 4)) & 0xFFDFFFFFFFFFFFFFLL | 0x20000000000000LL);
  __isb(0xFu);
}

//----- (0000000000000378) ----------------------------------------------------
void e_1821534_wa()
{
  _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1), _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFFFFFBLL | 4);
  __isb(0xFu);
}

//----- (0000000000000390) ----------------------------------------------------
__int64 cortex_a78_amu_enable()
{
  __int64 result; // x0

  result = 1612185856LL;
  if ( MEMORY[0x1FC8000] == 1612185856LL )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 2, 5), 0xFuLL);
    result = 7LL;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 3, 1), 7uLL);
    __isb(0xFu);
  }
  return result;
}

//----- (00000000000003BC) ----------------------------------------------------
__int64 cortex_a78_amu_disable()
{
  __int64 result; // x0

  result = 1612185856LL;
  if ( MEMORY[0x1FC8000] == 1612185856LL )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 2, 4), 0xFuLL);
    result = 7LL;
    _WriteStatusReg(ARM64_SYSREG(3, 3, 15, 3, 0), 7uLL);
    __isb(0xFu);
  }
  return result;
}

//----- (00000000000003E8) ----------------------------------------------------
void e_1941498_wa()
{
  _WriteStatusReg(
    ARM64_SYSREG(3, 0, 15, 1, 4),
    _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 4)) & 0xFFFFFFFFFFFFFEFFLL | 0x100);
  __isb(0xFu);
}

//----- (0000000000000400) ----------------------------------------------------
__int64 e_1951500_wa()
{
  __int64 result; // x0

  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 0LL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x10E3900002uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x10FFF00083uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x2001003FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x10E3800082uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x10FFF00083uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x2001003FFuLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 2uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x10E3800200uLL);
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x10FFF003E0uLL);
  result = 0x2001003FFLL;
  _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x2001003FFuLL);
  __isb(0xFu);
  return result;
}

//----- (0000000000000538) ----------------------------------------------------
unsigned __int64 __fastcall qtiseclib_cpuss_reset_asm(int a1)
{
  if ( !a1 )
  {
    cpuss_aarch64_por_sysini(1LL);
    interconnect_aarch64_sysini(1LL);
  }
  return cluster_aarch64_sysini(1uLL);
}

//----- (000000000000056C) ----------------------------------------------------
__int64 qtiseclib_kryo6_gold_reset_asm()
{
  return cpu_aarch64_sysini(1LL);
}

//----- (0000000000000578) ----------------------------------------------------
__int64 qtiseclib_kryo6_silver_reset_asm()
{
  return cpu_aarch64_sysini(1LL);
}

//----- (0000000000000588) ----------------------------------------------------
unsigned __int64 cpuss_read_isr()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 0, 12, 1, 0));
}

//----- (0000000000000590) ----------------------------------------------------
void cpuss_dsb()
{
  __dsb(0xFu);
}

//----- (0000000000000598) ----------------------------------------------------
void cpuss_dmb()
{
  __dmb(0xFu);
}

//----- (00000000000005A0) ----------------------------------------------------
void cpuss_isb()
{
  __isb(0xFu);
}

//----- (00000000000005A8) ----------------------------------------------------
unsigned __int64 __fastcall hoya_10_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFF7LL | 8);
    __isb(0xFu);
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 )
    {
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 3)) & 0xFFFFFFFFFFFF7FFFLL | 0x8000;
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 3, 3), result);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000000698) ----------------------------------------------------
__int64 __fastcall hoya_10_cpuss_aarch64_por_sysini(__int64 result)
{
  int v1; // w2
  unsigned __int64 v2; // x4

  if ( (unsigned __int8)result == 1LL )
  {
    MEMORY[0x17E00058] = 9615380;
    MEMORY[0x17E00060] = MEMORY[0x17E00060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E10058] = 9615380;
    MEMORY[0x17E10060] = MEMORY[0x17E10060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E60058] = 9615380;
    MEMORY[0x17E60060] = MEMORY[0x17E60060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E70058] = 9615380;
    MEMORY[0x17E70060] = MEMORY[0x17E70060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E20058] = 9615380;
    MEMORY[0x17E20060] = MEMORY[0x17E20060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E30058] = 9615380;
    MEMORY[0x17E30060] = MEMORY[0x17E30060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E40058] = 9615380;
    MEMORY[0x17E40060] = MEMORY[0x17E40060] & 0xFFFFFFFD | 2;
    MEMORY[0x17E50058] = 9615380;
    MEMORY[0x17E50060] = MEMORY[0x17E50060] & 0xFFFFFFFD | 2;
    MEMORY[0x17810058] = MEMORY[0x17810058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x17810068] = MEMORY[0x17810068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1781005C] = MEMORY[0x1781005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810060] = MEMORY[0x17810060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810064] = MEMORY[0x17810064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x17810054] = MEMORY[0x17810054] & 0xFFFFFC00 | 0x282;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271LL )
    {
      MEMORY[0x17990174] = MEMORY[0x17990174] & 0xFFFFFFFE | 1;
      __dmb(0xFu);
    }
    MEMORY[0x1799001C] &= ~0x800u;
    __dmb(0xFu);
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFBFFFFF | 0x400000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 || (MEMORY[0x1FC8000] | 0xFF) == 1610613503 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFEFFFFF | 0x100000;
      __dmb(0xFu);
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFFF7FFFF | 0x80000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFF) == 1610613247 || (MEMORY[0x1FC8000] | 0xFF) == 1610613503 )
    {
      MEMORY[0x17A00020] = MEMORY[0x17A00020] & 0xFF7FFFFF | 0x800000;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    {
      MEMORY[0x17990028] &= ~0x20u;
      __dmb(0xFu);
    }
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    {
      result = 395903216LL;
      v1 = 20;
      v2 = (unsigned __int64)&SPI_CONFIGURATION_DATA_SDM845;
      do
      {
        *(_DWORD *)result &= ~*(_DWORD *)v2;
        result = (unsigned int)(result + 4);
        v2 = (unsigned int)(v2 + 4);
        --v1;
      }
      while ( v1 >= 0 );
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}
// A50: using guessed type int SPI_CONFIGURATION_DATA_SDM845;

//----- (0000000000000BA0) ----------------------------------------------------
__int64 __fastcall hoya_10_interconnect_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    MEMORY[0x1790008C] = MEMORY[0x1790008C] & 0xFFFFFFE0 | 1;
    __dsb(0xFu);
    __isb(0xFu);
    result = 395313284LL;
    MEMORY[0x17900084] &= 0xFFFF00FF;
    __dmb(0xFu);
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000000C28) ----------------------------------------------------
unsigned __int64 __fastcall hoya_11_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 1uLL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFF7LL | 8);
    __isb(0xFu);
    result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 0));
    if ( (result & 0x400) != 0 )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 4, 4), 0x22222222uLL);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000000D10) ----------------------------------------------------
__int64 __fastcall hoya_11_cpuss_aarch64_por_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    if ( (MEMORY[0x17E00024] & 1) != 0 )
    {
      MEMORY[0x18000058] = 9615380;
      MEMORY[0x18000060] = MEMORY[0x18000060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 2) != 0 )
    {
      MEMORY[0x18010058] = 9615380;
      MEMORY[0x18010060] = MEMORY[0x18010060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 4) != 0 )
    {
      MEMORY[0x18020058] = 9615380;
      MEMORY[0x18020060] = MEMORY[0x18020060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 8) != 0 )
    {
      MEMORY[0x18030058] = 9615380;
      MEMORY[0x18030060] = MEMORY[0x18030060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x10) != 0 )
    {
      MEMORY[0x18040058] = 9615380;
      MEMORY[0x18040060] = MEMORY[0x18040060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x20) != 0 )
    {
      MEMORY[0x18050058] = 9615380;
      MEMORY[0x18050060] = MEMORY[0x18050060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x40) != 0 )
    {
      MEMORY[0x18060058] = 9615380;
      MEMORY[0x18060060] = MEMORY[0x18060060] & 0xFFFFFFFD | 2;
    }
    if ( (MEMORY[0x17E00024] & 0x80) != 0 )
    {
      MEMORY[0x18070058] = 9615380;
      MEMORY[0x18070060] = MEMORY[0x18070060] & 0xFFFFFFFD | 2;
    }
    MEMORY[0x17E0041C] = 9615380;
    MEMORY[0x17E00434] = MEMORY[0x17E00434] & 0xFFFFFFFE | 1;
    MEMORY[0x18080058] = MEMORY[0x18080058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x18080068] = MEMORY[0x18080068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1808005C] = MEMORY[0x1808005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080060] = MEMORY[0x18080060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080064] = MEMORY[0x18080064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080054] = MEMORY[0x18080054] & 0xFFFFFC00 | 0x282;
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000001108) ----------------------------------------------------
unsigned __int64 __fastcall hoya_20_cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (unsigned __int8)result == 1LL && !((unsigned __int64)((unsigned __int16)result & 0xFF00) >> 8) )
  {
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 1uLL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFBFFFLL | 0x4000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 15, 3, 4),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 4)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 3, 0));
    if ( (result & 0x400) != 0 )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 4, 4), 0x22222222uLL);
      __isb(0xFu);
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (00000000000011D8) ----------------------------------------------------
__int64 __fastcall hoya_20_cpuss_aarch64_por_sysini(__int64 result)
{
  __int64 v1; // x2
  __int64 v2; // x5
  __int64 v3; // x6
  __int64 i; // x7
  __int64 v5; // x0
  int v6; // w2
  unsigned __int64 v7; // x4

  if ( (unsigned __int8)result == 1LL )
  {
    v1 = MEMORY[0x17E0002C];
    v2 = 402653272LL;
    v3 = 402653280LL;
    for ( i = 1LL; (i & v1) != 0; i *= 2LL )
    {
      *(_QWORD *)v2 = 11538461LL;
      *(_DWORD *)v3 = *(_DWORD *)v3 & 0xFFFFFFFD | 2;
      v2 += 0x10000LL;
      v3 += 0x10000LL;
    }
    MEMORY[0x17E0041C] = 9615380;
    MEMORY[0x17E00434] = MEMORY[0x17E00434] & 0xFFFFFFFE | 1;
    __dmb(0xFu);
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135LL )
      MEMORY[0x180801C4] = MEMORY[0x180801C4] & 0xFFFFFFF8 | 3;
    MEMORY[0x18080058] = MEMORY[0x18080058] & 0xFFFC0000 | 0x2004;
    MEMORY[0x18080068] = MEMORY[0x18080068] & 0xFFFC0000 | 0x2008;
    MEMORY[0x1808005C] = MEMORY[0x1808005C] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080060] = MEMORY[0x18080060] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080064] = MEMORY[0x18080064] & 0xFFFC0000 | 0x2008;
    MEMORY[0x18080054] = MEMORY[0x18080054] & 0xFFFFFC00 | 0x282;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      MEMORY[0x17A20048] = MEMORY[0x17A20048] & 0xFFFFFEFF | 0x100;
      __dmb(0xFu);
      MEMORY[0x17A20088] = MEMORY[0x17A20088] & 0xFFFFFFF7 | 8;
      __dmb(0xFu);
      MEMORY[0x17A20088] = MEMORY[0x17A20088] & 0xFFFFFFFB | 4;
      __dmb(0xFu);
    }
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      MEMORY[0x17E00458] &= ~0x2000000u;
      MEMORY[0x17E00458] = MEMORY[0x17E00458] & 0x83FFFFFF | 0x14000000;
      MEMORY[0x17E00458] = MEMORY[0x17E00458] & 0xFFFFFFE0 | 1;
      MEMORY[0x17E0045C] &= 0xFFFFFFF0;
      MEMORY[0x17E00230] = MEMORY[0x17E00230] & 0xFFFEFFFF | 0x10000;
      MEMORY[0x17E00230] = MEMORY[0x17E00230] & 0xF0FFFFFF | 0x1000000;
      v5 = 398459120LL;
      v6 = 24;
      v7 = (unsigned __int64)&SPI_CONFIGURATION_DATA_SC7280;
      do
      {
        *(_DWORD *)v5 &= ~*(_DWORD *)v7;
        v5 = (unsigned int)(v5 + 4);
        v7 = (unsigned int)(v7 + 4);
        --v6;
      }
      while ( v6 >= 0 );
    }
    result = 33325056LL;
    if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    {
      result = 400556600LL;
      MEMORY[0x17E00238] = MEMORY[0x17E00238] & 0xFFFFFFFB | 4;
    }
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}
// 1578: using guessed type int SPI_CONFIGURATION_DATA_SC7280;

//----- (00000000000016A0) ----------------------------------------------------
unsigned __int64 __fastcall kryo400_gold_aarch64_config_wa_sysini(unsigned __int64 result, int a2)
{
  if ( (_DWORD)result == -2147450881 )
  {
    if ( a2 )
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFEFFFFLL | 0x10000;
    else
      result = _ReadStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1)) & 0xFFFFFFFFFFFEFFFFLL;
    _WriteStatusReg(ARM64_SYSREG(3, 0, 15, 1, 1), result);
  }
  __isb(0xFu);
  return result;
}

//----- (00000000000016E0) ----------------------------------------------------
__int64 __fastcall kryo400_gold_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFELL | 1);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFELL | 1);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    result = 269LL;
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000001810) ----------------------------------------------------
__int64 __fastcall kryo400_silver_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 5, 3, 0), 0x40000000uLL);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8500020uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00000uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8D00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (00000000000019C8) ----------------------------------------------------
__int64 __fastcall kryo500_silver_aarch64_sysini(__int64 result)
{
  if ( (unsigned __int8)result == 1LL )
  {
    _WriteStatusReg(
      ARM64_SYSREG(3, 0, 1, 0, 2),
      _ReadStatusReg(ARM64_SYSREG(3, 0, 1, 0, 2)) & 0xFFFFFFFFFFCFFFFFLL | 0x300000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 4, 5, 3, 0), 0x40000000uLL);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 3, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFCC39BFLL | 0x310000);
    __isb(0xFu);
    if ( MEMORY[0x1FC8000] == 1612185856LL )
    {
      _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 3, 1)) & 0xFFFFFFFFFFDFFFFFLL);
      __isb(0xFu);
    }
    _WriteStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1), _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFFFDLL | 2);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFFF7FLL | 0x80);
    __isb(0xFu);
    _WriteStatusReg(
      ARM64_SYSREG(3, 6, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 6, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    _WriteStatusReg(
      ARM64_SYSREG(3, 4, 1, 0, 1),
      _ReadStatusReg(ARM64_SYSREG(3, 4, 1, 0, 1)) & 0xFFFFFFFFFFFFEFFFLL | 0x1000);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 1, 0, 4), 0LL);
    __isb(0xFu);
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 3, 1), 0LL);
    _ReadStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1));
    _WriteStatusReg(ARM64_SYSREG(3, 0, 5, 4, 1), 0x10DuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8500020uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00000uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 0), 1uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 2), 0x8D00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 3), 0x21FF00040uLL);
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 8, 1), 0x11003FDuLL);
    result = 33325056LL;
  }
  __dsb(0xFu);
  __isb(0xFu);
  return result;
}

//----- (0000000000001B90) ----------------------------------------------------
unsigned __int64 __fastcall cluster_aarch64_sysini(unsigned __int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1611595775 )
    return hoya_11_cluster_aarch64_sysini(result);
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    return hoya_20_cluster_aarch64_sysini(result);
  return hoya_10_cluster_aarch64_sysini(result);
}

//----- (0000000000001BC4) ----------------------------------------------------
__int64 __fastcall cpuss_aarch64_por_sysini(__int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1611595775 )
    return hoya_11_cpuss_aarch64_por_sysini(result);
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1612251135 )
    return hoya_20_cpuss_aarch64_por_sysini(result);
  return hoya_10_cpuss_aarch64_por_sysini(result);
}

//----- (0000000000001BF8) ----------------------------------------------------
__int64 __fastcall interconnect_aarch64_sysini(__int64 result)
{
  if ( (MEMORY[0x1FC8000] | 0xFFFF) == 1610678271 )
    return hoya_10_interconnect_aarch64_sysini(result);
  return result;
}

//----- (0000000000001C18) ----------------------------------------------------
__int64 __fastcall cpu_aarch64_sysini(__int64 result)
{
  unsigned __int64 v1; // x2

  v1 = _ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0)) & 0xFFFFFFFFFF0FFFF0LL;
  if ( v1 == 1091555408 )
    return kryo500_silver_aarch64_sysini(result);
  if ( v1 == 1091556368 )
    return cortex_a78_aarch64_sysini(result);
  return result;
}

//----- (0000000000001C80) ----------------------------------------------------
int *__fastcall msm_xpu_isr(__int64 a1, __int64 a2, int *a3)
{
  __int64 is_sdi_enable; // x0

  msm_xpu_print_log(a3);
  is_sdi_enable = dbg_is_sdi_enable();
  if ( (_BYTE)is_sdi_enable )
    dbg_err_fatal(4u);
  qtiseclib_cb_console_flush(is_sdi_enable);
  return a3;
}
// 31998: using guessed type __int64 __fastcall qtiseclib_cb_console_flush(_QWORD);

//----- (0000000000001CC4) ----------------------------------------------------
__int64 xpu_register_interrupts()
{
  int v0; // w20

  v0 = int_svc_register_isr(227, (__int64)"SPI XPU Sec", 0xCuLL, (__int64)msm_xpu_isr, (__int64)&xpu_err_sec_ctx);
  return v0 | (unsigned int)int_svc_register_isr(
                              228,
                              (__int64)"SPI XPU NonSec",
                              0xCuLL,
                              (__int64)msm_xpu_isr,
                              (__int64)&xpu_err_non_sec_ctx);
}

//----- (0000000000001D2C) ----------------------------------------------------
__int64 xpu_static_config()
{
  unsigned int v0; // w19

  if ( (unsigned int)XpuMasterMPuInit((__int64)&msm_mpu_ranges, 2u) )
    return (unsigned int)-1;
  v0 = XpuLockDownAssets((__int64)&msm_xpu_cfg, msm_xpu_cfg_count);
  if ( v0 )
  {
    return (unsigned int)-1;
  }
  else
  {
    ACTzTargetConfig();
    cpuss_dsb();
    MEMORY[0x1FC2040] = -1;
    MEMORY[0x1FC4040] = -1;
    MEMORY[0x1FC2044] = -1;
    MEMORY[0x1FC4044] = -1;
  }
  return v0;
}
// 16860: using guessed type char msm_xpu_cfg_count;

//----- (0000000000001DC4) ----------------------------------------------------
__int64 ac_init()
{
  __int64 result; // x0

  vmidmt_config();
  if ( (unsigned int)xpu_static_config() )
    qtisec_assert("noship_src/drivers/accesscontrol/ac_init.c", 0x57u, "0 == xpu_static_config()");
  result = xpu_register_interrupts();
  if ( (_DWORD)result )
    qtisec_assert("noship_src/drivers/accesscontrol/ac_init.c", 0x59u, "0 == xpu_register_interrupts()");
  return result;
}

//----- (0000000000001E1C) ----------------------------------------------------
__int64 __fastcall mem_assign(__int64 *a1, unsigned int a2, __int64 a3, unsigned int a4, int *a5, unsigned int a6)
{
  __int64 v12; // x3
  __int64 v13; // x5
  int v14; // w19
  int v15; // w21
  int v16; // w0
  int v18; // w6
  unsigned int i; // w4
  __int64 v21; // x8
  int *v22; // x4
  unsigned int v23; // w25
  unsigned int v24; // w24
  int *v25; // x22
  int v26; // w0
  __int64 v28; // x5
  int v29; // w6
  int v30; // w9
  int v31; // w0
  __int64 *v32; // x28
  __int64 j; // x23
  int k; // w0
  __int64 v35; // x20
  __int64 v36; // x27
  __int64 v37; // x26
  int v38; // w0
  __int64 v39; // x22
  char *v40; // x20
  __int64 v41; // x9
  __int64 v42; // x3
  __int64 v43; // x5
  int v44; // w2
  __int64 v45; // x6
  unsigned __int64 v46; // x11
  int v47; // w8
  __int64 m; // x1
  int v49; // w4
  __int64 v50; // x0
  __int64 v51; // x13
  __int64 v52; // x0
  int v53; // w3
  __int64 v54; // x2
  bool v55; // zf
  __int64 v57; // x4
  int v58; // w3
  unsigned int v59; // w19
  __int64 result; // x0
  __int64 v61; // x3
  __int64 v62; // x4
  _QWORD *v63; // [xsp+68h] [xbp+68h]
  __int64 v64; // [xsp+78h] [xbp+78h]
  __int64 v65; // [xsp+90h] [xbp+90h]
  int v66; // [xsp+98h] [xbp+98h]
  unsigned int v67; // [xsp+9Ch] [xbp+9Ch]

  qtiseclib_cb_spin_lock(&perm_lock_1439);
  v12 = a4;
  v13 = 0LL;
  v14 = 0;
  v15 = 0;
  while ( v13 != v12 )
  {
    v16 = *(_DWORD *)(a3 + 4 * v13);
    if ( v16 == 15 || v16 == 43 )
    {
      v18 = 0;
      for ( i = 0; i < a6 && i <= 0x2B; ++i )
      {
        v21 = 6LL * i;
        if ( v16 == a5[v21] )
          v18 = 1;
      }
      if ( !v18 )
      {
        if ( v16 == 15 )
        {
          v14 = 1;
          v15 = 30;
        }
        else
        {
          if ( v16 != 43 )
          {
LABEL_77:
            v59 = 32;
            goto LABEL_78;
          }
          v14 = 1;
          v15 = 35;
        }
      }
    }
    ++v13;
  }
  v22 = a5;
  v23 = 0;
  v24 = 0;
  v25 = &a5[6 * a6];
  while ( v22 != v25 )
  {
    v26 = *v22;
    if ( *v22 == 15 || v26 == 43 )
    {
      v28 = 0LL;
      v29 = 0;
      while ( v12 != v28 )
      {
        v30 = *(_DWORD *)(a3 + 4 * v28++);
        if ( v26 == v30 )
          v29 = 1;
      }
      if ( !v29 )
      {
        if ( v26 == 15 )
        {
          v15 = 30;
        }
        else
        {
          if ( v26 != 43 )
            goto LABEL_77;
          v15 = 35;
        }
        v31 = v22[1];
        v14 = 257;
        if ( (v31 & 2) != 0 )
          v23 = 2;
        if ( (v31 & 4) != 0 )
          v24 = 2;
      }
    }
    v22 += 6;
  }
  v32 = a1;
  v65 = a2;
  for ( j = 0LL; ; ++j )
  {
    v67 = j;
    if ( j == v65 )
      break;
    for ( k = 0; k != 2; ++k )
    {
      v35 = 16LL * k;
      if ( v15 == *(_DWORD *)((char *)&msm_mpu_ranges + v35) )
      {
        v36 = *v32;
        v37 = 0LL;
        v38 = 0;
        v39 = *v32 + v32[1];
        v40 = (char *)&msm_mpu_ranges + v35;
        while ( (unsigned __int8)v40[4] > (int)v37 )
        {
          v41 = *((_QWORD *)v40 + 1);
          v42 = 0LL;
          v43 = 48 * v37;
          v44 = -1;
          v45 = v41 + 48 * v37;
          v46 = *(_QWORD *)(v45 + 24);
          v47 = v46 - *((unsigned __int16 *)v40 + 3);
          for ( m = 16 * (v47 + 1LL); ; m += 16LL )
          {
            v49 = v47 + v42;
            if ( v47 + v42 >= v46 )
            {
              v49 = v44;
              goto LABEL_68;
            }
            v50 = *(_QWORD *)(v45 + 32) + 24 * (v47 + v42);
            v51 = *(_QWORD *)(v50 + 8);
            if ( v36 == v51 && v39 == *(_QWORD *)(v50 + 16) )
              break;
            if ( *(_DWORD *)(*(_QWORD *)(v45 + 16) + m + 4) )
              v55 = 0;
            else
              v55 = v51 == 0xFFFFFFFFLL;
            if ( v55 && *(_QWORD *)(v50 + 16) == 0xFFFFFFFFLL && v44 == -1 )
              v44 = v47 + v42;
            ++v42;
          }
          if ( v14 == 1 )
          {
            v63 = (_QWORD *)(v41 + 48 * v37);
            v64 = *((_QWORD *)v40 + 1);
            v66 = v47 + v42;
            qtiseclib_cb_log(40LL, "freeing RG for xpu 0x%x z:%d", *v63, (unsigned int)v49);
            v52 = 0xFFFFFFFFLL;
            v53 = 0;
            v54 = 0xFFFFFFFFLL;
            v49 = v66;
            v45 = (__int64)v63;
            v43 = 48 * v37;
            v41 = v64;
            goto LABEL_69;
          }
LABEL_68:
          v52 = v39;
          v54 = v36;
          v53 = v14;
LABEL_69:
          if ( v49 == -1 )
          {
            qtiseclib_cb_log(40LL, "AC Fatal Error no free RG xpu addr : 0x%x ", *(_QWORD *)(v41 + v43));
            v38 = 1;
          }
          else
          {
            *(_DWORD *)(*(_QWORD *)(v45 + 16) + 16LL * v49 + 20) = v53;
            v57 = *(_QWORD *)(v45 + 32) + 24LL * v49;
            v58 = *(_DWORD *)v57;
            *(_QWORD *)(v57 + 8) = v54;
            *(_QWORD *)(v57 + 16) = v52;
            XpuLockDownAssetDynamically(v45, 1u, *(_DWORD *)(v45 + 40), v58, v24, v23);
            v38 = 0;
          }
          ++v37;
        }
        if ( v38 )
        {
          qtiseclib_cb_log(10LL, "AC Fatal Error  %x", 96LL);
          dbg_err_fatal(4u);
        }
        break;
      }
    }
    v61 = *v32;
    v62 = *v32 + v32[1];
    v32 += 2;
    qtiseclib_cb_log(10LL, "mpu_master_mpus_range: %d %x %x %x %x", v67, v61, v62, v24, v23);
  }
  v59 = 0;
LABEL_78:
  qtiseclib_cb_spin_unlock(&perm_lock_1439);
  result = 0LL;
  if ( v59 )
  {
    qtiseclib_cb_log(10LL, "mem_assign failed %x", v59);
    return -1LL;
  }
  return result;
}
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000002224) ----------------------------------------------------
__int64 __fastcall qtiseclib_mem_assign(
        __int64 *a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        int *a5,
        unsigned int a6)
{
  return mem_assign(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000002238) ----------------------------------------------------
__int64 __fastcall vmidmt_getInfo_index(unsigned __int8 a1)
{
  int v1; // w4
  __int64 v2; // x1
  __int64 result; // x0

  v1 = a1;
  v2 = 0LL;
  result = 0xFFFFFFFFLL;
  while ( (int)v2 < (unsigned __int8)g_vmidmt_info_cfg_count )
  {
    if ( g_vmidmt_info_cfg[24 * v2] == v1 )
      result = (unsigned int)v2;
    else
      result = (unsigned int)result;
    ++v2;
  }
  return result;
}
// 16858: using guessed type char g_vmidmt_info_cfg_count;
// 16B68: using guessed type unsigned __int8 g_vmidmt_info_cfg[72];

//----- (000000000000227C) ----------------------------------------------------
_DWORD *__fastcall vmidmt_error_handler(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v4; // x0
  unsigned int v5; // w19
  unsigned int v6; // w23
  unsigned int i; // w21
  char *v8; // x20
  unsigned int v9; // w28
  __int64 *v10; // x22
  __int64 v12; // [xsp+60h] [xbp+60h] BYREF
  __int64 v13; // [xsp+68h] [xbp+68h]
  __int64 v14; // [xsp+70h] [xbp+70h]
  __int64 v15; // [xsp+78h] [xbp+78h]
  __int64 v16; // [xsp+80h] [xbp+80h]
  unsigned int v17; // [xsp+88h] [xbp+88h]

  switch ( *a3 )
  {
    case 0:
      qtiseclib_cb_log(10LL, "VMIDMT ERROR: Client Sec!!");
      v4 = 16400LL;
      goto LABEL_4;
    case 1:
      qtiseclib_cb_log(10LL, "VMIDMT ERROR: Client Non Sec!!");
      v4 = 8208LL;
      goto LABEL_4;
    case 2:
      qtiseclib_cb_log(10LL, "VMIDMT ERROR: CFG Sec!!");
      v4 = 20480LL;
      goto LABEL_4;
    case 3:
      qtiseclib_cb_log(10LL, "VMIDMT ERROR: CFG Non Sec!!");
      v4 = 12288LL;
LABEL_4:
      v5 = *(_DWORD *)(v4 & 0xFFFFFFFF0000FFFFLL | 0x1FC0000) & 0x3FFFF;
      break;
    default:
      v5 = 0;
      qtiseclib_cb_log(10LL, "VMIDMT ERROR: Invalid!!");
      break;
  }
  qtiseclib_cb_log(10LL, "VMIDMT INTR0:0x%X", v5);
  if ( v5 )
  {
    v6 = 0;
    do
    {
      for ( i = v6; i != 32; ++i )
      {
        if ( ((v5 >> i) & 1) != 0 )
          break;
      }
      v6 = i + 1;
      if ( i != 32 )
      {
        v8 = &byte_16BB1;
        do
        {
          if ( (unsigned __int8)*(v8 - 1) == i )
          {
            v9 = (unsigned __int8)*v8;
            if ( v9 != 73 )
            {
              v12 = 0LL;
              v13 = 0LL;
              v14 = 0LL;
              v15 = 0LL;
              v16 = 0LL;
              v17 = 0;
              v10 = (__int64 *)&g_vmidmt_info_cfg[24 * (unsigned __int8)vmidmt_getInfo_index(v9) + 8];
              if ( vmidmt_IsError(v10, 1) )
              {
                vmidmt_GetError((__int64)v10, 1u, &v12);
                qtiseclib_cb_log(10LL, "Error Flags: 0x%X", (unsigned int)v12);
                qtiseclib_cb_log(10LL, "Bus Flags: 0x%X", HIDWORD(v12));
                qtiseclib_cb_log(10LL, "Phys Addr: 0x%X 0x%X", HIDWORD(v13), (unsigned int)v13);
                qtiseclib_cb_log(10LL, "SSD Idx: 0x%X SID: 0x%X", (unsigned int)v14, HIDWORD(v14));
                qtiseclib_cb_log(10LL, "MID: 0x%X AVMID: 0x%X", (unsigned int)v15, HIDWORD(v15));
                qtiseclib_cb_log(10LL, "ATID: 0x%X ABID: 0x%X APID: 0x%X", (unsigned int)v16, HIDWORD(v16), v17);
                vmidmt_ClearError(v10, 1);
              }
              else
              {
                qtiseclib_cb_log(10LL, "VMIDMT ERROR: VMIDMT %d reported no error!!", v9);
              }
            }
          }
          v8 += 2;
        }
        while ( v8 != (char *)&unk_16BF1 );
      }
    }
    while ( v6 <= 0x1F );
  }
  return a3;
}
// 16B68: using guessed type unsigned __int8 g_vmidmt_info_cfg[72];
// 16BB1: using guessed type char byte_16BB1;
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (00000000000024E4) ----------------------------------------------------
__int64 __fastcall vmidmt_map_vmid_internal(unsigned __int8 a1)
{
  int v1; // w7
  unsigned int v2; // w8
  char v3; // w9
  int v4; // w10
  __int64 Info_index; // x19
  int **v6; // x19
  int v7; // w0
  unsigned int v8; // w1
  __int64 v10[2]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v11; // [xsp+38h] [xbp+38h]
  __int64 v12[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v13; // [xsp+50h] [xbp+50h]
  int v14; // [xsp+58h] [xbp+58h]

  v12[0] = 0LL;
  v12[1] = 0LL;
  v10[0] = 0LL;
  v10[1] = 0LL;
  v11 = 0LL;
  v13 = 0LL;
  v14 = 0;
  Info_index = (unsigned __int8)vmidmt_getInfo_index(a1);
  if ( v1 != 255 )
  {
    BYTE4(v13) = v1;
    LODWORD(v13) = 1;
  }
  if ( v4 )
    LODWORD(v12[0]) = 2;
  v10[0] = (__int64)v12;
  LOBYTE(v11) = v3;
  v6 = (int **)&g_vmidmt_info_cfg[24 * Info_index + 8];
  v7 = vmidmt_ConfigVmidCtxt((__int64)v6, v2, v10);
  v8 = -1;
  if ( !v7 )
  {
    vmidmt_EnableClientP(v6, 1);
    vmidmt_EnableClientP(v6, 0);
    return 0;
  }
  return v8;
}
// 2520: variable 'v1' is possibly undefined
// 2530: variable 'v4' is possibly undefined
// 255C: variable 'v3' is possibly undefined
// 2568: variable 'v2' is possibly undefined
// 16B68: using guessed type unsigned __int8 g_vmidmt_info_cfg[72];

//----- (00000000000025A0) ----------------------------------------------------
__int64 __fastcall vmidmt_map_multisid_vmid_internal(unsigned __int8 a1)
{
  int v1; // w7
  unsigned int v2; // w8
  __int64 v3; // x9
  unsigned int v4; // w10
  char v5; // w11
  int v6; // w12
  __int64 Info_index; // x19
  int **v8; // x19
  int v9; // w0
  unsigned int v10; // w1
  __int64 v12[2]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v13; // [xsp+38h] [xbp+38h]
  __int64 v14[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v15; // [xsp+50h] [xbp+50h]
  int v16; // [xsp+58h] [xbp+58h]

  v14[0] = 0LL;
  v14[1] = 0LL;
  v12[0] = 0LL;
  v12[1] = 0LL;
  v13 = 0LL;
  v15 = 0LL;
  v16 = 0;
  Info_index = (unsigned __int8)vmidmt_getInfo_index(a1);
  if ( v1 != 255 )
  {
    BYTE4(v15) = v1;
    LODWORD(v15) = 1;
  }
  if ( v6 )
    LODWORD(v14[0]) = 2;
  v12[0] = (__int64)v14;
  v8 = (int **)&g_vmidmt_info_cfg[24 * Info_index + 8];
  LOBYTE(v13) = v5;
  v9 = vmidmt_ConfigVmidCtxtWithSIDList((__int64)v8, v2, v3, v4, v12);
  v10 = -1;
  if ( !v9 )
  {
    vmidmt_EnableClientP(v8, 1);
    vmidmt_EnableClientP(v8, 0);
    return 0;
  }
  return v10;
}
// 25E4: variable 'v1' is possibly undefined
// 25F4: variable 'v6' is possibly undefined
// 262C: variable 'v5' is possibly undefined
// 2634: variable 'v2' is possibly undefined
// 2634: variable 'v3' is possibly undefined
// 2634: variable 'v4' is possibly undefined
// 16B68: using guessed type unsigned __int8 g_vmidmt_info_cfg[72];

//----- (000000000000266C) ----------------------------------------------------
__int64 vmidmt_config_vmids()
{
  char *v0; // x21
  unsigned int i; // w19
  char *v2; // x1
  unsigned __int8 v3; // w0
  unsigned int v4; // w0
  unsigned int v5; // w20

  v0 = (char *)&unk_15EBC;
  for ( i = 0; i < 0x55; ++i )
  {
    v2 = (char *)&g_vmid_map + 28 * (int)i;
    if ( v2[26] )
    {
      v3 = *((_BYTE *)&g_vmid_map + 28 * (int)i);
      v4 = v2[24] == 1 ? vmidmt_map_vmid_internal(v3) : vmidmt_map_multisid_vmid_internal(v3);
      v5 = v4;
      if ( v4 )
      {
        qtiseclib_cb_log(10LL, "VMIDMT Config ERROR for g_vmid_map[%d]", i);
        return v5;
      }
    }
    v0 += 28;
  }
  return 0;
}
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000002744) ----------------------------------------------------
__int64 __fastcall vmidmt_config_options_per_master(int a1)
{
  __int64 v1; // x22
  int v2; // w23
  __int64 Info_index; // x19
  __int64 *v4; // x19
  int v5; // w0
  unsigned int v6; // w1
  unsigned __int8 *v7; // x20
  __int64 v8; // x1
  int v9; // w20
  __int64 v11[2]; // [xsp+40h] [xbp+40h] BYREF
  int v12[8]; // [xsp+50h] [xbp+50h] BYREF
  __int64 v13[3]; // [xsp+70h] [xbp+70h] BYREF
  char v14; // [xsp+88h] [xbp+88h]
  char v15; // [xsp+89h] [xbp+89h]

  v1 = a1;
  v2 = g_vmidmt_cfg[24 * a1];
  Info_index = (unsigned __int8)vmidmt_getInfo_index(g_vmidmt_cfg[24 * a1]);
  v13[2] = (__int64)&acc_ctl;
  v14 = 0;
  v15 = 0;
  v11[1] = 65280LL;
  v13[0] = 0LL;
  v13[1] = 0LL;
  qtiseclib_cb_memset(v12, 0LL, 28LL);
  v11[0] = (__int64)v13;
  if ( v2 == 4 )
  {
    v15 = 0;
    v13[0] = (__int64)v12;
    v12[0] = 2;
  }
  v4 = (__int64 *)&g_vmidmt_info_cfg[24 * Info_index + 8];
  v5 = vmidmt_Init(v4, (__int64)v11, 0LL);
  v6 = -1;
  if ( !v5 )
  {
    v7 = &g_vmidmt_cfg[24 * v1];
    v8 = *((_QWORD *)v7 + 1);
    if ( v8 )
      vmidmt_ConfigSSDT((__int64)v4, v8, v7[16]);
    v9 = g_vmidmt_cfg[24 * v1 + 1];
    vmidmt_ConfigErrRep((__int64)v4, 0, v9);
    vmidmt_ConfigErrRep((__int64)v4, 1, v9);
    return 0;
  }
  return v6;
}
// 16810: using guessed type unsigned __int8 g_vmidmt_cfg[72];
// 16B68: using guessed type unsigned __int8 g_vmidmt_info_cfg[72];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000286C) ----------------------------------------------------
__int64 vmidmt_config_options()
{
  unsigned int i; // w19
  __int64 result; // x0

  for ( i = 0; i < 3; ++i )
  {
    if ( g_vmidmt_cfg[24 * i + 17] )
    {
      result = vmidmt_config_options_per_master(i);
      if ( (_DWORD)result )
        return result;
    }
  }
  return 0LL;
}
// 16810: using guessed type unsigned __int8 g_vmidmt_cfg[72];

//----- (00000000000028D8) ----------------------------------------------------
__int64 vmidmt_register_interrupts()
{
  int v0; // w20
  int v1; // w20
  int v2; // w21
  __int64 result; // x0

  v0 = int_svc_register_isr(
         230,
         (__int64)"VMIDMT CTL Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_clt_sec_ctx);
  v1 = v0 | int_svc_register_isr(
              231,
              (__int64)"VMIDMT CTL NSec",
              0x10uLL,
              (__int64)vmidmt_error_handler,
              (__int64)&vmidmt_err_clt_nonsec_ctx);
  v2 = int_svc_register_isr(
         232,
         (__int64)"VMIDMT CFG Sec",
         0xFuLL,
         (__int64)vmidmt_error_handler,
         (__int64)&vmidmt_err_cfg_sec_ctx);
  result = v2 | (unsigned int)int_svc_register_isr(
                                233,
                                (__int64)"VMIDMT CFG NSec",
                                0x10uLL,
                                (__int64)vmidmt_error_handler,
                                (__int64)&vmidmt_err_cfg_nonsec_ctx) | v1;
  MEMORY[0x1FC5040] = -1;
  MEMORY[0x1FC3040] = -1;
  MEMORY[0x1FC4050] = -1;
  MEMORY[0x1FC2050] = -1;
  return result;
}

//----- (00000000000029C8) ----------------------------------------------------
__int64 vmidmt_config()
{
  __int64 result; // x0

  if ( (unsigned int)vmidmt_config_options()
    || (unsigned int)vmidmt_config_vmids()
    || (result = vmidmt_register_interrupts(), (_DWORD)result) )
  {
    qtiseclib_cb_log(10LL, "VMIDMT ERROR :(%x)", 1LL);
    while ( 1 )
      ;
  }
  return result;
}
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000002A08) ----------------------------------------------------
__int64 ACTzTargetConfig()
{
  __int64 result; // x0

  result = 31457288LL;
  MEMORY[0x1E00008] = 271;
  return result;
}

//----- (0000000000002A1C) ----------------------------------------------------
__int64 __fastcall cpucp_clkdom_init(__int64 a1)
{
  char v1; // w0
  int *v2; // x2
  __int64 result; // x0
  __int64 v4; // x1
  __int64 v5; // x20
  int v6; // [xsp+34h] [xbp+34h] BYREF
  int v7[2]; // [xsp+38h] [xbp+38h] BYREF

  v1 = qtiseclib_cb_plat_my_core_pos(a1);
  v2 = &dword_1A61C;
  result = (unsigned int)(1 << v1);
  v4 = 0LL;
  while ( 1 )
  {
    v5 = (int)v4;
    if ( !clkdom_init_status[v4] && ((unsigned int)result & *v2) != 0 )
      break;
    ++v4;
    v2 += 2;
    if ( v4 == 4 )
      return result;
  }
  qtiseclib_cb_spin_lock(&cpucp_clkdom_init_spinlock);
  if ( !clkdom_init_status[v5] )
  {
    v7[0] = *((_DWORD *)&clkdom_cpumasks + 2 * v5);
    v7[1] = 1;
    if ( !(unsigned int)cpucp_scmi_send(0x14u, 7u, (__int64)v7, 8u, &v6, 0LL, 0LL) && !v6 )
      clkdom_init_status[v5] = 1;
  }
  return qtiseclib_cb_spin_unlock(&cpucp_clkdom_init_spinlock);
}
// 1A608: using guessed type _DWORD clkdom_init_status[4];
// 1A61C: using guessed type int dword_1A61C;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (0000000000002AEC) ----------------------------------------------------
__int64 __fastcall Clock_InitImage(__int64 a1)
{
  __int64 v1; // x20
  unsigned int v2; // w21
  int v3; // w20

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 24LL) + 40LL;
  MEMORY[0x171154] = MEMORY[0x171154] & 0x81F0000E | 1;
  while ( (MEMORY[0x171154] & 0x80000000) != 0 )
    qtiseclib_cb_udelay(1LL);
  Clock_EnableClockGroup(2u);
  Clock_EnableClockGroup(3u);
  if ( (MEMORY[0x339B024] & 1) != 0 )
  {
    bSSCGDSCPrevEnabled = 0;
    MEMORY[0x339B024] &= 0xF8FFFFFE;
    __dsb(0xFu);
    while ( (MEMORY[0x339B030] & 1) == 0 )
      ;
    while ( (MEMORY[0x380101C] & 0x80000000) != 0 )
      ;
  }
  else
  {
    bSSCGDSCPrevEnabled = 1;
  }
  Clock_EnableClockGroup(4u);
  MEMORY[0x3D91098] = MEMORY[0x3D91098] & 0x81E07FFC | 1;
  MEMORY[0x3D91204] = MEMORY[0x3D91204] & 0x81E0000C | 1;
  MEMORY[0x3D9E110] |= 1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D9E110] &= ~1u;
  MEMORY[0x3D91074] = MEMORY[0x3D91074] & 0x7FFF0 | 1;
  MEMORY[0x3D9106C] &= 0xF8FFFFFE;
  while ( (MEMORY[0x3D9106C] & 0x80000000) == 0 )
    ;
  MEMORY[0x3D91510] = 2;
  MEMORY[0x3D9E120] = MEMORY[0x3D9E120] & 0xFFFFFE00 | 0x1F4;
  MEMORY[0x3D91014] = MEMORY[0x3D91014] & 0x7FF0F | 0x70;
  MEMORY[0x3D91008] = 1;
  MEMORY[0x3D91160] = 1;
  MEMORY[0x3D98004] = 1;
  qtiseclib_cb_udelay(150LL);
  MEMORY[0x3D91008] = 0;
  MEMORY[0x3D91160] = 0;
  MEMORY[0x3D98004] = 0;
  MEMORY[0x3D9158C] = MEMORY[0x3D9158C] & 0x3C0001 | 0x10;
  qtiseclib_cb_udelay(1LL);
  MEMORY[0x3D9158C] &= 0x3C0001u;
  MEMORY[0x3D9158C] &= 0x3C0010u;
  MEMORY[0x3D9100C] &= 0xF8FFFFFE;
  while ( (MEMORY[0x3D9100C] & 0x80000000) == 0 )
    ;
  MEMORY[0x3D94004] &= 0x3000800u;
  MEMORY[0x3D94000] &= 0x3000800u;
  MEMORY[0x106100] &= ~4u;
  MEMORY[0x153000] = MEMORY[0x153000] & 2;
  MEMORY[0x15301C] = MEMORY[0x15301C] & 2;
  MEMORY[0x153018] = MEMORY[0x153018] & 2;
  MEMORY[0x153010] = MEMORY[0x153010] & 2;
  MEMORY[0x153014] = MEMORY[0x153014] & 2;
  MEMORY[0x153008] = MEMORY[0x153008] & 2;
  MEMORY[0x153004] = MEMORY[0x153004] & 2;
  MEMORY[0x106100] |= 0x800u;
  MEMORY[0x153000] = MEMORY[0x153000] & 1 | 2;
  MEMORY[0x15301C] = MEMORY[0x15301C] & 1 | 2;
  MEMORY[0x153010] = MEMORY[0x153010] & 1 | 2;
  MEMORY[0x153014] = MEMORY[0x153014] & 1 | 2;
  MEMORY[0x153008] = MEMORY[0x153008] & 1 | 2;
  MEMORY[0x153004] = MEMORY[0x153004] & 1 | 2;
  MEMORY[0x153018] = MEMORY[0x153018] & 1 | 2;
  MEMORY[0x3D94004] = MEMORY[0x3D94004] & 0x3000004 | 0x800;
  MEMORY[0x3D94000] = MEMORY[0x3D94000] & 0x3000004 | 0x800;
  MEMORY[0x190004] = MEMORY[0x190004] & 0x81F03FFF | 0x4000;
  MEMORY[0x190010] = MEMORY[0x190010] & 0x81F03FFE | 0x4000;
  MEMORY[0x190020] = MEMORY[0x190020] & 0x81F03FFF | 0x4000;
  MEMORY[0x190028] = MEMORY[0x190028] & 0x81F03FFF | 0x4000;
  MEMORY[0x183008] = MEMORY[0x183008] & 0x81F03FFF | 0x4000;
  MEMORY[0x17100C] = MEMORY[0x17100C] & 0x81F03FFF | 0x4000;
  v2 = Clock_EnableSource(v1);
  if ( v2 )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = 500;
    MEMORY[0x1FD3300] = 1;
    MEMORY[0x18A2A4] = 0;
    MEMORY[0x18A00C] &= 0x81F0000E;
    MEMORY[0x18A000] = MEMORY[0x18A000] & 0x81F0000E | 1;
    if ( (MEMORY[0x18A000] & 2) == 0 )
    {
      while ( (MEMORY[0x18A000] & 0x80000000) != 0 )
      {
        qtiseclib_cb_udelay(1LL);
        if ( !--v3 )
          return v2;
      }
    }
    MEMORY[0x4180044] = 1;
    qtiseclib_cb_udelay(100LL);
    MEMORY[0xC2B0000] |= 1u;
    qtiseclib_cb_udelay(300LL);
    MEMORY[0xC2B0000] &= ~1u;
    qtiseclib_cb_udelay(100LL);
    MEMORY[0x4180044] = 0;
    MEMORY[0x18A000] &= 0x81F0000E;
    MEMORY[0x3D9152C] = 0;
  }
  return v2;
}
// 1FCA8: using guessed type char bSSCGDSCPrevEnabled;
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (00000000000030B4) ----------------------------------------------------
__int64 Clock_PostInitImage()
{
  MEMORY[0x3D9100C] = MEMORY[0x3D9100C] & 0xF8FFFFFE | 1;
  MEMORY[0x3D98004] = 1;
  qtiseclib_cb_udelay(150LL);
  MEMORY[0x3D9158C] = MEMORY[0x3D9158C] & 0x3C0010 | 1;
  while ( (MEMORY[0x3D9100C] & 0x80000000) != 0 )
    ;
  MEMORY[0x3D9106C] = MEMORY[0x3D9106C] & 0xF8FFFFFE | 1;
  while ( (MEMORY[0x3D9106C] & 0x80000000) != 0 )
    ;
  Clock_DisableClockGroup(4u);
  if ( !bSSCGDSCPrevEnabled )
  {
    MEMORY[0x339B024] = MEMORY[0x339B024] & 0xF8FFFFFE | 1;
    __dsb(0xFu);
    while ( (MEMORY[0x339B024] & 0x80000000) != 0 )
      ;
  }
  Clock_DisableClockGroup(3u);
  Clock_DisableClockGroup(2u);
  return 0LL;
}
// 1FCA8: using guessed type char bSSCGDSCPrevEnabled;
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (00000000000031A4) ----------------------------------------------------
__int64 __fastcall Clock_DisableSource(__int64 a1)
{
  int v1; // w1
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    *(_DWORD *)(a1 + 16) = v1 - 1;
    if ( v1 == 1 && !*(_QWORD *)(a1 + 24) )
      HAL_clk_DisableSource(a1);
  }
  result = 0LL;
  if ( *(_QWORD *)(a1 + 32) )
  {
    Clock_DisableSource(*(_QWORD *)(a1 + 32));
    return 0LL;
  }
  return result;
}

//----- (000000000000320C) ----------------------------------------------------
__int64 Clock_IsBSPSupported()
{
  return 1LL;
}

//----- (0000000000003214) ----------------------------------------------------
__int64 Clock_InitRPMh()
{
  int addr; // w23
  int v1; // w22
  int v2; // w21
  unsigned int v3; // w0

  qword_1A528 = rpmh_create_handle(0, (__int64)"clock");
  dword_1A530 = pwr_utils_lvl_resource_idx((__int64)"cx.lvl");
  dword_1A534 = pwr_utils_lvl_resource_idx((__int64)"mx.lvl");
  addr = cmd_db_query_addr((__int64)"cx.lvl");
  v1 = cmd_db_query_addr((__int64)"mx.lvl");
  v2 = cmd_db_query_addr((__int64)"xo.lvl");
  if ( !qword_1A528 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC5u, "pDrvCtxt->hRPMh != 0");
  if ( dword_1A530 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC6u, "pDrvCtxt->nCXLVLIdx != -1");
  if ( !addr )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC7u, "nCXAddr");
  if ( !v1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC8u, "nMXAddr");
  if ( !v2 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xC9u, "nXOAddr");
  dword_1A544 = addr;
  dword_1A550 = v1;
  v3 = rpmh_issue_command(qword_1A528, 0, 1, v2, 3);
  return rpmh_barrier_single(qword_1A528, v3);
}
// DD38: using guessed type __int64 __fastcall rpmh_barrier_single(_QWORD, _QWORD);
// 1A528: using guessed type __int64 qword_1A528;
// 1A530: using guessed type int dword_1A530;
// 1A534: using guessed type int dword_1A534;
// 1A544: using guessed type int dword_1A544;
// 1A550: using guessed type int dword_1A550;

//----- (0000000000003370) ----------------------------------------------------
__int64 __fastcall Clock_SetCXVoltage(int a1)
{
  int v1; // w22
  int v2; // w21
  int v3; // w20
  unsigned int v4; // w0

  v1 = aClockVRegMapping[a1];
  v2 = pwr_utils_hlvl(dword_1A530, v1, 0LL);
  v3 = pwr_utils_hlvl(dword_1A534, v1, 0LL);
  if ( v2 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xF5u, "nCXHLVL != -1");
  if ( v3 == -1 )
    qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0xF6u, "nMXHLVL != -1");
  dword_1A548 = v2;
  dword_1A554 = v3;
  v4 = rpmh_issue_command_set(qword_1A528, dword_1A538);
  rpmh_barrier_single(qword_1A528, v4);
  return 0LL;
}
// DD38: using guessed type __int64 __fastcall rpmh_barrier_single(_QWORD, _QWORD);
// 168E8: using guessed type _DWORD aClockVRegMapping[8];
// 1A528: using guessed type __int64 qword_1A528;
// 1A530: using guessed type int dword_1A530;
// 1A534: using guessed type int dword_1A534;
// 1A538: using guessed type unsigned int[3];
// 1A548: using guessed type int dword_1A548;
// 1A554: using guessed type int dword_1A554;

//----- (0000000000003434) ----------------------------------------------------
__int64 __fastcall Clock_VoltageRequest(unsigned int a1, unsigned int a2)
{
  bool v2; // cc
  unsigned int v3; // w21
  unsigned int v4; // w19
  char *v5; // x0
  int v6; // w1
  unsigned int v7; // w0

  v2 = a1 > 7 || a2 > 7;
  v3 = -1;
  if ( !v2 )
  {
    v4 = a2;
    if ( a1 )
    {
      v5 = (char *)ClockDrvCtxt + 4 * a1;
      v6 = *((_DWORD *)v5 + 3);
      if ( v6 )
        *((_DWORD *)v5 + 3) = v6 - 1;
    }
    if ( v4 )
      ++*((_DWORD *)&ClockDrvCtxt[1] + v4 + 1);
    if ( v4 < dword_1A524 )
    {
      v7 = dword_1A524;
      do
      {
        if ( *((_DWORD *)&ClockDrvCtxt[1] + v7 + 1) )
          break;
        --v7;
      }
      while ( v4 < v7 );
      v4 = v7;
    }
    v3 = 0;
    if ( v4 != dword_1A524 )
    {
      Clock_SetCXVoltage(v4);
      dword_1A524 = v4;
    }
  }
  return v3;
}
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 1A524: using guessed type int dword_1A524;

//----- (00000000000034F0) ----------------------------------------------------
__int64 __fastcall Clock_EnableSource(__int64 a1)
{
  unsigned int v1; // w20
  int v3; // w0

  if ( !a1 || *(_QWORD *)(a1 + 32) && (unsigned int)Clock_EnableSource() )
  {
    return (unsigned int)-1;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 16);
    v1 = 0;
    *(_DWORD *)(a1 + 16) = v3 + 1;
    if ( !v3 )
    {
      v1 = 0;
      if ( !*(_QWORD *)(a1 + 24) )
        HAL_clk_EnableSource((__int64 *)a1);
    }
  }
  return v1;
}

//----- (000000000000355C) ----------------------------------------------------
__int64 __fastcall Clock_EnableClockDomain(__int64 a1)
{
  int v1; // w1
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v1 + 1;
  if ( v1 )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 32);
  if ( v3 )
    Clock_VoltageRequest(0, *(_DWORD *)(v3 + 16));
  v4 = *(_QWORD *)(a1 + 40);
  if ( v4 )
    Clock_EnableSource(v4);
  return 0LL;
}

//----- (00000000000035C0) ----------------------------------------------------
__int64 __fastcall Clock_DisableClockDomain(__int64 a1)
{
  int v1; // w1
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_DWORD *)(a1 + 48);
  if ( !v1 )
    return 0LL;
  *(_DWORD *)(a1 + 48) = v1 - 1;
  if ( v1 != 1 )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 40);
  if ( v3 )
    Clock_DisableSource(v3);
  v4 = *(_QWORD *)(a1 + 32);
  if ( v4 )
    Clock_VoltageRequest(*(_DWORD *)(v4 + 16), 0);
  return 0LL;
}

//----- (000000000000362C) ----------------------------------------------------
__int64 __fastcall Clock_WriteRegRegion(__int64 result)
{
  unsigned int i; // w1
  __int64 v2; // x3
  int v3; // w4

  for ( i = 0; i < *(_DWORD *)(result + 8); ++i )
  {
    v2 = 4LL * (i & 0x3FFFFFFF);
    v3 = *(_DWORD *)(*(_QWORD *)result + 4LL * i);
    *(_DWORD *)(v2 + *(_QWORD *)(result + 16)) = v3;
  }
  return result;
}

//----- (000000000000365C) ----------------------------------------------------
__int64 Clock_Init()
{
  __int64 result; // x0

  result = (unsigned __int8)byte_1A500;
  if ( !byte_1A500 )
  {
    Clock_InitRPMh();
    if ( (unsigned int)Clock_InitImage((__int64)ClockDrvCtxt) )
      qtisec_assert(
        "noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c",
        0x307u,
        "0 == Clock_InitImage(&ClockDrvCtxt)");
    result = 1LL;
    byte_1A500 = 1;
  }
  return result;
}
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 1A500: using guessed type char byte_1A500;

//----- (00000000000036BC) ----------------------------------------------------
__int64 Clock_TZInitDone()
{
  __int64 result; // x0

  result = Clock_PostInitImage();
  if ( (_DWORD)result )
    qtisec_assert(
      "noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c",
      0x317u,
      "0 == Clock_PostInitImage(&ClockDrvCtxt)");
  return result;
}

//----- (00000000000036F8) ----------------------------------------------------
__int64 __fastcall Clock_GetClockId(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  _QWORD *v5; // x20
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD **)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_10);
  result = 0xFFFFFFFFLL;
  if ( v5 )
  {
    while ( *v5 )
    {
      result = qtiseclib_cb_strcmp(a1);
      if ( !(_DWORD)result )
      {
        *a2 = v5;
        return result;
      }
      v5 += 7;
    }
    result = 0xFFFFFFFFLL;
    *a2 = 0LL;
  }
  return result;
}
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 31940: using guessed type __int64 __fastcall qtiseclib_cb_strcmp(_QWORD);

//----- (0000000000003778) ----------------------------------------------------
__int64 __fastcall Clock_EnableClock(__int64 a1)
{
  int v2; // w0
  int **v3; // x21
  __int64 v4; // x19
  int v5; // w0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  qtiseclib_cb_spin_lock(&ClockMutex);
  v2 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v2 + 1;
  if ( v2
    || ((v3 = (int **)(a1 + 8),
         Clock_EnableClockDomain(*(_QWORD *)(a1 + 32)),
         HAL_clk_EnableClock(a1 + 8),
         (v4 = *(_QWORD *)(a1 + 40)) == 0)
     || (v5 = *(_DWORD *)(v4 + 16), *(_DWORD *)(v4 + 16) = v5 + 1, v5)
     || (HAL_clk_EnablePowerDomain(v4), (unsigned int)HAL_clk_WaitForPowerDomainOn((_DWORD **)v4)))
    && (unsigned int)HAL_clk_WaitForClockOn(v3) )
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0LL;
  }
  else
  {
    qtiseclib_cb_spin_unlock(&ClockMutex);
    return 0xFFFFFFFFLL;
  }
}
// 318F8: using guessed type int ClockMutex;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000003830) ----------------------------------------------------
__int64 __fastcall Clock_DisableClock(__int64 a1)
{
  int v2; // w0
  __int64 v3; // x0
  int v4; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  qtiseclib_cb_spin_lock(&ClockMutex);
  v2 = *(_DWORD *)(a1 + 48);
  if ( v2 )
  {
    *(_DWORD *)(a1 + 48) = v2 - 1;
    if ( v2 == 1 )
    {
      HAL_clk_DisableClock(a1 + 8);
      Clock_DisableClockDomain(*(_QWORD *)(a1 + 32));
      v3 = *(_QWORD *)(a1 + 40);
      if ( v3 )
      {
        v4 = *(_DWORD *)(v3 + 16);
        if ( v4 )
        {
          *(_DWORD *)(v3 + 16) = v4 - 1;
          if ( v4 == 1 )
            HAL_clk_DisablePowerDomain((_DWORD **)v3);
        }
      }
    }
  }
  qtiseclib_cb_spin_unlock(&ClockMutex);
  return 0LL;
}
// 318F8: using guessed type int ClockMutex;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (00000000000038BC) ----------------------------------------------------
__int64 __fastcall Clock_IsClockOn(__int64 a1, _BYTE *a2)
{
  bool v2; // zf
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  result = HAL_clk_IsClockOn((int **)(a1 + 8));
  if ( (_DWORD)result )
  {
    *a2 = 1;
    return 0LL;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

//----- (0000000000003910) ----------------------------------------------------
__int64 __fastcall Clock_IsClockPowerDomainOn(__int64 a1, _BYTE *a2)
{
  bool v2; // zf
  _DWORD **v3; // x0
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD ***)(a1 + 40);
  if ( !v3 || (result = HAL_clk_IsPowerDomainOn(v3), (_DWORD)result) )
  {
    *a2 = 1;
    return 0LL;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

//----- (0000000000003968) ----------------------------------------------------
__int64 __fastcall Clock_SetClockFrequency(__int64 a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w1
  __int64 v4; // x19
  __int64 result; // x0
  __int64 v6; // x20
  unsigned int v7; // w3
  __int64 v8; // x21
  unsigned int v9; // w0
  unsigned int v10; // w1
  unsigned int v11; // w0
  unsigned int v12; // w1
  __int64 v13; // x0
  bool v14; // zf
  int v15; // w0

  v3 = 1000 * a2;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 32);
  result = 0xFFFFFFFFLL;
  if ( v4 )
  {
    v6 = *(_QWORD *)(v4 + 24);
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)v6;
        if ( !*(_DWORD *)v6 )
          return 0xFFFFFFFFLL;
        if ( v3 <= v7 && ((*(_DWORD *)(v4 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(v6 + 14) != 255) )
          break;
        v6 += 24LL;
      }
      result = 0xFFFFFFFFLL;
      if ( *(_DWORD *)(v6 + 4) <= 2u )
      {
        if ( a3 )
          *a3 = v7 / 0x3E8;
        result = 0LL;
        if ( v6 != *(_QWORD *)(v4 + 32) )
        {
          qtiseclib_cb_spin_lock(&ClockMutex);
          v8 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_18) + 40LL * *(unsigned int *)(v6 + 4);
          if ( *(_DWORD *)(v4 + 48) )
          {
            v9 = *(_DWORD *)(v4 + 52);
            v10 = *(_DWORD *)(v6 + 16);
            if ( v10 > v9 )
              Clock_VoltageRequest(v9, v10);
            if ( v8 != *(_QWORD *)(v4 + 40) )
              Clock_EnableSource(v8);
          }
          if ( (*(_DWORD *)(v4 + 56) & 0x800000) == 0 )
            HAL_clk_ConfigClockMux((_DWORD *)v4, (unsigned int *)(v6 + 4));
          if ( *(_DWORD *)(v4 + 48) )
          {
            v11 = *(_DWORD *)(v4 + 52);
            v12 = *(_DWORD *)(v6 + 16);
            if ( v12 < v11 )
              Clock_VoltageRequest(v11, v12);
            v13 = *(_QWORD *)(v4 + 40);
            if ( v13 )
              v14 = v8 == v13;
            else
              v14 = 1;
            if ( !v14 )
              Clock_DisableSource(v13);
          }
          v15 = *(_DWORD *)(v6 + 16);
          *(_QWORD *)(v4 + 32) = v6;
          *(_QWORD *)(v4 + 40) = v8;
          *(_DWORD *)(v4 + 52) = v15;
          qtiseclib_cb_spin_unlock(&ClockMutex);
          return 0LL;
        }
      }
    }
  }
  return result;
}
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 318F8: using guessed type int ClockMutex;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000003AC4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall Clock_EnableClockGroup(unsigned int a1)
{
  __int64 v1; // x29
  __int64 v2; // x23
  unsigned __int64 v3; // x21
  __int64 v4; // x19
  __int64 v5; // x2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  int v11; // w0
  __int64 v12; // x20
  __int64 v13; // x20
  __int64 v14; // x0
  int v15; // w0
  int v16; // w3
  int v17; // w4
  unsigned int v18; // w0
  int **v19; // x20
  __int64 client; // x0
  __int64 v21; // x0
  _QWORD *v22; // x20
  __int64 v23; // x0
  _QWORD *v24; // x24
  _DWORD **v25; // x0
  _QWORD *v26; // x24
  __int64 v27; // x0
  int **i; // x19
  int **v29; // x0
  __int64 v31; // [xsp+0h] [xbp-60h]
  __int64 v32; // [xsp+50h] [xbp-10h] BYREF
  __int64 v33; // [xsp+58h] [xbp-8h]

  if ( a1 > 4 )
    return 0xFFFFFFFFLL;
  v31 = v1;
  v2 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_8);
  if ( v2 )
  {
    v3 = (unsigned __int64)a1 << 6;
    v4 = v2 + v3;
    if ( *(_QWORD *)(v2 + v3) )
    {
      qtiseclib_cb_spin_lock(&ClockMutex);
      v11 = *(_DWORD *)(v4 + 40);
      *(_DWORD *)(v4 + 40) = v11 + 1;
      if ( v11 )
        goto LABEL_43;
      v12 = *(_QWORD *)(v4 + 32);
      v32 = 0LL;
      v33 = 0LL;
      if ( v12 )
      {
        *(_DWORD *)(v4 + 60) = 0;
        while ( 1 )
        {
          v14 = *(_QWORD *)v12;
          if ( !*(_QWORD *)v12 )
            break;
          ++*(_DWORD *)(v4 + 60);
          if ( !*(_DWORD *)(v12 + 12) )
          {
            *(_DWORD *)(v12 + 12) = cmd_db_query_addr(v14);
            v15 = pwr_utils_hlvl_named_resource(*(_QWORD *)v12, *(_DWORD *)(v12 + 8), 0LL);
            *(_DWORD *)(v12 + 16) = v15;
            if ( !*(_DWORD *)(v12 + 12) )
            {
              v15 = 0;
              *(_DWORD *)cortex_a78_aarch64_sysini = 0;
              __break(0x3E8u);
            }
            if ( v15 == -1 )
            {
              *(_DWORD *)cortex_a78_aarch64_sysini = 0;
              __break(0x3E8u);
            }
          }
          v16 = *(_DWORD *)(v12 + 12);
          v17 = *(_DWORD *)(v12 + 16);
          v12 += 24LL;
          v18 = rpmh_issue_command(qword_1A528, 0, 1, v16, v17);
          rpmh_barrier_single(qword_1A528, v18);
        }
      }
      v13 = *(_QWORD *)(v4 + 24);
      if ( v13 )
      {
        *(_DWORD *)(v4 + 56) = 0;
        while ( *(_DWORD *)(v13 + 8) )
        {
          ++*(_DWORD *)(v4 + 56);
          if ( !*(_QWORD *)(v13 + 16) )
          {
            client = icbuarb_create_client(*(_DWORD *)v13, *(_DWORD *)(v13 + 4));
            *(_QWORD *)(v13 + 16) = client;
            if ( !client )
              qtisec_assert("noship_src/drivers/systemdrivers/clock/src/v1/ClockDriver.c", 0x255u, "pICB->hICB");
          }
          v21 = *(unsigned int *)(v13 + 8);
          v13 += 24LL;
          v32 = v21;
          v33 = v21;
          icbuarb_issue_request(*(_QWORD **)(v13 - 8), &v32, v5, v6, v7, v8, v9, v10, v31);
        }
      }
      v19 = *(int ***)(v4 + 16);
      if ( v19 )
      {
        *(_DWORD *)(v4 + 52) = 0;
        while ( *v19 )
        {
          ++*(_DWORD *)(v4 + 52);
          HAL_clk_EnableClock((__int64)v19);
          if ( !(unsigned int)HAL_clk_WaitForClockOn(v19) )
            goto LABEL_42;
          v19 += 3;
        }
      }
      v22 = *(_QWORD **)(v4 + 8);
      if ( v22 )
      {
        *(_DWORD *)(v4 + 48) = 0;
        while ( *v22 )
        {
          ++*(_DWORD *)(v4 + 48);
          v23 = (__int64)v22;
          v22 += 2;
          HAL_clk_EnablePowerDomain(v23);
        }
        v24 = *(_QWORD **)(v4 + 8);
        LODWORD(v22) = 0;
        while ( *v24 )
        {
          v25 = (_DWORD **)v24;
          v24 += 2;
          LODWORD(v22) = (unsigned int)v22 | ((unsigned int)HAL_clk_WaitForPowerDomainOn(v25) == 0);
        }
      }
      v26 = *(_QWORD **)(v2 + v3);
      *(_DWORD *)(v4 + 44) = 0;
      while ( *v26 )
      {
        ++*(_DWORD *)(v4 + 44);
        v27 = (__int64)v26;
        v26 += 3;
        HAL_clk_EnableClock(v27);
      }
      for ( i = *(int ***)(v2 + v3); *i; i += 3 )
      {
        v29 = i;
        LODWORD(v22) = (unsigned int)v22 | ((unsigned int)HAL_clk_WaitForClockOn(v29) == 0);
      }
      if ( !(_DWORD)v22 )
      {
LABEL_43:
        qtiseclib_cb_spin_unlock(&ClockMutex);
        return 0LL;
      }
LABEL_42:
      qtiseclib_cb_spin_unlock(&ClockMutex);
    }
  }
  return 0xFFFFFFFFLL;
}
// 3B84: write access to const memory at 0 has been detected
// 3B98: write access to const memory at 0 has been detected
// 3ACC: variable 'v1' is possibly undefined
// 3C38: variable 'v5' is possibly undefined
// 3C38: variable 'v6' is possibly undefined
// 3C38: variable 'v7' is possibly undefined
// 3C38: variable 'v8' is possibly undefined
// 3C38: variable 'v9' is possibly undefined
// 3C38: variable 'v10' is possibly undefined
// 3C38: variable 'v31' is possibly undefined
// DD38: using guessed type __int64 __fastcall rpmh_barrier_single(_QWORD, _QWORD);
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 1A528: using guessed type __int64 qword_1A528;
// 318F8: using guessed type int ClockMutex;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000003D6C) ----------------------------------------------------
__int64 __fastcall Clock_DisableClockGroup(unsigned int a1)
{
  __int64 v1; // x29
  __int64 v3; // x24
  __int64 result; // x0
  unsigned __int64 v5; // x23
  __int64 v6; // x19
  __int64 v7; // x3
  __int64 v8; // x4
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7
  int v12; // w0
  unsigned int v13; // w20
  unsigned __int64 i; // x20
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned __int64 j; // x20
  unsigned __int64 k; // x20
  __int64 v19; // x0
  __int64 v20; // x2
  unsigned __int64 m; // x20
  __int64 v22; // x0
  unsigned __int64 n; // x20
  _QWORD *v24; // x0
  int v25; // w3
  __int64 v26; // [xsp+0h] [xbp-50h]
  __int64 v27[2]; // [xsp+40h] [xbp-10h] BYREF

  if ( a1 > 4 )
    return 0xFFFFFFFFLL;
  v26 = v1;
  v3 = *(_QWORD *)((char *)ClockDrvCtxt[0] + (unsigned __int64)&loc_8);
  result = 0xFFFFFFFFLL;
  if ( v3 )
  {
    v5 = (unsigned __int64)a1 << 6;
    v6 = v3 + v5;
    if ( *(_QWORD *)(v3 + v5) )
    {
      qtiseclib_cb_spin_lock(&ClockMutex);
      v12 = *(_DWORD *)(v6 + 40);
      if ( v12 )
      {
        *(_DWORD *)(v6 + 40) = v12 - 1;
        if ( v12 == 1 )
        {
          v13 = *(_DWORD *)(v6 + 44);
          v27[0] = 0LL;
          v27[1] = 0LL;
          for ( i = *(_QWORD *)(v3 + v5) + 24LL * v13 - 24; i >= *(_QWORD *)v6; i -= 24LL )
          {
            if ( !*(_DWORD *)(i + 16) )
              HAL_clk_DisableClock(i);
          }
          v15 = *(_QWORD *)(v6 + 8);
          if ( v15 )
          {
            for ( j = v15 + 16LL * *(unsigned int *)(v6 + 48) - 16; j >= *(_QWORD *)(v6 + 8); j -= 16LL )
            {
              if ( !*(_DWORD *)(j + 8) )
                HAL_clk_DisablePowerDomain((_DWORD **)j);
            }
          }
          v16 = *(_QWORD *)(v6 + 16);
          if ( v16 )
          {
            for ( k = v16 + 24LL * *(unsigned int *)(v6 + 52) - 24; k >= *(_QWORD *)(v6 + 16); k -= 24LL )
            {
              if ( !*(_DWORD *)(k + 16) )
                HAL_clk_DisableClock(k);
            }
          }
          v19 = *(_QWORD *)(v6 + 24);
          if ( v19 )
          {
            v20 = 24LL;
            for ( m = v19 + 24LL * *(unsigned int *)(v6 + 56) - 24; m >= *(_QWORD *)(v6 + 24); m -= 24LL )
            {
              v24 = *(_QWORD **)(m + 16);
              if ( v24 )
                icbuarb_issue_request(v24, v27, v20, v7, v8, v9, v10, v11, v26);
            }
          }
          v22 = *(_QWORD *)(v6 + 32);
          if ( v22 )
          {
            for ( n = v22 + 24LL * *(unsigned int *)(v6 + 60) - 24; n >= *(_QWORD *)(v6 + 32); n -= 24LL )
            {
              v25 = *(_DWORD *)(n + 12);
              if ( v25 )
                rpmh_issue_command(qword_1A528, 0, 1, v25, 0);
            }
          }
        }
      }
      qtiseclib_cb_spin_unlock(&ClockMutex);
      return 0LL;
    }
  }
  return result;
}
// 3D74: variable 'v1' is possibly undefined
// 3EF0: variable 'v20' is possibly undefined
// 3EF0: variable 'v7' is possibly undefined
// 3EF0: variable 'v8' is possibly undefined
// 3EF0: variable 'v9' is possibly undefined
// 3EF0: variable 'v10' is possibly undefined
// 3EF0: variable 'v11' is possibly undefined
// 3EF0: variable 'v26' is possibly undefined
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 1A528: using guessed type __int64 qword_1A528;
// 318F8: using guessed type int ClockMutex;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000003F54) ----------------------------------------------------
__int64 Clock_SetRPMAvailable()
{
  return 0LL;
}

//----- (0000000000003F5C) ----------------------------------------------------
__int64 Clock_RPMRequest()
{
  return 0LL;
}

//----- (0000000000003F64) ----------------------------------------------------
__int64 __fastcall Clock_GetRPMId(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  _QWORD *v4; // x19
  __int64 result; // x0

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD **)ClockDrvCtxt[0];
  if ( *(_QWORD *)ClockDrvCtxt[0] )
  {
    while ( *v4 )
    {
      result = qtiseclib_cb_strcmp(a1);
      if ( !(_DWORD)result )
      {
        *a2 = v4;
        return result;
      }
      v4 += 3;
    }
  }
  return 0xFFFFFFFFLL;
}
// 1A4F8: using guessed type __int64 (__fastcall *ClockDrvCtxt[12])();
// 31940: using guessed type __int64 __fastcall qtiseclib_cb_strcmp(_QWORD);

//----- (0000000000003FD4) ----------------------------------------------------
__int64 __fastcall Clock_EnableDFS(__int64 a1)
{
  unsigned __int64 v1; // x19
  __int64 result; // x0
  __int64 i; // x20

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 32);
  result = 0xFFFFFFFFLL;
  if ( v1 )
  {
    if ( *(_DWORD *)(v1 + 16) )
    {
      result = 0LL;
      if ( (*(_DWORD *)(v1 + 56) & 0x800000) == 0 )
      {
        for ( i = *(_QWORD *)(v1 + 24) + 4LL; *(_DWORD *)(i - 4); i += 24LL )
        {
          if ( *(unsigned __int8 *)(i + 10) != 255 )
            HAL_clk_ConfigDFSMux(v1, i);
        }
        HAL_clk_EnableDFS(v1);
        *(_DWORD *)(v1 + 56) |= 0x800000u;
        return 0LL;
      }
    }
  }
  return result;
}

//----- (0000000000004064) ----------------------------------------------------
__int64 __fastcall Clock_GetFrequencyPlan(__int64 a1, unsigned __int64 *a2, unsigned int *a3)
{
  bool v3; // zf
  __int64 v5; // x22
  __int64 result; // x0
  __int64 v7; // x0
  unsigned int v8; // w20
  unsigned __int64 v11; // x0
  _DWORD *v12; // x2
  __int64 i; // x0

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( !v3 && a1 != 0 )
  {
    v5 = *(_QWORD *)(a1 + 32);
    result = 0xFFFFFFFFLL;
    if ( !v5 )
      return result;
    v7 = *(_QWORD *)(v5 + 24);
    v8 = 0;
    if ( !v7 )
    {
      *a3 = 0;
      return 0LL;
    }
    while ( *(_DWORD *)v7 )
    {
      if ( (*(_DWORD *)(v5 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(v7 + 14) != 255 )
        ++v8;
      v7 += 24LL;
    }
    if ( *a2 || (*a3 = v8, v11 = qtisec_malloc(4LL * (v8 & 0x3FFFFFFF)), (*a2 = v11) != 0) )
    {
      if ( v8 <= *a3 )
      {
        v12 = (_DWORD *)*a2;
        for ( i = *(_QWORD *)(v5 + 24); *(_DWORD *)i; i += 24LL )
        {
          if ( (*(_DWORD *)(v5 + 56) & 0x800000) == 0 || *(unsigned __int8 *)(i + 14) != 255 )
            *v12++ = *(_DWORD *)i;
        }
        *a3 = v8;
        return 0LL;
      }
      *a3 = v8;
    }
    else
    {
      *a3 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000004168) ----------------------------------------------------
__int64 __fastcall cmd_db_conv_str_to_unit64(__int64 a1)
{
  __int64 v2; // x2
  __int64 result; // x0
  unsigned __int8 v4; // w1
  char v5; // w3

  v2 = 0LL;
  result = 0LL;
  do
  {
    v4 = *(_BYTE *)(a1 + v2);
    if ( !v4 )
      break;
    v5 = 8 * v2++;
    result |= (unsigned __int64)v4 << v5;
  }
  while ( v2 != 8 );
  return result;
}

//----- (000000000000419C) ----------------------------------------------------
__int64 __fastcall cmd_db_query(__int64 a1, __int64 a2, __int64 a3)
{
  bool v5; // zf
  unsigned int v6; // w21
  int v7; // w0
  int v9; // w0
  __int64 v10; // x26
  int v11; // w0
  int v12; // w25
  int v13; // w21
  unsigned int v14; // w25
  __int64 v15; // x5
  unsigned __int16 *v16; // x4
  unsigned __int16 *v17; // x1
  unsigned int i; // w2
  int v19; // w0
  __int64 v20; // x3
  __int64 v21; // x22
  bool v22; // zf
  unsigned int v23; // w20
  unsigned int v24; // w2
  __int64 v25; // x1
  __int64 v26; // x21
  __int64 v27; // x2

  if ( !smem_query_db )
  {
LABEL_21:
    v6 = 1;
    goto LABEL_37;
  }
  if ( a1 )
    v5 = a2 == 0;
  else
    v5 = 1;
  v6 = 2;
  v7 = v5;
  if ( !v7 && (a3 || !*(_DWORD *)(a2 + 24)) )
  {
    v9 = *(_DWORD *)(a1 + 16);
    if ( !v9 )
    {
      v10 = cmd_db_conv_str_to_unit64(a1);
      goto LABEL_17;
    }
    if ( v9 == 1 )
    {
      v11 = *(_WORD *)(a1 + 14) & 0xF;
      if ( (unsigned int)(v11 - 3) <= 2 )
      {
        v10 = 0LL;
        *(_DWORD *)(a1 + 20) = v11;
LABEL_17:
        v12 = *(_DWORD *)(a1 + 20);
        cmd_db_prep_access();
        v13 = 0;
        v14 = v12 - 3;
        v15 = smem_query_db + 144;
        v16 = (unsigned __int16 *)(smem_query_db + 8);
        v17 = (unsigned __int16 *)(smem_query_db + 10);
        while ( v14 <= 2 && *v16 != *(_DWORD *)(a1 + 20) )
        {
LABEL_20:
          ++v13;
          v16 += 8;
          v17 += 8;
          if ( v13 == 8 )
            goto LABEL_21;
        }
        for ( i = 0; ; i = (unsigned __int16)(i + 1) )
        {
          if ( i >= v17[2] )
            goto LABEL_20;
          v19 = *(_DWORD *)(a1 + 16);
          v20 = *v17 + 24LL * i;
          v21 = v15 + v20;
          if ( v19 )
          {
            if ( v19 != 1 )
              continue;
            v22 = *(_DWORD *)(a1 + 12) == *(_DWORD *)(v21 + 16);
          }
          else
          {
            v22 = *(_QWORD *)(v15 + v20) == v10;
          }
          if ( v22 )
          {
            qtiseclib_cb_memcpy(a2, a1, 9LL);
            v23 = *(_DWORD *)(a2 + 24);
            v24 = *(unsigned __int16 *)(v21 + 20);
            v25 = smem_query_db;
            *(_DWORD *)(a2 + 12) = *(_DWORD *)(v21 + 16);
            v26 = v25 + 16LL * v13;
            *(_DWORD *)(a2 + 16) = *(_DWORD *)(v21 + 8);
            *(_DWORD *)(a2 + 20) = *(_DWORD *)(v21 + 12);
            *(_WORD *)(a2 + 28) = *(_WORD *)(v26 + 16);
            if ( v23 && v24 )
            {
              if ( v24 <= v23 )
                v23 = v24;
              v27 = *(unsigned __int16 *)(v26 + 12);
              v6 = 0;
              qtiseclib_cb_memcpy(a3, v25 + 144 + v27 + *(unsigned __int16 *)(v21 + 22), v23);
              *(_DWORD *)(a2 + 24) = v23;
            }
            else
            {
              v6 = 0;
              if ( v24 )
                *(_DWORD *)(a2 + 24) = v24;
            }
            goto LABEL_37;
          }
        }
      }
    }
    goto LABEL_21;
  }
LABEL_37:
  cmd_db_access_done();
  return v6;
}
// 4768: using guessed type __int64 cmd_db_prep_access(void);
// 476C: using guessed type __int64 cmd_db_access_done(void);
// 1FCB0: using guessed type __int64 smem_query_db;
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000004380) ----------------------------------------------------
__int64 __fastcall cmd_db_query_addr(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+38h] [xbp+38h]
  __int64 v5; // [xsp+40h] [xbp+40h]
  __int64 v6; // [xsp+48h] [xbp+48h]

  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)&v3, 0LL) )
    return 0LL;
  else
    return HIDWORD(v4);
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (00000000000043D8) ----------------------------------------------------
__int64 __fastcall cmd_db_query_priority(int a1, char a2)
{
  __int64 v4; // [xsp+28h] [xbp+28h] BYREF
  int v5; // [xsp+30h] [xbp+30h]
  int v6; // [xsp+34h] [xbp+34h]
  __int64 v7; // [xsp+38h] [xbp+38h]
  __int64 v8[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v9; // [xsp+50h] [xbp+50h]
  __int64 v10; // [xsp+58h] [xbp+58h]

  v4 = 0LL;
  v5 = 0;
  v7 = 1LL;
  v6 = a1;
  v8[0] = 0LL;
  v8[1] = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  if ( (unsigned int)cmd_db_query((__int64)&v4, (__int64)v8, 0LL) )
    return 0LL;
  else
    return 2 * ((HIDWORD(v9) >> a2) & 1) + (((unsigned int)v9 >> a2) & 1);
}

//----- (0000000000004448) ----------------------------------------------------
__int64 __fastcall cmd_db_query_priority_res_id(__int64 a1, char a2)
{
  int v3; // w0
  unsigned int v4; // w1
  __int64 v6[3]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v7[2]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v8; // [xsp+50h] [xbp+50h]
  __int64 v9; // [xsp+58h] [xbp+58h]

  v7[0] = 0LL;
  v7[1] = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  memset(v6, 0, sizeof(v6));
  if ( a1 )
  {
    qtiseclib_cb_memcpy(v6, a1, 9LL);
    v3 = cmd_db_query((__int64)v6, (__int64)v7, 0LL);
    v4 = 0;
    if ( !v3 )
      return 2 * ((HIDWORD(v8) >> a2) & 1) + (((unsigned int)v8 >> a2) & 1);
  }
  else
  {
    return 2;
  }
  return v4;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (00000000000044C8) ----------------------------------------------------
__int64 __fastcall cmd_db_query_version(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3[3]; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+48h] [xbp+48h]

  memset(v3, 0, sizeof(v3));
  v4 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)v3, 0LL) )
    return 0LL;
  else
    return WORD2(v4);
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000004520) ----------------------------------------------------
__int64 __fastcall cmd_db_query_len(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3[3]; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+48h] [xbp+48h]

  memset(v3, 0, sizeof(v3));
  v4 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 2LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)v3, 0LL) )
    return 0LL;
  else
    return (unsigned int)v4;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000004578) ----------------------------------------------------
__int64 __fastcall cmd_db_query_aux_data(__int64 a1, _BYTE *a2, __int64 a3)
{
  bool v3; // zf
  bool v4; // zf
  __int64 result; // x0
  __int64 v8[3]; // [xsp+28h] [xbp+28h] BYREF
  __int64 v9[3]; // [xsp+40h] [xbp+40h] BYREF
  __int64 v10; // [xsp+58h] [xbp+58h]

  if ( a3 )
    v3 = a2 == 0LL;
  else
    v3 = 1;
  v4 = v3 || a1 == 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0LL;
  memset(v8, 0, sizeof(v8));
  if ( v4 )
    return 2LL;
  qtiseclib_cb_memcpy(v8, a1, 9LL);
  LODWORD(v10) = (unsigned __int8)*a2;
  result = cmd_db_query((__int64)v8, (__int64)v9, a3);
  if ( !(_DWORD)result )
    *a2 = v10;
  return result;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (00000000000045F4) ----------------------------------------------------
__int64 __fastcall cmd_db_query_slv_id(__int64 a1)
{
  __int64 v2[3]; // [xsp+18h] [xbp+18h] BYREF
  __int64 v3; // [xsp+30h] [xbp+30h] BYREF
  __int64 v4; // [xsp+38h] [xbp+38h]
  __int64 v5; // [xsp+40h] [xbp+40h]
  __int64 v6; // [xsp+48h] [xbp+48h]

  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  memset(v2, 0, sizeof(v2));
  if ( !a1 )
    return 0LL;
  qtiseclib_cb_memcpy(v2, a1, 9LL);
  if ( (unsigned int)cmd_db_query((__int64)v2, (__int64)&v3, 0LL) )
    return 0LL;
  else
    return BYTE6(v4) & 0xF;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000000464C) ----------------------------------------------------
bool cmd_db_init()
{
  _BOOL4 v0; // w20
  char v2; // [xsp+4Bh] [xbp+4Bh] BYREF
  int v3; // [xsp+4Ch] [xbp+4Ch] BYREF

  v3 = 0;
  smem_query_db = cmd_db_target_mem_init(&v3);
  v0 = !smem_query_db
    || (cmd_db_prep_access(), *(_DWORD *)smem_query_db != 1)
    || *(_DWORD *)(smem_query_db + 4) != 201535707;
  cmd_db_access_done();
  if ( v0 )
    smem_query_db = 0LL;
  v2 = 32;
  cmd_db_test_addr = cmd_db_query_addr((__int64)"MC0");
  dword_1FCCC = cmd_db_query_addr((__int64)"mss.lvl");
  cmd_db_query_aux_data((__int64)"mss.lvl", &v2, (__int64)&cmd_db_test_data);
  cmd_db_test_priority = cmd_db_query_priority(cmd_db_test_addr, 0);
  dword_1FCBC = cmd_db_query_priority(dword_1FCCC, 1);
  dword_1FCC0 = cmd_db_query_priority_res_id((__int64)"cx.lvl", 0);
  dword_1FCC4 = cmd_db_query_priority_res_id((__int64)"cx.tmr", 1);
  return v0;
}
// 4768: using guessed type __int64 cmd_db_prep_access(void);
// 476C: using guessed type __int64 cmd_db_access_done(void);
// 1FCB0: using guessed type __int64 smem_query_db;
// 1FCB8: using guessed type int cmd_db_test_priority;
// 1FCBC: using guessed type int dword_1FCBC;
// 1FCC0: using guessed type int dword_1FCC0;
// 1FCC4: using guessed type int dword_1FCC4;
// 1FCC8: using guessed type int cmd_db_test_addr;
// 1FCCC: using guessed type int dword_1FCCC;

//----- (0000000000004770) ----------------------------------------------------
__int64 __fastcall cmd_db_target_mem_init(_DWORD *a1)
{
  cmd_db_addr = 2156265472LL;
  *a1 = 0x20000;
  return 2156265472LL;
}
// 1FCF0: using guessed type __int64 cmd_db_addr;

//----- (0000000000004790) ----------------------------------------------------
__int64 __fastcall calculate_cpumasks(__int64 result)
{
  int *v1; // x1
  char v2; // w2
  __int64 i; // x2
  int v4; // t1

  v1 = &dword_1A61C;
  v2 = ~(unsigned __int8)((unsigned __int64)MEMORY[0x78018C] >> 7);
  dword_1A624 = v2 & 0xF;
  dword_1A62C = v2 & 0x70;
  dword_1A634 = v2 & 0x80;
  for ( i = 0LL; i != 16; i += 4LL )
  {
    v4 = *v1;
    v1 += 2;
    *(_DWORD *)(result + i) = v4;
  }
  return result;
}
// 1A61C: using guessed type int dword_1A61C;
// 1A624: using guessed type int dword_1A624;
// 1A62C: using guessed type int dword_1A62C;
// 1A634: using guessed type int dword_1A634;

//----- (00000000000047E8) ----------------------------------------------------
__int64 __fastcall dbg_halt_online_cpus(__int64 result)
{
  unsigned int i; // w19
  __int64 v2; // x0

  for ( i = 0; i != 8; ++i )
  {
    result = qtiseclib_cb_plat_my_core_pos(result) & 7;
    if ( (_DWORD)result != i )
    {
      result = int_svc_is_cpu_on(i);
      if ( (_BYTE)result )
      {
        v2 = int_svc_core_pos_to_mpidr(i);
        result = qtiseclib_cb_ic_raise_sgi(15LL, v2);
      }
    }
  }
  return result;
}
// 31908: using guessed type __int64 __fastcall qtiseclib_cb_ic_raise_sgi(_QWORD, _QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (0000000000004844) ----------------------------------------------------
void __fastcall __noreturn dbg_err_fatal_handler(unsigned int a1)
{
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x0

  qtiseclib_cb_spin_lock(&g_dbg_svc_lock);
  if ( first_time_1190 )
  {
    first_time_1190 = 0;
    timer_sec_wdog_pet();
    timer_sec_wdog_start(2, 1);
    dbg_halt_online_cpus(v2);
    g_fatal_err_code = a1;
    qtiseclib_cb_switch_console_to_crash_state();
  }
  if ( a1 > 5 )
    v3 = qtiseclib_cb_log(10LL, "Unknown fatal error");
  else
    v3 = qtiseclib_cb_log(10LL, dbg_err_fatal_str[a1]);
  qtiseclib_cb_console_flush(v3);
  qtiseclib_cb_spin_unlock(&g_dbg_svc_lock);
  MEMORY[0x17C00008] = 2;
  qtiseclib_cb_log(10LL, "SENDING NMI TO Q6 SUBSYSs! ");
  if ( (MEMORY[0x1F62010] & 1) != 0 )
    MEMORY[0x3000040] = 1;
  if ( (MEMORY[0x1F7400C] & 1) != 0 )
    MEMORY[0xA300040] = 1;
  if ( (MEMORY[0x1F63010] & 1) != 0 )
    MEMORY[0x4080040] = 1;
  v4 = MEMORY[0x8A00408];
  if ( (MEMORY[0x8A00408] & 1) != 0 )
  {
    v4 = 144703552LL;
    MEMORY[0x8A00040] = 1;
  }
  while ( 1 )
    v4 = dbg_halt_online_cpus(v4);
}
// 4880: variable 'v2' is possibly undefined
// 1A638: using guessed type char first_time_1190;
// 1A640: using guessed type char *dbg_err_fatal_str[6];
// 1FCF8: using guessed type int g_fatal_err_code;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);
// 31978: using guessed type __int64 qtiseclib_cb_switch_console_to_crash_state(void);
// 31998: using guessed type __int64 __fastcall qtiseclib_cb_console_flush(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000496C) ----------------------------------------------------
void __noreturn nsec_wdt_bite_isr_handler()
{
  dbg_err_fatal_handler(2u);
}

//----- (000000000000497C) ----------------------------------------------------
__int64 dbg_is_sdi_enable()
{
  return 0LL;
}

//----- (0000000000004984) ----------------------------------------------------
__int64 dbg_init()
{
  int_svc_register_isr(33, (__int64)"NSEC_WDOG_BITE", 0xFuLL, (__int64)nsec_wdt_bite_isr_handler, 0LL);
  return int_svc_register_isr(15, (__int64)"SGI15", 6uLL, (__int64)sgi15_isr_handler, 0LL);
}
// 47E4: using guessed type void __fastcall __noreturn sgi15_isr_handler();

//----- (00000000000049D0) ----------------------------------------------------
void __noreturn qtiseclib_panic()
{
  dbg_err_fatal_handler(1u);
}

//----- (00000000000049E0) ----------------------------------------------------
void __fastcall __noreturn dbg_err_fatal(unsigned int a1)
{
  dbg_err_fatal_handler(a1);
}

//----- (00000000000049EC) ----------------------------------------------------
__int64 qtiseclib_is_debug_enabled_secure_io_access()
{
  return 0LL;
}

//----- (00000000000049F4) ----------------------------------------------------
unsigned __int64 __fastcall HAL_clk_GenericConfigMuxOffs_part_0(
        unsigned __int64 result,
        unsigned int *a2,
        unsigned int a3,
        unsigned int a4,
        unsigned int a5,
        unsigned int a6)
{
  __int64 v6; // x6
  unsigned int v7; // w0
  int v8; // w7
  int v9; // w7
  unsigned int v10; // w1

  v6 = *(_QWORD *)result;
  if ( *(_QWORD *)result )
  {
    v7 = ((*(_DWORD *)(*(_QWORD *)(result + 8) + 4LL * *a2) & 7) << 8) | *(_DWORD *)(a3 + v6) & 0xFFEFC8E0;
    v8 = 0;
    if ( *((_BYTE *)a2 + 4) )
      v8 = (*((unsigned __int8 *)a2 + 4) - 1) & 0x1F;
    v9 = v7 | v8;
    result = *((unsigned __int16 *)a2 + 3);
    if ( *((_WORD *)a2 + 3) )
    {
      v10 = *((unsigned __int16 *)a2 + 4);
      if ( (unsigned int)result < v10 )
      {
        v9 |= 0x2000u;
        *(_DWORD *)(a4 + v6) = result;
        result = ~(v10 - (unsigned int)result);
        *(_DWORD *)(a5 + v6) = result;
        *(_DWORD *)(a6 + v6) = ~v10;
      }
    }
    *(_DWORD *)(a3 + v6) = v9;
  }
  return result;
}

//----- (0000000000004A80) ----------------------------------------------------
__int64 __fastcall HAL_clk_EnableClock(__int64 result)
{
  int *v1; // x1
  int v2; // w2
  bool v3; // zf
  int v4; // w2
  int v5; // w4

  LODWORD(v1) = *(_DWORD *)(result + 8);
  if ( (_DWORD)v1 )
  {
    v1 = (int *)(unsigned int)v1;
    v2 = *(_DWORD *)(result + 12);
  }
  else
  {
    v1 = *(int **)result;
    if ( !*(_QWORD *)result )
      return result;
    v2 = 1;
  }
  v3 = (*v1 & v2) == 0;
  v4 = *v1 | v2;
  v5 = !v3;
  *(_DWORD *)(result + 16) = v5;
  *v1 = v4;
  return result;
}

//----- (0000000000004ABC) ----------------------------------------------------
__int64 __fastcall HAL_clk_DisableClock(__int64 result)
{
  unsigned __int64 v1; // x1
  int v2; // w0

  LODWORD(v1) = *(_DWORD *)(result + 8);
  if ( (_DWORD)v1 )
  {
    v1 = (unsigned int)v1;
    v2 = *(_DWORD *)(result + 12);
  }
  else
  {
    v1 = *(_QWORD *)result;
    if ( !*(_QWORD *)result )
      return result;
    v2 = 1;
  }
  result = *(_DWORD *)v1 & (unsigned int)~v2;
  *(_DWORD *)v1 = result;
  return result;
}

//----- (0000000000004AEC) ----------------------------------------------------
__int64 *__fastcall HAL_clk_EnableSource(__int64 *result)
{
  int v1; // w3

  v1 = *((_DWORD *)result + 2);
  if ( v1 )
  {
    result = (__int64 *)*result;
    MEMORY[0x153030] |= v1;
    if ( result )
    {
      while ( (*(_DWORD *)result & 0x40000000) == 0 )
        ;
    }
  }
  return result;
}

//----- (0000000000004B1C) ----------------------------------------------------
__int64 __fastcall HAL_clk_DisableSource(__int64 a1)
{
  __int64 result; // x0

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
  {
    result = MEMORY[0x153030] & (unsigned int)~(_DWORD)result;
    MEMORY[0x153030] = result;
  }
  return result;
}

//----- (0000000000004B3C) ----------------------------------------------------
__int64 __fastcall HAL_clk_IsClockOn(int **a1)
{
  int *v1; // x0

  v1 = *a1;
  if ( v1 )
    return (unsigned int)(*v1 >> 31);
  else
    return 0LL;
}

//----- (0000000000004B58) ----------------------------------------------------
__int64 __fastcall HAL_clk_WaitForClockOn(int **a1)
{
  int v2; // w20

  if ( !*a1 )
    return 0xFFFFFFFFLL;
  if ( (**a1 & 2) != 0 )
    return 0LL;
  v2 = 100;
  while ( 1 )
  {
    if ( (unsigned int)HAL_clk_IsClockOn(a1) )
      return 0LL;
    if ( !--v2 )
      break;
    qtiseclib_cb_udelay(1LL);
  }
  return 0xFFFFFFFFLL;
}
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (0000000000004BC8) ----------------------------------------------------
_DWORD *__fastcall HAL_clk_ConfigClockMux(_DWORD *result, unsigned int *a2)
{
  bool v2; // zf
  _DWORD **v3; // x9

  if ( a2 )
    v2 = result == 0LL;
  else
    v2 = 1;
  if ( !v2 && *(_QWORD *)result )
  {
    HAL_clk_GenericConfigMuxOffs_part_0((unsigned __int64)result, a2, 4u, 8u, 0xCu, 0x10u);
    result = *v3;
    **v3 |= 1u;
    while ( (*result & 1) != 0 )
      ;
  }
  return result;
}
// 4BFC: variable 'v3' is possibly undefined

//----- (0000000000004C20) ----------------------------------------------------
__int64 __fastcall HAL_clk_EnablePowerDomain(__int64 result)
{
  unsigned int *v1; // x2
  unsigned int v2; // w1

  v1 = *(unsigned int **)result;
  if ( *(_QWORD *)result )
  {
    v2 = *v1 & 0xFFFFFFFE;
    *(_DWORD *)(result + 8) = !(*(_BYTE *)v1 & 1);
    *v1 = v2;
  }
  return result;
}

//----- (0000000000004C44) ----------------------------------------------------
_DWORD *__fastcall HAL_clk_DisablePowerDomain(_DWORD **a1)
{
  _DWORD *result; // x0

  result = *a1;
  if ( result )
    *result |= 1u;
  return result;
}

//----- (0000000000004C5C) ----------------------------------------------------
__int64 __fastcall HAL_clk_IsPowerDomainOn(_DWORD **a1)
{
  _DWORD *v1; // x0

  v1 = *a1;
  if ( v1 )
    return (unsigned int)(~*v1 >> 31);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000004C7C) ----------------------------------------------------
__int64 __fastcall HAL_clk_WaitForPowerDomainOn(_DWORD **a1)
{
  int v2; // w19
  __int64 result; // x0

  v2 = 10000;
  qtiseclib_cb_udelay(1LL);
  while ( 1 )
  {
    result = HAL_clk_IsPowerDomainOn(a1);
    if ( !(_DWORD)result )
      break;
    if ( !--v2 )
      return 0xFFFFFFFFLL;
    qtiseclib_cb_udelay(1LL);
  }
  return result;
}
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (0000000000004CC8) ----------------------------------------------------
__int64 __fastcall HAL_clk_EnableDFS(__int64 result)
{
  __int64 v1; // x1

  v1 = *(_QWORD *)result;
  if ( *(_QWORD *)result )
  {
    result = *(unsigned int *)(result + 16);
    if ( (_DWORD)result )
    {
      result = 33LL;
      *(_DWORD *)(v1 + 20) = 33;
    }
  }
  return result;
}

//----- (0000000000004CE4) ----------------------------------------------------
unsigned __int64 __fastcall HAL_clk_ConfigDFSMux(unsigned __int64 result, __int64 a2)
{
  unsigned int v2; // w2

  if ( result )
  {
    v2 = *(unsigned __int8 *)(a2 + 10);
    if ( *(_DWORD *)(result + 16) > v2 )
      return HAL_clk_GenericConfigMuxOffs_part_0(
               result,
               (unsigned int *)a2,
               4 * v2 + 28,
               4 * v2 + 92,
               4 * v2 + 156,
               4 * v2 + 220);
  }
  return result;
}

//----- (0000000000004D14) ----------------------------------------------------
__int64 __fastcall vmidmt_SetDefaultConfig_isra_0_part_1(unsigned int **a1, __int64 *a2, char a3)
{
  unsigned int *v3; // x5
  unsigned int *v4; // x0
  __int64 v5; // x5
  int v6; // w4
  unsigned int v7; // w3
  int v8; // w3
  unsigned int v9; // w4
  bool v10; // cc
  int v11; // w6
  unsigned int v12; // w4
  int v13; // w6
  unsigned int v14; // w4
  unsigned int v15; // w3
  unsigned int v16; // w6
  int v17; // w4
  int i; // w3
  int v19; // w8
  _DWORD *v20; // x6
  int v21; // w3
  unsigned int v22; // w7
  int v23; // w8
  unsigned int v24; // w7
  int v25; // w8
  unsigned int v26; // w6
  unsigned int v27; // w7
  unsigned int v28; // w2
  int v29; // w5
  int v30; // w4
  unsigned int v31; // w0
  int v33; // w4

  v3 = (unsigned int *)a2[2];
  v4 = *a1;
  if ( v3 )
  {
    v16 = *v3;
    v17 = 0;
    for ( i = 0; i != 32; ++i )
    {
      if ( ((v16 >> i) & 1) != 0 )
      {
        v19 = (v3[1] >> i) & 1;
        if ( v19 )
          v17 |= v19 << i;
      }
    }
    v4[39] ^= (v4[39] ^ v17) & v16;
    if ( (v4[39] & *v3) != v17 )
      return 7LL;
  }
  v5 = *a2;
  v6 = 0;
  if ( *a2 )
  {
    v7 = *(_DWORD *)(v5 + 4);
    if ( v7 > 3 )
      v8 = 0;
    else
      v8 = v7 << 26;
    v9 = *(_DWORD *)(v5 + 8);
    v10 = v9 > 3;
    v11 = v8 | (v9 << 24);
    v12 = *(_DWORD *)(v5 + 12);
    if ( !v10 )
      v8 = v11;
    v10 = v12 > 3;
    v13 = v8 | (v12 << 22);
    v14 = *(_DWORD *)(v5 + 16);
    if ( !v10 )
      v8 = v13;
    if ( v14 <= 1 )
      v8 |= v14 << 20;
    v6 = v8 | (*(unsigned __int8 *)(v5 + 20) << 16);
    v15 = *(_DWORD *)(v5 + 24);
    if ( v15 <= 3 )
      v6 |= v15 << 6;
  }
  v20 = (_DWORD *)a2[1];
  v21 = 0;
  if ( v20 )
  {
    v21 = *v20 << 30;
    v22 = v20[1];
    if ( *v20 > 1u )
      v21 = 0;
    v10 = v22 > 1;
    v23 = v21 | (v22 << 29);
    v24 = v20[2];
    if ( !v10 )
      v21 = v23;
    v10 = v24 > 1;
    v25 = v21 | (v24 << 28);
    v27 = v20[3];
    v26 = v20[4];
    if ( !v10 )
      v21 = v25;
    if ( v27 <= 1 )
      v21 |= 16 * v27;
    if ( v26 <= 3 )
      v21 |= v26;
  }
  if ( a3 )
  {
    if ( v5 )
    {
      v28 = *(_DWORD *)v5;
      v29 = v6 | (*(_DWORD *)v5 << 28);
      if ( v28 <= 3 )
        v6 = v29;
    }
    *v4 = *v4 & 0xC020FF3F | v6 & 0x3FDF00C0;
    if ( v6 != (*v4 & 0x3FDF00C0) )
      return 7LL;
    v30 = *((unsigned __int8 *)a2 + 24);
    *v4 = ((v30 & 1) << 11) | *v4 & 0xFFFFF7FF;
    if ( ((*v4 >> 11) & 1) != v30 )
      return 7LL;
    v4[2] = v4[2] & 0xFF00 | *((unsigned __int8 *)a2 + 25);
    if ( *((unsigned __int8 *)a2 + 25) != (unsigned __int8)v4[2] )
      return 7LL;
    v4[4] = v21 & 0x70000013;
    v31 = v4[4];
  }
  else
  {
    v4[256] = v4[256] & 0x20FF3F | v6 & 0xFDF00C0;
    if ( v6 != (v4[256] & 0xFDF00C0) )
      return 7LL;
    v33 = *((unsigned __int8 *)a2 + 24);
    v4[256] = ((v33 & 1) << 11) | v4[256] & 0xFFFF7FF;
    if ( ((v4[256] >> 11) & 1) != v33 )
      return 7LL;
    v4[258] = v4[258] & 0xFF00 | *((unsigned __int8 *)a2 + 25);
    if ( *((unsigned __int8 *)a2 + 25) != (unsigned __int8)v4[258] )
      return 7LL;
    v4[260] = v21 & 0x70000013;
    v31 = v4[260];
  }
  if ( v21 == (v31 & 0x70000013) )
    return 0LL;
  return 7LL;
}

//----- (0000000000004FB8) ----------------------------------------------------
__int64 __fastcall vmidmt_ShiftCtxt_isra_2(__int64 a1, int a2, int a3)
{
  _DWORD *v3; // x1
  _DWORD *v4; // x0
  int v5; // w3
  int v6; // w4
  int v7; // w1
  int v8; // w2
  __int64 result; // x0

  v3 = (_DWORD *)(4LL * (a2 & 0x3FFFFFFF) + a1);
  v4 = (_DWORD *)(4LL * (a3 & 0x3FFFFFFF) + a1);
  v5 = v3[512];
  v4[512] = v5;
  if ( v5 != v4[512] )
    return 7LL;
  v6 = v3[768] & 0x30FCFBFF;
  v4[768] = v4[768] & 0xCF030400 | v6;
  if ( v6 != (v4[768] & 0x30FCFBFF) )
    return 7LL;
  v7 = v3[896];
  v4[896] = v7;
  v8 = v4[896];
  result = 0LL;
  if ( v7 != v8 )
    return 7LL;
  return result;
}

//----- (0000000000005034) ----------------------------------------------------
__int64 __fastcall vmidmt_ConfigCtxt_isra_4(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // x5
  int v4; // w3
  int v5; // w3
  unsigned int v6; // w4
  bool v7; // cc
  int v8; // w6
  unsigned int v9; // w4
  int v10; // w6
  unsigned int v11; // w4
  int v12; // w6
  unsigned int v13; // w4
  unsigned int v14; // w4
  __int64 v15; // x0
  int v16; // w3
  _DWORD *v17; // x1
  int v19; // w2
  unsigned int v20; // w3
  int v21; // w4
  unsigned int v22; // w3
  int v23; // w4
  unsigned int v24; // w1
  unsigned int v25; // w3

  v3 = *a3;
  v4 = 0;
  if ( *a3 )
  {
    v5 = *(_DWORD *)v3 << 18;
    v6 = *(_DWORD *)(v3 + 4);
    if ( *(_DWORD *)v3 > 3u )
      v5 = 0;
    v7 = v6 > 3;
    v8 = v5 | (v6 << 22);
    v9 = *(_DWORD *)(v3 + 8);
    if ( !v7 )
      v5 = v8;
    v7 = v9 > 3;
    v10 = v5 | (v9 << 20);
    v11 = *(_DWORD *)(v3 + 12);
    if ( !v7 )
      v5 = v10;
    v7 = v11 > 3;
    v12 = v5 | (v11 << 8);
    v13 = *(_DWORD *)(v3 + 16);
    if ( !v7 )
      v5 = v12;
    if ( v13 <= 1 )
      v5 |= v13 << 11;
    v4 = v5 | (*(unsigned __int8 *)(v3 + 20) << 12);
    v14 = *(_DWORD *)(v3 + 24);
    if ( v14 <= 3 )
      v4 |= v14 << 28;
  }
  v15 = 4LL * (a2 & 0x3FFFFFFF) + a1;
  v16 = *((unsigned __int8 *)a3 + 16) | v4;
  *(_DWORD *)(v15 + 3072) = *(_DWORD *)(v15 + 3072) & 0xCF030400 | v16 & 0x30FCFBFF;
  if ( v16 != (*(_DWORD *)(v15 + 3072) & 0x30FCFBFF) )
    return 7LL;
  v17 = (_DWORD *)a3[1];
  if ( !v17 )
    return 0LL;
  v19 = *v17 << 30;
  v20 = v17[1];
  if ( *v17 > 1u )
    v19 = 0;
  v7 = v20 > 1;
  v21 = v19 | (v20 << 29);
  v22 = v17[2];
  if ( !v7 )
    v19 = v21;
  v7 = v22 > 1;
  v23 = v19 | (v22 << 28);
  v25 = v17[3];
  v24 = v17[4];
  if ( !v7 )
    v19 = v23;
  if ( v25 <= 1 )
    v19 |= 16 * v25;
  if ( v24 <= 3 )
    v19 |= v24;
  *(_DWORD *)(v15 + 3584) = v19;
  if ( v19 == *(_DWORD *)(v15 + 3584) )
    return 0LL;
  else
    return 7LL;
}

//----- (0000000000005160) ----------------------------------------------------
__int64 __fastcall vmidmt_Init(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 *v4; // x9
  __int64 *v5; // x12
  __int64 v6; // x1
  unsigned __int64 v7; // x0
  unsigned int v8; // w10
  __int64 result; // x0
  __int64 *v10; // x1
  int v11; // w10
  __int64 v12; // x11
  unsigned int *v13; // x0
  int v14; // w2
  unsigned int v15; // w2
  unsigned int i; // w1
  unsigned int j; // w1
  __int64 v18; // x4
  __int64 v19; // x5
  unsigned int k; // w1
  __int64 v21; // x4
  unsigned int *v22; // x0
  unsigned int *v23; // x2
  unsigned int v24; // w0
  unsigned int v25; // w1
  _DWORD *v26; // x0
  __int64 v27; // x1

  v4 = a1;
  v5 = a3;
  v6 = *a1;
  v7 = *(unsigned int *)(*a1 + 32);
  *((_BYTE *)v4 + 15) = (v7 & 0x8000000) != 0;
  *((_BYTE *)v4 + 13) = (v7 >> 9) & 0xF;
  *((_WORD *)v4 + 4) = (unsigned __int8)v7;
  *((_BYTE *)v4 + 12) = BYTE1(*(_DWORD *)(v6 + 36)) & 0xF;
  *((_BYTE *)v4 + 14) = *(_DWORD *)(v6 + 40) & 0xF;
  *((_WORD *)v4 + 5) = (unsigned __int8)*(_DWORD *)(v6 + 52);
  *(_DWORD *)(v6 + 156) = -1;
  if ( a2 )
  {
    v8 = *(unsigned __int8 *)(a2 + 9);
    if ( v8 != 255 && v8 > (unsigned __int8)v7 )
      goto LABEL_4;
    v10 = *(__int64 **)a2;
    if ( !*(_QWORD *)a2 || *v10 && *(unsigned __int8 *)(*v10 + 20) > 7u )
      goto LABEL_4;
    result = vmidmt_SetDefaultConfig_isra_0_part_1((unsigned int **)v4, v10, 1);
    if ( (_DWORD)result )
      goto LABEL_17;
    v13 = (unsigned int *)*v4;
    v14 = *(unsigned __int8 *)(v12 + 8);
    v13[1] = ((v14 & 1) << 24) | *(_DWORD *)(*v4 + 4) & 0xFF00;
    if ( (HIBYTE(v13[1]) & 1) != v14
      || (v13[1] = v13[1] & 0x1000000 | (v11 << 8), (unsigned __int8)BYTE1(v13[1]) != v11) )
    {
      result = 7LL;
      goto LABEL_17;
    }
  }
  else
  {
    *(_DWORD *)v6 = 273;
    *(_QWORD *)(v6 + 4) = (unsigned __int8)v7 << 8;
    *(_DWORD *)(v6 + 16) = 0;
  }
  if ( !v5 )
  {
    v22 = (unsigned int *)*v4;
    v22[256] = 273;
    v22[258] = 0;
    v22[260] = 0;
    goto LABEL_30;
  }
  if ( *v5 && *(unsigned __int8 *)(*v5 + 20) > 7u )
  {
LABEL_4:
    result = 5LL;
    goto LABEL_17;
  }
  result = vmidmt_SetDefaultConfig_isra_0_part_1((unsigned int **)v4, v5, 0);
  if ( (_DWORD)result )
    goto LABEL_17;
LABEL_30:
  v23 = (unsigned int *)*v4;
  v23[36] = 1;
  v23[292] = 1;
  v23[19] = 0;
  v23[275] = 0;
  v24 = 1 << *((_BYTE *)v4 + 12);
  if ( v24 <= 0x1F )
  {
    v23[32] = -1;
  }
  else
  {
    v25 = v24 >> 5;
    result = 6LL;
    if ( v25 > 4 )
      goto LABEL_17;
    v26 = v23 + 32;
    v27 = (__int64)&v23[v25 + 32];
    do
      *v26++ = -1;
    while ( (_DWORD *)v27 != v26 );
  }
  result = 0LL;
LABEL_17:
  v15 = *((unsigned __int16 *)v4 + 4);
  if ( *((_BYTE *)v4 + 15) == 1 )
  {
    for ( i = 0; i < v15; ++i )
    {
      v18 = 4LL * (i & 0x3FFFFFFF);
      *(_DWORD *)(*v4 + 2048 + v18) = 0;
    }
  }
  for ( j = 0; j < v15; ++j )
  {
    v19 = 4LL * (j & 0x3FFFFFFF);
    *(_DWORD *)(*v4 + 3072 + v19) = 0x10000;
  }
  for ( k = 0; k < v15; ++k )
  {
    v21 = 4LL * (k & 0x3FFFFFFF);
    *(_DWORD *)(*v4 + 3584 + v21) = 0;
  }
  return result;
}
// 5220: variable 'v4' is possibly undefined
// 5224: variable 'v12' is possibly undefined
// 525C: variable 'v11' is possibly undefined
// 5290: variable 'v5' is possibly undefined

//----- (00000000000053DC) ----------------------------------------------------
__int64 __fastcall vmidmt_EnableClientP(int **a1, char a2)
{
  int *v2; // x0
  int v3; // w0

  v2 = *a1;
  if ( a2 )
  {
    *v2 &= ~1u;
    v3 = *v2;
  }
  else
  {
    v2[256] &= 0xFFFFFFEu;
    v3 = v2[256];
  }
  if ( (v3 & 1) != 0 )
    return 7LL;
  else
    return 0LL;
}

//----- (0000000000005420) ----------------------------------------------------
__int64 __fastcall vmidmt_ConfigSSDT(__int64 a1, __int64 a2, unsigned int a3)
{
  bool v4; // cc
  __int64 result; // x0
  unsigned int v6; // w3
  __int64 v7; // x2
  __int64 i; // x3
  __int64 v9; // x0
  int v10; // w5

  if ( a2 )
    v4 = a3 > 4;
  else
    v4 = 1;
  result = 5LL;
  if ( !v4 )
  {
    v6 = 1 << *(_BYTE *)(a1 + 12);
    result = 5LL;
    if ( v6 <= 0x1F )
    {
      if ( a3 > 1 )
        return result;
    }
    else if ( a3 > v6 >> 5 )
    {
      return result;
    }
    v7 = 4LL * a3;
    for ( i = 0LL; i != v7; i += 4LL )
    {
      v9 = (unsigned int)i;
      v10 = *(_DWORD *)(a2 + i);
      *(_DWORD *)(*(_QWORD *)a1 + 128LL + v9) &= v10;
    }
    return 0LL;
  }
  return result;
}

//----- (00000000000054A4) ----------------------------------------------------
__int64 __fastcall vmidmt_ConfigVmidCtxt(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v3; // x8
  unsigned int v4; // w3
  __int64 result; // x0
  __int64 v6; // x3
  unsigned int v7; // w10
  __int64 v8; // x5
  __int64 v9; // x4
  __int64 v10; // x6
  int v11; // w3
  int v12; // w9
  __int64 *v13; // x11
  unsigned int v14; // w9
  int v15; // w7
  unsigned int v16; // w12
  int *v17; // x5
  unsigned int v18; // w7
  unsigned int i; // w6
  int v20; // t1
  unsigned int v21; // w13
  __int64 v23; // x1
  unsigned int v24; // w2
  _DWORD *v25; // x6
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x1
  int v29; // w1
  __int64 v30; // x2
  __int64 v31; // x1
  int v32; // w3
  __int64 v33; // x1
  __int64 v34; // x0
  __int64 v35; // x1
  unsigned int v36; // w7

  if ( !a3 )
    return 5LL;
  v3 = a1;
  if ( (1 << *(_BYTE *)(a1 + 13)) - 1 >= a2 || (v4 = *(unsigned __int16 *)(a1 + 8), result = 5LL, a2 < v4) )
  {
    v6 = *a3;
    if ( *a3 )
    {
      result = 5LL;
      if ( *(unsigned __int8 *)(v6 + 20) > 7u )
        return result;
      v7 = *(_DWORD *)v6 == 2;
    }
    else
    {
      v7 = 0;
    }
    v8 = *(_QWORD *)v3;
    v9 = 4LL * (a2 >> 5);
    v10 = *(_QWORD *)v3 + 128LL;
    v11 = 1 << a2;
    if ( v7 )
      v12 = ~v11;
    else
      v12 = 1 << a2;
    *(_DWORD *)(v9 + v10) ^= (v12 ^ *(_DWORD *)(v9 + v10)) & v11;
    if ( (v11 & *(_DWORD *)(v9 + v10)) != (v12 & v11) )
      return 7LL;
    v13 = a3;
    v14 = a2;
    if ( *(_BYTE *)(v3 + 15) == 1 )
    {
      v15 = *(_DWORD *)(v8 + 4);
      v16 = a2 | 0x80000000;
      v17 = (int *)(v8 + 2048);
      v18 = BYTE1(v15);
      for ( i = 0; (int)i < *(unsigned __int16 *)(v3 + 8); ++i )
      {
        v20 = *v17++;
        if ( v16 == v20 )
        {
          if ( v7 && v18 - 1 <= i || (v18 > i) > v7 )
            return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
          result = 0LL;
          if ( v18 <= i )
          {
            while ( v18 < i && (_DWORD)result == 0 )
              result = vmidmt_ShiftCtxt_isra_2(*(_QWORD *)v3, i - 1, i);
            if ( (_DWORD)result )
              return result;
            v23 = *(_QWORD *)v3;
            v24 = v18 + 1;
            *(_DWORD *)(v23 + 4) = ((unsigned __int8)(v18 + 1) << 8) | *(_DWORD *)(*(_QWORD *)v3 + 4LL) & 0x1000000;
            v18 = (unsigned __int8)BYTE1(*(_DWORD *)(v23 + 4));
            if ( v24 != v18 )
              return 7LL;
          }
          else
          {
            v21 = v18 - 1;
            while ( v21 > i )
            {
              if ( (_DWORD)result )
                return result;
              result = vmidmt_ShiftCtxt_isra_2(*(_QWORD *)v3, i + 1, i);
            }
            if ( (_DWORD)result )
              return result;
          }
          v25 = (_DWORD *)(4LL * (i & 0x3FFFFFFF) + *(_QWORD *)v3);
          v25[512] = 0;
          if ( v25[512] )
            return 7LL;
          v25[768] &= 0xCF030400;
          if ( (v25[768] & 0x30FCFBFF) != 0 )
            return 7LL;
          v25[896] = 0;
          if ( v25[896] )
            return 7LL;
          break;
        }
      }
      if ( v7 )
      {
        i = *(unsigned __int16 *)(v3 + 8) - 1;
        v27 = (int)(4 * i);
        while ( i != -1 )
        {
          v28 = *(_QWORD *)v3 + 2048LL;
          if ( (*(_DWORD *)(v28 + v27) & 0x80000000) == 0
            || (v29 = *(_DWORD *)(v28 + v27), v27 -= 4LL, v14 == (v29 & 0x7FFF)) )
          {
            if ( v18 - 1 > i )
              return 5LL;
            goto LABEL_51;
          }
          --i;
        }
        return 5LL;
      }
      v26 = 0LL;
      do
      {
        i = v26;
        v32 = v26;
        if ( v18 == v26 )
          break;
        v30 = 4 * v26;
        v31 = *(_QWORD *)v3 + 2048LL;
        if ( (*(_DWORD *)(v31 + 4 * v26) & 0x80000000) == 0 )
          break;
        ++v26;
      }
      while ( v14 != (*(_DWORD *)(v31 + v30) & 0x7FFF) );
      if ( v18 == v32 )
        return 5LL;
LABEL_51:
      v33 = *(_QWORD *)v3 + 2048LL;
      v34 = (int)(4 * i);
      *(_DWORD *)(v33 + v34) = v16;
      if ( v16 != *(_DWORD *)(v33 + v34) )
        return 7LL;
    }
    else
    {
      v18 = 0;
      i = 0;
    }
    if ( ((unsigned __int8)v7 & (v18 > i)) == 0 )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
    v35 = *(_QWORD *)v3;
    v36 = v18 - 1;
    *(_DWORD *)(v35 + 4) = *(_DWORD *)(*(_QWORD *)v3 + 4LL) & 0x1000000 | (v36 << 8);
    if ( v36 == (unsigned __int8)BYTE1(*(_DWORD *)(v35 + 4)) )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)v3, i, v13);
    else
      return 7LL;
  }
  return result;
}
// 55D0: variable 'v21' is possibly undefined
// 55D0: variable 'i' is possibly undefined
// 55DC: variable 'v3' is possibly undefined
// 55FC: variable 'v18' is possibly undefined
// 5694: variable 'v7' is possibly undefined
// 56DC: variable 'v14' is possibly undefined
// 5748: variable 'v16' is possibly undefined
// 57B4: variable 'v13' is possibly undefined

//----- (00000000000057C4) ----------------------------------------------------
__int64 __fastcall vmidmt_ConfigVmidCtxtWithSIDList(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        __int64 *a5)
{
  __int64 result; // x0
  unsigned int v8; // w5
  __int64 v9; // x0
  unsigned int v10; // w6
  unsigned int v11; // w7
  int v12; // w10
  __int64 v15; // x2
  __int64 v16; // x0
  unsigned int v17; // w6

  if ( *(unsigned __int16 *)(a1 + 8) <= a2 || a5 == 0LL )
    return 5LL;
  if ( *a5 )
  {
    result = 5LL;
    if ( *(unsigned __int8 *)(*a5 + 20) > 7u )
      return result;
  }
  v8 = *(unsigned __int8 *)(a1 + 15);
  if ( v8 != 1 )
    return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)a1, a2, a5);
  if ( !a3 )
    return 5LL;
  if ( *(_BYTE *)(a1 + 13) )
    v8 = (1 << *(_BYTE *)(a1 + 13)) - 1;
  v9 = 0LL;
  v10 = 0;
  v11 = 0;
  while ( v9 != a4 )
  {
    v12 = *(_DWORD *)(a3 + 4 * v9);
    v11 |= v12;
    if ( a4 > (int)v9 + 1 )
      v10 |= v12 ^ *(_DWORD *)(a3 + 4LL * (unsigned int)(v9 + 1));
    ++v9;
  }
  result = 5LL;
  if ( v8 >= v11 && v8 >= v10 )
  {
    v15 = 4LL * (a2 & 0x3FFFFFFF);
    v16 = *(_QWORD *)a1 + 2048LL;
    v17 = v11 | 0x80000000 | (v10 << 16);
    *(_DWORD *)(v16 + v15) = v17;
    if ( v17 == *(_DWORD *)(v16 + v15) )
      return vmidmt_ConfigCtxt_isra_4(*(_QWORD *)a1, a2, a5);
    return 7LL;
  }
  return result;
}

//----- (00000000000058A4) ----------------------------------------------------
__int64 __fastcall vmidmt_ConfigErrRep(__int64 a1, char a2, int a3)
{
  int v3; // w3
  bool v4; // zf
  unsigned int *v5; // x2
  unsigned int v6; // w1

  if ( (a3 & 0xFFFFFFE0) != 0 )
    return 5LL;
  v3 = 0;
  if ( (a3 & 1) != 0 )
    v3 = (*(_BYTE *)(a1 + 15) == 1) << 21;
  if ( (a3 & 2) != 0 )
    v3 |= 0x400u;
  if ( (a3 & 4) != 0 )
    v3 |= 0x20u;
  if ( (a3 & 8) != 0 )
    v3 |= 0x10u;
  v4 = (a3 & 0x10) == 0LL;
  v5 = *(unsigned int **)a1;
  if ( !v4 )
    v3 |= 4u;
  if ( a2 )
  {
    *v5 = *v5 & 0xFFDFFBCB | v3 & 0x200434;
    v6 = *v5;
  }
  else
  {
    v5[256] = v5[256] & 0xFDFFBCB | v3 & 0x200434;
    v6 = v5[256];
  }
  if ( v3 == (v6 & 0x200434) )
    return 0LL;
  else
    return 7LL;
}

//----- (0000000000005968) ----------------------------------------------------
bool __fastcall vmidmt_IsError(__int64 *a1, char a2)
{
  bool v2; // zf
  __int64 v3; // x1
  int v4; // w1

  v2 = a2 == 0;
  v3 = *a1;
  if ( v2 )
    v4 = *(_DWORD *)(v3 + 1096);
  else
    v4 = *(_DWORD *)(v3 + 72);
  return (v4 & 0xC00000A6) != 0;
}

//----- (0000000000005994) ----------------------------------------------------
__int64 __fastcall vmidmt_GetError(__int64 result, unsigned __int8 a2, _DWORD *a3)
{
  __int64 v4; // x20
  int v5; // w21
  _DWORD *v6; // x1
  unsigned int v7; // w2
  int v8; // w4
  int v9; // w3
  unsigned __int64 v10; // x0
  int v11; // w1

  if ( a3 )
  {
    v4 = result;
    v5 = a2;
    qtiseclib_cb_memset(a3, 0LL, 44LL);
    v6 = *(_DWORD **)v4;
    if ( v5 )
    {
      v7 = v6[18] & 0xC00000A6;
      a3[2] = v6[16];
      if ( *(_BYTE *)(v4 + 14) )
        a3[3] = v6[17];
      v8 = v6[21];
      v9 = v6[20] & 0x1FF;
      v10 = (unsigned int)v6[22];
    }
    else
    {
      v7 = v6[274] & 0xC00000A6;
      a3[2] = v6[272];
      if ( *(_BYTE *)(v4 + 14) )
        a3[3] = v6[273];
      v8 = v6[277];
      v10 = (unsigned int)v6[278];
      v9 = v6[276] & 0x1FF;
    }
    if ( (v7 & 0x80000000) != 0 )
      *a3 |= 1u;
    if ( (v7 & 0x40000000) != 0 )
      *a3 |= 2u;
    if ( (v7 & 0x80) != 0 )
      *a3 |= 4u;
    if ( (v7 & 0x20) != 0 )
      *a3 |= 8u;
    if ( (v7 & 4) != 0 )
      *a3 |= 0x10u;
    if ( (v7 & 2) != 0 )
      *a3 |= 0x20u;
    if ( (v9 & 0x20) != 0 )
      a3[1] |= 1u;
    if ( (v9 & 0x10) != 0 )
      a3[1] |= 2u;
    if ( (v9 & 2) != 0 )
      a3[1] |= 4u;
    a3[4] = BYTE2(v8);
    a3[5] = v8 & 0x7FFF;
    a3[6] = (unsigned __int8)v10;
    a3[7] = BYTE2(v10);
    a3[8] = BYTE3(v10);
    v11 = (unsigned __int16)v10 >> 13;
    result = (v10 >> 8) & 0x1F;
    a3[9] = v11;
    a3[10] = result;
  }
  return result;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000005B0C) ----------------------------------------------------
__int64 __fastcall vmidmt_ClearError(__int64 *a1, char a2)
{
  bool v2; // zf
  __int64 v3; // x1
  int v4; // w1

  v2 = a2 == 0;
  v3 = *a1;
  if ( v2 )
  {
    *(_DWORD *)(v3 + 1100) = 0;
    v4 = *(_DWORD *)(v3 + 1100);
  }
  else
  {
    *(_DWORD *)(v3 + 76) = 0;
    v4 = *(_DWORD *)(v3 + 76);
  }
  if ( (v4 & 0xC00000A6) != 0 )
    return 7LL;
  else
    return 0LL;
}

//----- (0000000000005B48) ----------------------------------------------------
unsigned __int64 __fastcall qtisec_malloc(unsigned __int64 a1)
{
  unsigned __int64 result; // x0

  if ( !heapHasInit )
  {
    mem_magic_number = (__int64)&magic_num;
    qword_2FD10 = (__int64)&magic_num_index_array;
    word_2FD18 = 0;
    if ( (unsigned int)mem_init_heap(atfHeapDesc, &mem_magic_number, (__int64)&atfHeap, 0x10000uLL) == 1 )
      heapHasInit = 1;
    else
      qtiseclib_cb_log(10LL, "Heap init failed !");
  }
  result = 0LL;
  if ( heapHasInit )
  {
    if ( a1 > 0xFFFF )
    {
      qtiseclib_cb_log(10LL, "Heap length 0x%x not supported !", a1);
    }
    else
    {
      result = mem_malloc((__int64)atfHeapDesc, &mem_magic_number, a1);
      if ( result )
        return result;
    }
    qtiseclib_cb_log(10LL, "Heap Exhausted !");
    return 0LL;
  }
  return result;
}
// 2FD08: using guessed type __int64 mem_magic_number;
// 2FD10: using guessed type __int64 qword_2FD10;
// 2FD18: using guessed type __int16 word_2FD18;
// 2FD20: using guessed type char heapHasInit;
// 2FD28: using guessed type int atfHeapDesc[20];
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000005C2C) ----------------------------------------------------
unsigned __int64 __fastcall qtisec_realloc(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x19
  bool v5; // zf

  if ( !heapHasInit )
  {
    qtiseclib_cb_log(10LL, "Heap un-initialized !");
    return 0LL;
  }
  if ( a2 > 0xFFFF )
  {
    qtiseclib_cb_log(10LL, "Heap length 0x%x not supported !", a2);
    return 0LL;
  }
  v3 = mem_realloc((__int64)atfHeapDesc, &mem_magic_number, a1, a2);
  v5 = a2 == 0;
  v4 = v3;
  v5 = !v5 && v3 == 0;
  if ( v5 )
    qtiseclib_cb_log(10LL, "Heap Exhausted !");
  return v4;
}
// 2FD08: using guessed type __int64 mem_magic_number;
// 2FD20: using guessed type char heapHasInit;
// 2FD28: using guessed type int atfHeapDesc[20];
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000005CD4) ----------------------------------------------------
__int64 __fastcall qtisec_free(__int64 a1)
{
  return mem_free((__int64)atfHeapDesc, &mem_magic_number, a1);
}
// 2FD08: using guessed type __int64 mem_magic_number;
// 2FD28: using guessed type int atfHeapDesc[20];

//----- (0000000000005CEC) ----------------------------------------------------
__int64 cpucp_host_handle_irq()
{
  return 0LL;
}

//----- (0000000000005CF4) ----------------------------------------------------
__int64 __fastcall cpucp_host_clock_domain_enable(__int64 a1)
{
  cpucp_clkdom_init(a1);
  return 0LL;
}

//----- (0000000000005D0C) ----------------------------------------------------
__int64 cpucp_host_error_handler()
{
  return 0LL;
}

//----- (0000000000005D14) ----------------------------------------------------
__int64 cpucp_host_init()
{
  return 0LL;
}

//----- (0000000000005D1C) ----------------------------------------------------
__int64 cpucp_host_clock_domain_init()
{
  return 0LL;
}

//----- (0000000000005D24) ----------------------------------------------------
__int64 cpucp_host_clock_domain_disable()
{
  return 0LL;
}

//----- (0000000000005D2C) ----------------------------------------------------
__int64 cpucp_host_send_message()
{
  return 0LL;
}

//----- (0000000000005D34) ----------------------------------------------------
__int64 cpucp_host_recv_message()
{
  return 0LL;
}

//----- (0000000000005D3C) ----------------------------------------------------
__int64 __fastcall cpucp_iface_initialize(_QWORD *a1)
{
  int *v1; // x2
  _QWORD *v2; // x0
  int v3; // w1
  int v4; // t1

  a1[1] = cpucp_prepare;
  a1[2] = cpucp_unprepare;
  a1[3] = cpucp_load_firmware;
  a1[4] = cpucp_host_init;
  v1 = &dword_1A61C;
  a1[8] = cpucp_host_configure_shared_data;
  a1[9] = cpucp_host_error_handler;
  a1[10] = cpucp_host_send_message;
  a1[11] = cpucp_host_recv_message;
  a1[5] = cpucp_start;
  v2 = a1 + 12;
  v3 = 0;
  do
  {
    *(_DWORD *)v2 = v3++;
    v2[4] = cpucp_host_clock_domain_init;
    v2[5] = cpucp_host_clock_domain_enable;
    v2[6] = cpucp_host_clock_domain_disable;
    v2 += 10;
    *(v2 - 1) = cpucp_host_handle_irq;
    v4 = *v1;
    v1 += 2;
    *((_DWORD *)v2 - 18) = v4;
  }
  while ( v3 != 4 );
  return 0LL;
}
// 1A61C: using guessed type int dword_1A61C;

//----- (0000000000005E08) ----------------------------------------------------
__int64 icbcfg_init()
{
  __int64 result; // x0
  unsigned int *v1; // x24
  __int64 v2; // x26
  unsigned int v3; // w21
  unsigned int v4; // w20
  unsigned int v5; // w22
  unsigned int i; // w23
  int *v7; // x19
  int v8; // w1
  int v9; // w2
  int v10; // w4
  int v11; // w1
  int v12; // w1
  int v13; // w1
  int v14; // w2
  int v15; // w3
  int v16; // w1
  int v17; // w2
  int v18; // w3
  int v19; // w2
  int v20; // w3
  int v21; // w4
  int v22; // w1
  int v23; // w2
  int v24; // w3
  int v25; // w5
  int v26; // w1
  int v27; // w2
  int v28; // w3
  int v29; // w5
  int v30; // w1
  int v31; // w27
  int v32; // w27
  int v33; // w27

  if ( !icb_dev_config_valid )
  {
    icb_dev_config = (__int64)*off_1A820;
    icb_dev_config_valid = 1;
  }
  result = (unsigned __int8)icb_dev_config_valid;
  if ( icb_dev_config_valid )
  {
    result = icb_dev_config;
    v1 = *(unsigned int **)(icb_dev_config + 48);
    if ( v1 )
    {
      v2 = *((_QWORD *)v1 + 1);
      v3 = 0;
      v4 = 0;
      v5 = 0;
      for ( i = 0; ; ++i )
      {
        result = *v1;
        if ( i >= (unsigned int)result )
          break;
        v7 = (int *)(v2 + 32LL * i);
        v8 = *v7;
        result = *((_QWORD *)v7 + 1);
        if ( !result && v8 != 1 )
          break;
        switch ( v8 )
        {
          case 1:
            return result;
          case 2:
            v9 = v7[4];
            v10 = v7[5];
            v11 = v7[6];
            if ( v9 == v10 )
              v12 = v9 & v11;
            else
              v12 = (v10 & *(_DWORD *)result ^ v11) & v9 ^ v10 & *(_DWORD *)result;
            goto LABEL_25;
          case 3:
            v13 = v7[4];
            v14 = v7[5];
            v15 = v7[6];
            if ( v13 == v14 )
              LOWORD(v13) = v15 & v13;
            else
              LOWORD(v13) = *(_WORD *)result & v14 ^ (*(_WORD *)result & v14 ^ v15) & v13;
            goto LABEL_29;
          case 4:
            v16 = v7[4];
            v17 = v7[5];
            v18 = v7[6];
            if ( v16 == v17 )
              LOBYTE(v16) = v18 & v16;
            else
              LOBYTE(v16) = *(_BYTE *)result & v17 ^ (*(_BYTE *)result & v17 ^ v18) & v16;
            goto LABEL_33;
          case 5:
            v5 = (v7[5] & (unsigned int)v7[4] & *(_DWORD *)result) >> v7[6];
            continue;
          case 6:
            v4 = (v7[5] & v7[4] & (unsigned int)*(unsigned __int16 *)result) >> v7[6];
            continue;
          case 7:
            v3 = (v7[5] & v7[4] & (unsigned int)*(unsigned __int8 *)result) >> v7[6];
            continue;
          case 8:
            v19 = v7[4];
            v20 = v7[5];
            v21 = v7[6];
            v22 = v19 & v5;
            if ( v19 == v20 )
              v12 = v22 << v21;
            else
              v12 = *(_DWORD *)result & ~v19 & v20 | (v22 << v21);
LABEL_25:
            *(_DWORD *)result = v12;
            continue;
          case 9:
            v23 = v7[4];
            v24 = v7[5];
            v25 = v7[6];
            v26 = v4 & v23;
            if ( v23 == v24 )
              v13 = v26 << v25;
            else
              v13 = (unsigned __int16)(*(_WORD *)result & v24) & ~v23 | (v26 << v25);
LABEL_29:
            *(_WORD *)result = v13;
            break;
          case 10:
            v27 = v7[4];
            v28 = v7[5];
            v29 = v7[6];
            v30 = v3 & v27;
            if ( v27 == v28 )
              v16 = v30 << v29;
            else
              v16 = (unsigned __int8)(*(_BYTE *)result & v28) & ~v27 | (v30 << v29);
LABEL_33:
            *(_BYTE *)result = v16;
            break;
          case 11:
            v31 = 1000;
            v5 = v7[5] & v7[4] & *(_DWORD *)result;
            do
            {
              if ( v7[6] == v5 )
                break;
              qtiseclib_cb_udelay(1LL);
              --v31;
              v5 = v7[5] & v7[4] & **((_DWORD **)v7 + 1);
            }
            while ( v31 );
            break;
          case 12:
            v32 = 1000;
            v4 = *(unsigned __int16 *)result & v7[5] & v7[4];
            do
            {
              if ( v4 == v7[6] )
                break;
              qtiseclib_cb_udelay(1LL);
              --v32;
              v4 = **((unsigned __int16 **)v7 + 1) & v7[5] & v7[4];
            }
            while ( v32 );
            break;
          case 13:
            v33 = 1000;
            v3 = *(unsigned __int8 *)result & v7[5] & v7[4];
            do
            {
              if ( v3 == v7[6] )
                break;
              qtiseclib_cb_udelay(1LL);
              --v33;
              v3 = **((unsigned __int8 **)v7 + 1) & v7[5] & v7[4];
            }
            while ( v33 );
            break;
          default:
            continue;
        }
      }
    }
  }
  return result;
}
// 1A820: using guessed type void **off_1A820;
// 2FD80: using guessed type __int64 icb_dev_config;
// 2FD90: using guessed type char icb_dev_config_valid;
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (0000000000006198) ----------------------------------------------------
__int64 __fastcall get_addr_translation(__int64 a1)
{
  int v2; // w23
  __int64 result; // x0
  __int64 v4; // x21
  int v5; // w4
  unsigned int v6; // w3
  unsigned int *v7; // x7
  __int64 *v8; // x0
  unsigned int *v9; // x5
  unsigned __int64 v10; // x8
  int v11; // w4
  __int64 v12; // x9
  __int64 *v13; // x0
  unsigned int *v14; // x8
  int v15; // w10
  unsigned int v16; // w2
  unsigned int v17; // w5
  bool v18; // w6
  unsigned int v19; // w2
  unsigned int v20; // w6
  bool v21; // w9
  __int64 v22; // x23
  __int64 v23; // x2
  __int64 *v24; // x5

  v2 = *(_DWORD *)(a1 + 32);
  qtiseclib_cb_memset(addr_trans_segs, 0LL, 168LL);
  result = *(unsigned int *)(a1 + 36);
  v4 = 1LL << ((unsigned __int8)v2 - 1);
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result != 1 )
      return result;
    v5 = 0;
    v6 = *(_DWORD *)(a1 + 24);
    v7 = **(unsigned int ***)(a1 + 40);
    v8 = addr_trans_segs;
    v9 = v7 + 1;
    v10 = ((unsigned __int64)*v7 >> 4) & 0x3F;
    while ( v5 != v6 )
    {
      if ( v5 )
        *v8 = ((unsigned __int64)(v7[4 * ((v5 + 0xFFFFFFF) & 0xFFFFFFF) + 4] & 0xF) << 32) | v7[4
                                                                                              * ((v5 + 0xFFFFFFF) & 0xFFFFFFF)
                                                                                              + 3];
      else
        addr_trans_segs[0] = 0LL;
      v19 = *v9;
      v20 = v9[1];
      v21 = ((1 << v5++) & (unsigned int)v10) != 0;
      *((_BYTE *)v8 + 16) = v21;
      v9 += 4;
      v8 += 3;
      *(v8 - 2) = ((((unsigned __int64)(v20 & 0xF) << 32) | v19) ^ v4) - v4;
    }
  }
  else
  {
    v11 = 0;
    v6 = *(_DWORD *)(a1 + 24);
    v12 = **(_QWORD **)(a1 + 40);
    v13 = addr_trans_segs;
    v14 = (unsigned int *)(v12 + 24);
    v15 = *(_DWORD *)(v12 + 16) & 0x3F;
    while ( v11 != v6 )
    {
      if ( v11 )
        *v13 = ((unsigned __int64)(*(_DWORD *)(v12 + 16LL * ((v11 + 0xFFFFFFF) & 0xFFFFFFF) + 36) & 0xF) << 32) | *(unsigned int *)(v12 + 16LL * ((v11 + 0xFFFFFFF) & 0xFFFFFFF) + 32);
      else
        addr_trans_segs[0] = 0LL;
      v16 = *v14;
      v17 = v14[1];
      v18 = ((1 << v11++) & v15) != 0;
      *((_BYTE *)v13 + 16) = v18;
      v14 += 4;
      v13 += 3;
      *(v13 - 2) = ((((unsigned __int64)(v17 & 0xF) << 32) | v16) ^ v4) - v4;
    }
  }
  result = 1LL;
  v22 = 1LL << v2;
  while ( v6 <= 6 )
  {
    v23 = v6++;
    v24 = &addr_trans_segs[3 * v23];
    *v24 = v22;
    *((_BYTE *)v24 + 16) = 1;
  }
  return result;
}
// 2FD98: using guessed type __int64 addr_trans_segs[];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000006378) ----------------------------------------------------
__int64 __fastcall get_device_configuration_isra_0(_QWORD *a1)
{
  if ( !query_dev_config_valid )
  {
    icb_dev_config_0 = (__int64)*off_1A820;
    get_addr_translation(icb_dev_config_0);
    query_dev_config_valid = 1;
  }
  *a1 = icb_dev_config_0;
  return (unsigned __int8)query_dev_config_valid;
}
// 1A820: using guessed type void **off_1A820;
// 2FD88: using guessed type __int64 icb_dev_config_0;
// 2FD91: using guessed type char query_dev_config_valid;

//----- (00000000000063D4) ----------------------------------------------------
__int64 __fastcall get_system_memory_map(__int64 a1, _QWORD *a2)
{
  __int64 v4; // x2
  unsigned int v5; // w4
  __int64 *v6; // x1
  __int64 v7; // x5
  char *v8; // x6
  _QWORD *v9; // x6
  unsigned int i; // w21
  __int64 result; // x0
  __int64 v12; // x0

  qtiseclib_cb_memset(a2, 0LL, 576LL);
  v4 = 0LL;
  v5 = 0;
  v6 = (__int64 *)&byte_2FDA8;
  do
  {
    if ( *(_BYTE *)v6 )
    {
      v9 = &a2[3 * v5];
      if ( *v9 )
      {
        ++v5;
        v9[1] = v9[1] - v4 + *(v6 - 2);
      }
    }
    else
    {
      v7 = *(v6 - 2);
      v8 = (char *)&a2[3 * v5];
      if ( *(_QWORD *)v8 )
      {
        *((_QWORD *)v8 + 1) = *((_QWORD *)v8 + 1) - v4 + v7;
        v4 = v7;
      }
      else
      {
        a2[3 * v5] = v7;
        v4 = v7;
        v8[16] = 1;
      }
    }
    v6 += 3;
  }
  while ( v6 != &info );
  for ( i = 1; ; ++i )
  {
    result = *(unsigned int *)(a1 + 28);
    if ( i >= (unsigned int)result )
      break;
    v12 = i;
    memcpy(&a2[18 * v12], a2, 0x90uLL);
  }
  return result;
}
// 2FDA8: using guessed type char byte_2FDA8;
// 2FE50: using guessed type __int64 info;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (00000000000064D4) ----------------------------------------------------
__int64 __fastcall translate_address(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // x0

  result = 0LL;
  *a3 = a2;
  return result;
}

//----- (00000000000064E0) ----------------------------------------------------
bool __fastcall check_overlap(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // x2
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x4
  _BOOL8 result; // x0

  v2 = *a1;
  v3 = *a2;
  if ( *a1 >= *a2 || (v4 = a1[1], result = 0LL, v3 < v2 + v4) )
  {
    result = 1LL;
    if ( v2 > v3 )
      return v2 < v3 + a2[1];
  }
  return result;
}

//----- (0000000000006524) ----------------------------------------------------
__int64 __fastcall compare_ch_segments(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        int a8)
{
  int v8; // w1
  unsigned int v9; // w5
  int j; // w3
  unsigned int v11; // w5
  int i; // w3
  __int64 *v13; // x1
  __int64 *v14; // x1
  __int64 v15; // t1
  __int64 v16; // x4
  __int64 v17; // x11
  __int64 v18; // x4
  unsigned int v19; // w8
  int v20; // w14
  int v21; // w9
  __int64 v22; // x10
  __int64 *v23; // x1
  __int64 *v24; // x1
  __int64 v25; // t1
  __int64 v26; // x4
  __int64 v27; // x11
  __int64 v28; // x4
  unsigned int v29; // w8
  int v30; // w14
  int v31; // w9
  __int64 v32; // x10

  v8 = *(_DWORD *)(a1 + 36);
  if ( !v8 )
  {
    v11 = -16;
    for ( i = 0; i != *(_DWORD *)(a1 + 24); ++i )
    {
      v13 = *(__int64 **)(a1 + 40);
      if ( i )
      {
        a8 = *(_DWORD *)(*v13 + v11 + 32LL);
        a3 = *(_DWORD *)(*v13 + v11 + 36LL) & 0xF;
      }
      v15 = *v13;
      v14 = v13 + 1;
      v16 = 16LL * (i & 0xFFFFFFF);
      v17 = v16 + 24;
      v18 = v16 + 28;
      v19 = 1;
      v20 = *(_DWORD *)(v15 + v17);
      v21 = *(_DWORD *)(v15 + v18) & 0xF;
      while ( v19 < *(_DWORD *)(a1 + 28) )
      {
        if ( i && (a8 != *(_DWORD *)(*v14 + v11 + 32LL) || a3 != (*(_DWORD *)(*v14 + v11 + 36LL) & 0xF)) )
          return 0xFFFFFFFFLL;
        v22 = *v14;
        if ( v20 != *(_DWORD *)(*v14 + v17) )
          return 0xFFFFFFFFLL;
        ++v14;
        if ( v21 != (*(_DWORD *)(v22 + v18) & 0xF) )
          return 0xFFFFFFFFLL;
        ++v19;
      }
      v11 += 16;
    }
    return 0LL;
  }
  if ( v8 == 1 )
  {
    v9 = -16;
    for ( j = 0; j != *(_DWORD *)(a1 + 24); ++j )
    {
      v23 = *(__int64 **)(a1 + 40);
      if ( j )
      {
        a8 = *(_DWORD *)(*v23 + v9 + 12LL);
        a3 = *(_DWORD *)(*v23 + v9 + 16LL) & 0xF;
      }
      v25 = *v23;
      v24 = v23 + 1;
      v26 = 16LL * (j & 0xFFFFFFF);
      v27 = v26 + 4;
      v28 = v26 + 8;
      v29 = 1;
      v30 = *(_DWORD *)(v25 + v27);
      v31 = *(_DWORD *)(v25 + v28) & 0xF;
      while ( v29 < *(_DWORD *)(a1 + 28) )
      {
        if ( j && (a8 != *(_DWORD *)(*v24 + v9 + 12LL) || a3 != (*(_DWORD *)(*v24 + v9 + 16LL) & 0xF)) )
          return 0xFFFFFFFFLL;
        v32 = *v24;
        if ( v30 != *(_DWORD *)(*v24 + v27) )
          return 0xFFFFFFFFLL;
        ++v24;
        if ( v31 != (*(_DWORD *)(v32 + v28) & 0xF) )
          return 0xFFFFFFFFLL;
        ++v29;
      }
      v9 += 16;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (00000000000066E0) ----------------------------------------------------
__int64 __fastcall check_dupRegion(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        int a8)
{
  int v9; // w7
  __int64 *v10; // x5
  unsigned int v11; // w8
  char v12; // w11
  __int64 *v13; // x9
  __int64 v14; // x12
  unsigned int v15; // w10
  __int64 v16; // x1
  unsigned __int64 v17; // x0
  __int64 v18; // x2
  unsigned int i; // w0
  unsigned int v20; // w6
  __int64 v21; // x1
  char *v22; // x2
  unsigned __int64 v23; // x1
  unsigned __int64 v24; // x0
  __int64 v25; // x2
  unsigned __int64 v27[2]; // [xsp+10h] [xbp+10h] BYREF
  char v28; // [xsp+20h] [xbp+20h]
  unsigned __int64 v29[2]; // [xsp+28h] [xbp+28h] BYREF
  char v30; // [xsp+38h] [xbp+38h]

  if ( (unsigned int)compare_ch_segments(a1, a2, a3, a4, a5, a6, a7, a8) )
  {
    return (unsigned int)-1;
  }
  else
  {
    v9 = 1;
    v10 = addr_trans_segs;
    v11 = 0;
    v12 = 1;
    v13 = addr_trans_segs;
    v14 = 24LL;
    v15 = *(_DWORD *)(a1 + 24);
    while ( v9 != v15 )
    {
      if ( !*((_BYTE *)v10 + 16) )
      {
        v16 = *v10;
        v17 = v10[3];
        if ( *v10 >= v17 )
          return (unsigned int)-1;
        v18 = v10[1];
        v28 = v12;
        v27[0] = v18 + v16;
        v27[1] = v17 - v16;
        for ( i = v9; i < v15; i = v20 )
        {
          v20 = i + 1;
          v21 = i * v14;
          v22 = (char *)v13 + v21;
          if ( !*((_BYTE *)v13 + v21 + 16) )
          {
            v23 = *(__int64 *)((char *)v13 + v21);
            v24 = *(__int64 *)((char *)v13 + v20 * v14);
            if ( v23 >= v24 )
              return (unsigned int)-1;
            v25 = *((_QWORD *)v22 + 1);
            v30 = v12;
            v29[0] = v25 + v23;
            v29[1] = v24 - v23;
            if ( check_overlap(v27, v29) )
              return (unsigned int)-1;
          }
        }
      }
      v10 += 3;
      ++v9;
    }
  }
  return v11;
}
// 6718: variable 'v10' is possibly undefined
// 671C: variable 'v9' is possibly undefined
// 6724: variable 'v15' is possibly undefined
// 6748: variable 'v12' is possibly undefined
// 6768: variable 'v14' is possibly undefined
// 676C: variable 'v13' is possibly undefined
// 67C0: variable 'v20' is possibly undefined
// 67C8: variable 'v11' is possibly undefined
// 2FD98: using guessed type __int64 addr_trans_segs[];

//----- (00000000000067D4) ----------------------------------------------------
__int64 update_addr_translation()
{
  __int64 result; // x0

  result = (unsigned __int8)query_dev_config_valid;
  if ( query_dev_config_valid )
    return get_addr_translation(icb_dev_config_0);
  return result;
}
// 2FD88: using guessed type __int64 icb_dev_config_0;
// 2FD91: using guessed type char query_dev_config_valid;

//----- (00000000000067F0) ----------------------------------------------------
__int64 __fastcall ICB_Get_Memmap(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  char device_configuration_isra_0; // w0
  unsigned int v5; // w1
  __int64 v7; // [xsp+28h] [xbp-8h] BYREF

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 1LL;
  device_configuration_isra_0 = get_device_configuration_isra_0(&v7);
  v5 = -1;
  if ( device_configuration_isra_0 )
  {
    get_system_memory_map(v7, a2);
    return 0;
  }
  return v5;
}

//----- (0000000000006850) ----------------------------------------------------
__int64 __fastcall ICB_Get_AllowedMemRegion(__int64 a1, _QWORD *a2)
{
  bool v2; // zf
  __int64 v4; // x1
  int v5; // w2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  int v10; // w7
  _QWORD *v12; // x0
  __int64 v13; // [xsp+28h] [xbp-8h] BYREF

  if ( a1 )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( v2 )
    return 1LL;
  if ( !(unsigned __int8)get_device_configuration_isra_0(&v13)
    || (unsigned int)check_dupRegion(v13, v4, v5, v6, v7, v8, v9, v10) )
  {
    return 0xFFFFFFFFLL;
  }
  v12 = *(_QWORD **)(v13 + 16);
  *a2 = *v12;
  a2[1] = v12[1];
  return 0LL;
}
// 6888: variable 'v4' is possibly undefined
// 6888: variable 'v5' is possibly undefined
// 6888: variable 'v6' is possibly undefined
// 6888: variable 'v7' is possibly undefined
// 6888: variable 'v8' is possibly undefined
// 6888: variable 'v9' is possibly undefined
// 6888: variable 'v10' is possibly undefined

//----- (00000000000068C4) ----------------------------------------------------
__int64 __fastcall ICB_Get_MCAddr(__int64 a1, __int64 a2, _QWORD *a3)
{
  bool v3; // zf
  char device_configuration_isra_0; // w0
  unsigned int v8; // w1
  __int64 v10; // [xsp+28h] [xbp-8h] BYREF

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 || a1 == 0 )
    return 1LL;
  device_configuration_isra_0 = get_device_configuration_isra_0(&v10);
  v8 = -1;
  if ( device_configuration_isra_0 )
  {
    v8 = 0;
    *a3 = a2;
  }
  return v8;
}

//----- (0000000000006924) ----------------------------------------------------
unsigned int *__fastcall aggregate_sw_node(unsigned int *result, _QWORD *a2)
{
  __int64 v2; // x3
  __int64 v3; // x4
  unsigned __int64 v4; // x2
  __int64 *v5; // x6
  unsigned __int64 v6; // x7
  __int64 v7; // x6

  v2 = 0LL;
  v3 = 0LL;
  v4 = 0LL;
  while ( 8LL * *result != v2 )
  {
    v5 = *(__int64 **)(*((_QWORD *)result + 1) + v2);
    v2 += 8LL;
    v6 = v5[1];
    v7 = *v5;
    if ( v4 < v6 )
      v4 = v6;
    v3 += v7;
  }
  *a2 = v3;
  a2[1] = v4;
  return result;
}

//----- (000000000000696C) ----------------------------------------------------
__int64 __fastcall add_sw_node_request(int *a1, __int64 a2)
{
  unsigned int v4; // w0
  __int64 v5; // x20
  unsigned __int64 v6; // x0
  unsigned __int64 v7; // x21
  unsigned int v8; // w1
  int v9; // w0
  unsigned int v10; // w0
  __int64 v11; // x1

  v4 = *a1;
  if ( v4 != a1[1] )
  {
LABEL_6:
    v10 = *a1;
    v11 = *((_QWORD *)a1 + 1);
    ++*a1;
    *(_QWORD *)(v11 + 8LL * v10) = a2;
    return 1;
  }
  v5 = *((_QWORD *)a1 + 1);
  v6 = qtisec_malloc(8LL * (v4 + 10));
  v7 = v6;
  v8 = 0;
  if ( v6 )
  {
    qtiseclib_cb_memcpy(v6, v5, 8LL * (unsigned int)a1[1]);
    if ( v5 )
      qtisec_free(v5);
    v9 = a1[1];
    *((_QWORD *)a1 + 1) = v7;
    a1[1] = v9 + 10;
    goto LABEL_6;
  }
  return v8;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000006A08) ----------------------------------------------------
__int64 __fastcall remove_sw_node_request(int *a1, __int64 a2)
{
  int v2; // w2
  __int64 i; // x0
  unsigned int v5; // w2
  __int64 result; // x0

  v2 = *a1;
  for ( i = 0LL; i != v2 && *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * i) != a2; ++i )
    ;
  v5 = v2 - 1;
  if ( (unsigned int)i < v5 )
    qtiseclib_cb_memmove(
      *((_QWORD *)a1 + 1) + 8LL * (unsigned int)i,
      *((_QWORD *)a1 + 1) + 8LL * (unsigned int)(i + 1),
      8LL * (v5 - (unsigned int)i));
  result = (unsigned int)(*a1 - 1);
  *a1 = result;
  return result;
}
// 319A0: using guessed type __int64 __fastcall qtiseclib_cb_memmove(_QWORD, _QWORD, _QWORD);

//----- (0000000000006A8C) ----------------------------------------------------
__int64 __fastcall remove_client_requests(__int64 a1)
{
  __int64 v1; // x21
  __int64 v2; // x19
  unsigned int i; // w20
  __int64 result; // x0
  _QWORD *v5; // x22
  __int64 v6; // x0

  v1 = *(_QWORD *)(a1 + 8);
  v2 = a1 + 16;
  for ( i = 0; ; ++i )
  {
    result = *(unsigned int *)(v1 + 8);
    if ( i >= (unsigned int)result )
      break;
    v5 = (_QWORD *)(*(_QWORD *)(v1 + 16) + 16LL * i);
    if ( *v5 )
      remove_sw_node_request((int *)(*v5 + 32LL), v2);
    v6 = v5[1];
    if ( v6 )
      remove_sw_node_request((int *)(v6 + 32), v2);
  }
  return result;
}

//----- (0000000000006B00) ----------------------------------------------------
__int64 icbuarb_init()
{
  __int64 result; // x0
  unsigned int v1; // w21
  __int64 v2; // x19
  int v3; // w0
  __int64 v4; // x0
  __int64 v5; // x3
  __int64 v6; // x5
  __int64 v7; // x4
  __int64 v8; // x1
  __int64 v9; // x6
  __int64 v10; // x7
  unsigned int v11; // w2
  int v12; // w12
  int v13; // w13
  __int64 v14; // x8
  __int64 v15; // x3
  __int64 v16; // x5
  __int64 v17; // x4
  __int64 v18; // x1
  __int64 v19; // x6
  __int64 v20; // x7
  unsigned int v21; // w2
  int v22; // w12
  int v23; // w13
  __int64 v24; // x8
  char v25; // w0
  char v26; // [xsp+37h] [xbp+37h] BYREF
  int v27; // [xsp+38h] [xbp+38h] BYREF
  unsigned __int16 v28; // [xsp+3Ch] [xbp+3Ch]
  unsigned __int8 v29; // [xsp+3Eh] [xbp+3Eh]

  result = 1LL;
  if ( !info )
  {
    v1 = 0;
    info = (__int64)&target_info;
    while ( v1 < *(_DWORD *)(info + 48) )
    {
      v2 = *(_QWORD *)(*(_QWORD *)(info + 56) + 8LL * v1);
      v26 = 8;
      if ( (unsigned int)cmd_db_query_aux_data(*(_QWORD *)(v2 + 8), &v26, (__int64)&v27) )
        goto LABEL_23;
      ++v1;
      *(_DWORD *)(v2 + 20) = cmd_db_query_addr(*(_QWORD *)(v2 + 8));
      v3 = v28;
      *(_BYTE *)(v2 + 36) = 0;
      *(_DWORD *)(v2 + 24) = v3;
      *(_DWORD *)(v2 + 28) = v27;
      *(_DWORD *)(v2 + 32) = v29;
    }
    rpmh_handle = rpmh_create_handle(0, (__int64)"ICB");
    if ( !rpmh_handle )
    {
LABEL_23:
      v25 = 0;
      return v25 & 1;
    }
    v4 = info;
    v5 = 0LL;
    v6 = 8LL * *(unsigned int *)(info + 16);
    while ( v6 != v5 )
    {
      v7 = 0LL;
      v8 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + v5);
      v9 = 8LL * *(unsigned int *)(v8 + 48);
      while ( v7 != v9 )
      {
        v10 = *(_QWORD *)(*(_QWORD *)(v8 + 56) + v7);
        v11 = *(_DWORD *)(v10 + 64);
        if ( v11 < *(_DWORD *)(v10 + 68) )
        {
          v13 = *(_DWORD *)(v8 + 4);
          v12 = *(_DWORD *)(v8 + 8);
          v14 = *(_QWORD *)(v10 + 72) + 16LL * *(unsigned int *)(v10 + 64);
          *(_QWORD *)v14 = v8 + 16;
          *(_DWORD *)(v14 + 8) = v13;
          *(_DWORD *)(v14 + 12) = v12;
          *(_DWORD *)(v10 + 64) = v11 + 1;
        }
        v7 += 8LL;
      }
      v5 += 8LL;
    }
    v15 = 0LL;
    v16 = 8LL * *(unsigned int *)(v4 + 32);
    while ( v15 != v16 )
    {
      v17 = 0LL;
      v18 = *(_QWORD *)(*(_QWORD *)(v4 + 40) + v15);
      v19 = 8LL * *(unsigned int *)(v18 + 48);
      while ( v17 != v19 )
      {
        v20 = *(_QWORD *)(*(_QWORD *)(v18 + 56) + v17);
        v21 = *(_DWORD *)(v20 + 64);
        if ( v21 < *(_DWORD *)(v20 + 68) )
        {
          v23 = *(_DWORD *)(v18 + 4);
          v22 = *(_DWORD *)(v18 + 8);
          v24 = *(_QWORD *)(v20 + 72) + 16LL * *(unsigned int *)(v20 + 64);
          *(_QWORD *)v24 = v18 + 16;
          *(_DWORD *)(v24 + 8) = v23;
          *(_DWORD *)(v24 + 12) = v22;
          *(_DWORD *)(v20 + 64) = v21 + 1;
        }
        v17 += 8LL;
      }
      v15 += 8LL;
    }
    v25 = icbuarb_target_init(v4);
    return v25 & 1;
  }
  return result;
}
// 2FE40: using guessed type __int64 rpmh_handle;
// 2FE50: using guessed type __int64 info;

//----- (0000000000006CD0) ----------------------------------------------------
__int64 __fastcall icbuarb_create_client(int a1, int a2)
{
  __int64 i; // x20
  _DWORD *v3; // x4
  __int64 v6; // x19
  __int64 v7; // x0
  unsigned int v8; // w20
  __int64 v9; // x0
  __int64 v10; // x21
  __int64 v11; // x0
  __int64 v12; // x0

  if ( info )
  {
    for ( i = 0LL; i != 8LL * *(unsigned int *)info; i += 8LL )
    {
      v3 = *(_DWORD **)(*(_QWORD *)(info + 8) + i);
      if ( v3 && *v3 == a1 && v3[1] == a2 )
      {
        v6 = qtisec_malloc(0x20uLL);
        if ( !v6 )
          return 0LL;
        v7 = *(_QWORD *)(*(_QWORD *)(info + 8) + i);
        v8 = 0;
        *(_DWORD *)v6 = a1;
        *(_DWORD *)(v6 + 4) = a2;
        *(_QWORD *)(v6 + 8) = v7;
        qtiseclib_cb_memset(v6 + 16, 0LL, 16LL);
        while ( 1 )
        {
          v9 = *(_QWORD *)(v6 + 8);
          if ( v8 >= *(_DWORD *)(v9 + 8) )
            break;
          v10 = 16LL * v8;
          v11 = *(_QWORD *)(*(_QWORD *)(v9 + 16) + v10);
          if ( v11 )
          {
            if ( !(unsigned __int8)add_sw_node_request((int *)(v11 + 32), v6 + 16) )
              break;
          }
          v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 16LL) + v10 + 8);
          if ( v12 )
          {
            if ( !(unsigned __int8)add_sw_node_request((int *)(v12 + 32), v6 + 16) )
              break;
          }
          ++v8;
        }
        if ( v8 < *(_DWORD *)(*(_QWORD *)(v6 + 8) + 8LL) )
        {
          remove_client_requests(v6);
          qtisec_free(v6);
          return 0LL;
        }
        return v6;
      }
    }
  }
  return 0LL;
}
// 2FE50: using guessed type __int64 info;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000006E20) ----------------------------------------------------
__int64 __fastcall icbuarb_issue_request(
        _QWORD *a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x8
  __int64 result; // x0
  __int64 v12; // x11
  unsigned int i; // w10
  __int64 v14; // x12
  __int64 v15; // x9
  __int64 v16; // x9
  __int64 v17; // x9
  char v18; // w13
  __int64 v19; // x0
  __int64 v20; // x1
  __int64 v21; // x2
  __int64 v22; // x9
  char v23; // w13
  __int64 v24; // x0
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x9
  int v28; // w11
  __int64 v29; // x4
  __int64 v30; // x12
  __int64 v31; // x1
  __int64 v32; // x0
  int v33; // w13
  __int64 v34; // x5
  unsigned __int64 v35; // x1
  unsigned __int64 v36; // x3
  int v37; // w2
  __int64 v38; // x18
  unsigned __int64 *v39; // x14
  __int64 v40; // x7
  unsigned int v41; // w2
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x6
  unsigned __int64 v44; // x7
  unsigned __int64 v45; // x2
  unsigned __int64 v46; // x2
  unsigned __int64 v47; // x5
  unsigned __int64 v48; // x1
  unsigned __int64 v49; // x2
  int v50; // w1
  __int64 v51; // x1
  _QWORD *v52; // x2
  unsigned int v53; // w21
  __int64 j; // x0
  _DWORD *v55; // x1
  __int64 v56; // x5
  unsigned int v57; // w2
  char *v58; // x4
  int v59; // w3
  int v60; // w3
  char *v62; // x0
  int v63; // w0
  int v64; // w20
  unsigned int v65[52]; // [xsp+40h] [xbp-D0h] BYREF

  v9 = info;
  if ( !info )
    return 0LL;
  if ( !a1 || a2 == 0LL )
    return 0LL;
  v12 = a1[1];
  a1[2] = *a2;
  a1[3] = a2[1];
  if ( !v12 )
    return 0LL;
  for ( i = 0; i < *(_DWORD *)(v12 + 8); ++i )
  {
    v14 = 16LL * i;
    v15 = *(_QWORD *)(*(_QWORD *)(v12 + 16) + v14);
    if ( v15 )
    {
      aggregate_sw_node((unsigned int *)(v15 + 32), (_QWORD *)(v15 + 16));
      v19 = 0LL;
      v20 = 8LL * *(unsigned int *)(v17 + 48);
      while ( v19 != v20 )
      {
        v21 = *(_QWORD *)(*(_QWORD *)(v17 + 56) + v19);
        v19 += 8LL;
        *(_BYTE *)(v21 + 36) = v18;
      }
    }
    v16 = *(_QWORD *)(*(_QWORD *)(v12 + 16) + v14 + 8);
    if ( v16 )
    {
      aggregate_sw_node((unsigned int *)(v16 + 32), (_QWORD *)(v16 + 16));
      v24 = 0LL;
      v25 = 8LL * *(unsigned int *)(v22 + 48);
      while ( v24 != v25 )
      {
        v26 = *(_QWORD *)(*(_QWORD *)(v22 + 56) + v24);
        v24 += 8LL;
        *(_BYTE *)(v26 + 36) = v23;
      }
    }
  }
  v27 = 0LL;
  v28 = 0;
  v29 = commit_queue;
  v30 = 8LL * *(unsigned int *)(v9 + 48);
  while ( v27 != v30 )
  {
    v31 = v29;
    v32 = *(_QWORD *)(*(_QWORD *)(v9 + 56) + v27);
    v33 = *(unsigned __int8 *)(v32 + 36);
    if ( *(_BYTE *)(v32 + 36) )
    {
      v34 = 0LL;
      v35 = 0LL;
      v36 = 0LL;
      while ( 1 )
      {
        v37 = *(_DWORD *)(v32 + 16);
        if ( v34 == 16LL * *(unsigned int *)(v32 + 64) )
          break;
        v38 = *(_QWORD *)(v32 + 72) + v34;
        v39 = *(unsigned __int64 **)v38;
        if ( v37 )
        {
          if ( v36 < v39[1] )
            v36 = v39[1];
          v46 = *v39;
        }
        else
        {
          v40 = *(unsigned int *)(v32 + 24);
          v41 = *(_DWORD *)(v38 + 8);
          v42 = v40 * v39[1];
          v43 = v42 / v41;
          if ( v42 % v41 )
            ++v43;
          if ( v36 < v43 )
            v36 = v43;
          v44 = v40 * *v39;
          v45 = v41 * *(_DWORD *)(v38 + 12);
          if ( v44 % v45 )
            v46 = v44 / v45 + 1;
          else
            v46 = v44 / v45;
        }
        v34 += 16LL;
        if ( v35 < v46 )
          v35 = v46;
      }
      *(_QWORD *)(v32 + 48) = v35;
      *(_QWORD *)(v32 + 56) = v36;
      if ( v37 )
      {
        *(_DWORD *)(v32 + 40) = 0;
      }
      else
      {
        v47 = *(unsigned int *)(v32 + 28);
        if ( v35 % v47 )
          v48 = v35 / v47 + 1;
        else
          v48 = v35 / v47;
        v49 = v36 / v47;
        if ( v48 > 0x3FFF )
          LODWORD(v48) = 0x3FFF;
        if ( v36 % v47 )
          ++v49;
        if ( v49 > 0x3FFF )
          LODWORD(v49) = 0x3FFF;
        *(_DWORD *)(v32 + 40) = v49 | ((_DWORD)v48 << 14);
      }
      v50 = *(_DWORD *)(v32 + 40);
      if ( v50 )
        *(_DWORD *)(v32 + 40) = v50 | 0x20000000;
      v51 = v29;
      v52 = 0LL;
      while ( v51 && *(_DWORD *)(v32 + 32) >= *(_DWORD *)(v51 + 32) )
      {
        v52 = (_QWORD *)v51;
        v51 = *(_QWORD *)v51;
      }
      if ( v51 == v29 )
      {
        *(_QWORD *)v32 = v51;
        v31 = v32;
      }
      else
      {
        *v52 = v32;
        v33 = v28;
        *(_QWORD *)v32 = v51;
        v31 = v29;
      }
      v28 = v33;
      *(_BYTE *)(v32 + 36) = 0;
    }
    v27 += 8LL;
    v29 = v31;
  }
  if ( v28 )
    commit_queue = v29;
  result = 1LL;
  if ( commit_queue )
  {
    v53 = 0;
    qtiseclib_cb_memset(v65, 0LL, 204LL);
    for ( j = 0LL; ; j = v57 )
    {
      v55 = (_DWORD *)commit_queue;
      if ( !commit_queue )
        break;
      v56 = *(_QWORD *)commit_queue;
      v57 = j + 1;
      *(_QWORD *)commit_queue = 0LL;
      v58 = (char *)&a9 + 12 * (unsigned int)j;
      v59 = v55[5];
      commit_queue = v56;
      *((_DWORD *)v58 - 49) = v59;
      v60 = v55[10];
      *((_DWORD *)v58 - 48) = v60;
      if ( v56 )
      {
        if ( v55[8] == *(_DWORD *)(v56 + 32) && v57 != 16 )
          continue;
      }
      v62 = (char *)&a9 + 12 * j;
      v65[0] = 0;
      v65[1] = v57;
      *((_DWORD *)v62 - 48) = v60 | 0x40000000;
      *(v62 - 188) = 1;
      v63 = rpmh_issue_command_set(rpmh_handle, v65);
      if ( v63 )
        v64 = v63;
      else
        v64 = v53;
      v53 = v64;
      qtiseclib_cb_memset(v65, 0LL, 204LL);
      v57 = 0;
    }
    rpmh_barrier_all(rpmh_handle, v53);
    return 1LL;
  }
  return result;
}
// 6E74: variable 'v12' is possibly undefined
// 6E94: variable 'v14' is possibly undefined
// 6EB0: variable 'v17' is possibly undefined
// 6ED0: variable 'v18' is possibly undefined
// 6ED8: variable 'i' is possibly undefined
// 6EEC: variable 'v22' is possibly undefined
// 6F0C: variable 'v23' is possibly undefined
// 6F18: variable 'v9' is possibly undefined
// DD34: using guessed type __int64 __fastcall rpmh_barrier_all(_QWORD, _QWORD);
// 2FE40: using guessed type __int64 rpmh_handle;
// 2FE48: using guessed type __int64 commit_queue;
// 2FE50: using guessed type __int64 info;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (00000000000071A0) ----------------------------------------------------
__int64 __fastcall icbuarb_destroy_client(_QWORD *a1)
{
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  __int64 v9; // [xsp+0h] [xbp+0h]
  _QWORD v10[2]; // [xsp+20h] [xbp+20h] BYREF

  if ( !a1 )
    return 0LL;
  qtiseclib_cb_memset(v10, 0LL, 16LL);
  if ( !(unsigned __int8)icbuarb_issue_request(a1, v10, v2, v3, v4, v5, v6, v7, v9) )
    return 0LL;
  remove_client_requests((__int64)a1);
  qtisec_free((__int64)a1);
  return 1LL;
}
// 71CC: variable 'v2' is possibly undefined
// 71CC: variable 'v3' is possibly undefined
// 71CC: variable 'v4' is possibly undefined
// 71CC: variable 'v5' is possibly undefined
// 71CC: variable 'v6' is possibly undefined
// 71CC: variable 'v7' is possibly undefined
// 71CC: variable 'v9' is possibly undefined
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000007220) ----------------------------------------------------
__int64 __fastcall icbuarb_target_init(__int64 a1)
{
  int addr; // w0
  __int64 v3; // x2
  __int64 v4; // x1

  addr = cmd_db_query_addr((__int64)"MM1");
  v3 = 0LL;
  while ( v3 != 8LL * *(unsigned int *)(a1 + 48) )
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + v3);
    v3 += 8LL;
    if ( addr == *(_DWORD *)(v4 + 20) )
      goto LABEL_6;
  }
  v4 = 0LL;
LABEL_6:
  mm_node = v4;
  if ( v4 )
  {
    rpmh_wa_handle = rpmh_create_handle_explicit(0, (__int64)"ICB");
    if ( rpmh_wa_handle )
      initialized = 1;
  }
  return (unsigned __int8)initialized;
}
// 2FE58: using guessed type __int64 rpmh_wa_handle;
// 2FE60: using guessed type __int64 mm_node;
// 2FE68: using guessed type char initialized;

//----- (00000000000072B4) ----------------------------------------------------
__int64 icbuarb_target_d4_entry()
{
  __int64 result; // x0
  unsigned int v1; // w0
  unsigned int v2; // w22
  unsigned int v3[4]; // [xsp+30h] [xbp+30h] BYREF
  int v4; // [xsp+40h] [xbp+40h]
  char v5; // [xsp+44h] [xbp+44h]

  result = (unsigned __int8)initialized;
  if ( initialized )
  {
    result = *(unsigned int *)(mm_node + 40);
    if ( !(_DWORD)result )
    {
      qtiseclib_cb_memset(v3, 0LL, 204LL);
      v3[0] = 0;
      v3[1] = 1;
      v1 = *(_DWORD *)(mm_node + 20);
      v5 = 1;
      v3[3] = v1;
      v4 = 1610612737;
      v2 = rpmh_issue_command_set(rpmh_wa_handle, v3);
      v5 = 1;
      v3[0] = 2;
      v4 = 1610612737;
      rpmh_issue_command_set(rpmh_wa_handle, v3);
      v5 = 0;
      v3[0] = 1;
      v4 = 0x40000000;
      rpmh_issue_command_set(rpmh_wa_handle, v3);
      return rpmh_barrier_single(rpmh_wa_handle, v2);
    }
  }
  return result;
}
// DD38: using guessed type __int64 __fastcall rpmh_barrier_single(_QWORD, _QWORD);
// 2FE58: using guessed type __int64 rpmh_wa_handle;
// 2FE60: using guessed type __int64 mm_node;
// 2FE68: using guessed type char initialized;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000737C) ----------------------------------------------------
__int64 icbuarb_target_d4_exit()
{
  __int64 result; // x0
  unsigned int v1; // w0
  unsigned int v2[5]; // [xsp+20h] [xbp+20h] BYREF
  char v3; // [xsp+34h] [xbp+34h]

  result = (unsigned __int8)initialized;
  if ( initialized )
  {
    result = *(unsigned int *)(mm_node + 40);
    if ( !(_DWORD)result )
    {
      rpmh_invalidate_explicit_cmds(rpmh_wa_handle);
      qtiseclib_cb_memset(v2, 0LL, 204LL);
      v2[0] = 0;
      v2[1] = 1;
      v1 = *(_DWORD *)(mm_node + 20);
      v3 = 0;
      v2[3] = v1;
      v2[4] = 0x40000000;
      return rpmh_issue_command_set(rpmh_wa_handle, v2);
    }
  }
  return result;
}
// 2FE58: using guessed type __int64 rpmh_wa_handle;
// 2FE60: using guessed type __int64 mm_node;
// 2FE68: using guessed type char initialized;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000740C) ----------------------------------------------------
_DWORD *__fastcall inq_create(int a1)
{
  _DWORD *v2; // x19

  v2 = (_DWORD *)rpmh_malloc(0x18u);
  rpmh_core_verify_ptr((__int64)v2);
  qtiseclib_cb_memset(v2, 0LL, 24LL);
  *v2 = a1;
  return v2;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000007454) ----------------------------------------------------
__int64 __fastcall inq_size(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}

//----- (000000000000745C) ----------------------------------------------------
unsigned int *__fastcall inq_append(unsigned int *result, __int64 a2)
{
  __int64 v2; // x3
  __int64 v3; // x2

  v2 = *((_QWORD *)result + 2);
  v3 = *result;
  if ( v2 )
  {
    *(_QWORD *)(v2 + v3) = a2;
    *(_QWORD *)(a2 + v3) = 0LL;
    *((_QWORD *)result + 2) = a2;
  }
  else
  {
    *((_QWORD *)result + 1) = a2;
    *((_QWORD *)result + 2) = a2;
    *(_QWORD *)(a2 + v3) = 0LL;
  }
  ++result[1];
  return result;
}

//----- (0000000000007490) ----------------------------------------------------
__int64 __fastcall inq_pop(unsigned int *a1)
{
  unsigned int v1; // w2
  __int64 v2; // x1
  __int64 v3; // x3
  __int64 v4; // x4

  v1 = a1[1];
  if ( !v1 )
    return 0LL;
  v2 = *((_QWORD *)a1 + 1);
  v3 = *a1;
  v4 = *(_QWORD *)(v2 + v3);
  *((_QWORD *)a1 + 1) = v4;
  if ( !v4 )
    *((_QWORD *)a1 + 2) = 0LL;
  *(_QWORD *)(v2 + v3) = 0LL;
  a1[1] = v1 - 1;
  return v2;
}

//----- (00000000000074CC) ----------------------------------------------------
__int64 __fastcall inq_head(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000000074D4) ----------------------------------------------------
__int64 __fastcall inq_it_begin(__int64 a1, _QWORD *a2)
{
  __int64 result; // x0

  *a2 = a1;
  a2[1] = 0LL;
  result = *(_QWORD *)(a1 + 8);
  a2[2] = result;
  return result;
}

//----- (00000000000074E4) ----------------------------------------------------
unsigned int **__fastcall inq_it_next(unsigned int **result)
{
  unsigned int *v1; // x1

  v1 = result[2];
  result[1] = v1;
  if ( v1 )
    result[2] = *(unsigned int **)((char *)v1 + **result);
  return result;
}

//----- (0000000000007504) ----------------------------------------------------
__int64 __fastcall inq_it_deref(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (000000000000750C) ----------------------------------------------------
unsigned int *__fastcall inq_it_insert(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // x2
  unsigned int *v5; // x0
  unsigned int *result; // x0
  unsigned int *v7; // x1
  unsigned int *v8; // x0
  __int64 v9; // x0
  unsigned int *v10; // x1
  unsigned int v11; // w0

  v2 = a1[2];
  v5 = *a1;
  if ( v2 )
  {
    v7 = a1[1];
    if ( v7 )
    {
      v9 = *v5;
      *(_QWORD *)(a2 + v9) = v2;
      *(_QWORD *)((char *)v7 + v9) = a2;
    }
    else
    {
      rpmh_core_verify(*((_QWORD *)v5 + 1) == (_QWORD)v2);
      v8 = *a1;
      *(_QWORD *)(a2 + **a1) = *((_QWORD *)*a1 + 1);
      *((_QWORD *)v8 + 1) = a2;
    }
    v10 = *a1;
    v11 = (*a1)[1];
    a1[2] = (unsigned int *)a2;
    result = (unsigned int *)(v11 + 1);
    v10[1] = (unsigned int)result;
  }
  else
  {
    a1[1] = (unsigned int *)*((_QWORD *)v5 + 2);
    result = inq_append(v5, a2);
    a1[2] = (unsigned int *)a2;
  }
  return result;
}

//----- (000000000000759C) ----------------------------------------------------
__int64 __fastcall inq_it_delete(unsigned int **a1)
{
  __int64 result; // x0
  unsigned int *v3; // x2
  unsigned int *v4; // x3
  unsigned int **v5; // x19
  __int64 v6; // x4

  result = (__int64)a1[2];
  if ( result )
  {
    v3 = *a1;
    v4 = a1[1];
    if ( v4 )
    {
      v6 = *v3;
      *(_QWORD *)((char *)v4 + v6) = *(_QWORD *)(result + v6);
      a1[2] = *(unsigned int **)(result + v6);
      if ( result == *((_QWORD *)v3 + 2) )
        *((_QWORD *)v3 + 2) = v4;
      --v3[1];
    }
    else
    {
      v5 = a1;
      rpmh_core_verify(*((_QWORD *)v3 + 1) == result);
      result = inq_pop(*v5);
      v5[2] = (unsigned int *)*((_QWORD *)*v5 + 1);
    }
  }
  return result;
}

//----- (0000000000007628) ----------------------------------------------------
__int64 __fastcall int_svc_register_isr(int a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  __int64 i; // x5
  __int64 v11; // x7
  unsigned int v12; // w19
  bool v13; // zf
  char *v14; // x0
  __int64 v15; // x2

  if ( !init_done_1195 )
  {
    for ( i = 0LL; i != 1088; i += 34LL )
      g_isrs[i] = -1;
    init_done_1195 = 1;
  }
  qtiseclib_cb_spin_lock(&g_int_svc_fiq_lock);
  v11 = 0LL;
  while ( g_isrs[34 * v11] != -1 )
  {
    if ( ++v11 == 32 )
    {
      v12 = -1;
      goto LABEL_17;
    }
  }
  if ( a2 )
    v13 = a3 == 0;
  else
    v13 = 1;
  v14 = (char *)&g_isrs[34 * (unsigned int)v11];
  *(_DWORD *)v14 = a1;
  *((_QWORD *)v14 + 3) = a4;
  *((_QWORD *)v14 + 4) = a5;
  if ( !v13 )
  {
    v15 = 15LL;
    if ( a3 <= 0xF )
      v15 = a3;
    qtiseclib_cb_memcpy(v14 + 4, a2, v15);
  }
  v12 = 0;
LABEL_17:
  qtiseclib_cb_spin_unlock(&g_int_svc_fiq_lock);
  return v12;
}
// 2FEB8: using guessed type _DWORD g_isrs[1088];
// 30FD0: using guessed type char init_done_1195;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000007728) ----------------------------------------------------
__int64 __fastcall int_svc_unregister_isr(int a1)
{
  __int64 v2; // x1
  unsigned int v3; // w20

  qtiseclib_cb_spin_lock(&g_int_svc_fiq_lock);
  v2 = 0LL;
  while ( g_isrs[34 * v2] != a1 )
  {
    if ( ++v2 == 32 )
    {
      v3 = -1;
      goto LABEL_6;
    }
  }
  v3 = 0;
  qtiseclib_cb_memset(&g_isrs[34 * (unsigned int)v2], 0LL, 136LL);
LABEL_6:
  qtiseclib_cb_spin_unlock(&g_int_svc_fiq_lock);
  return v3;
}
// 2FEB8: using guessed type _DWORD g_isrs[1088];
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (00000000000077A8) ----------------------------------------------------
__int64 __fastcall qtiseclib_invoke_isr(__int64 a1, __int64 a2)
{
  unsigned int v3; // w23
  char v4; // w20
  __int64 v5; // x1
  __int64 v6; // x21
  __int64 v7; // x19
  __int64 (__fastcall *v8)(_QWORD, __int64, __int64); // x20
  __int64 result; // x0
  __int64 v10; // x20
  _DWORD *v11; // x0
  _DWORD *v12; // x19

  v3 = a1;
  v4 = qtiseclib_cb_plat_my_core_pos(a1);
  qtiseclib_cb_spin_lock(&g_int_svc_fiq_lock);
  v5 = 0LL;
  while ( 1 )
  {
    v6 = (unsigned int)v5;
    if ( g_isrs[34 * v5] == v3 )
      break;
    if ( ++v5 == 32 )
    {
      v6 = 32LL;
      v7 = 0LL;
      v8 = 0LL;
      goto LABEL_5;
    }
  }
  v10 = v4 & 7;
  v11 = &g_isrs[34 * (unsigned int)v5 + 8 + v10];
  ++v11[2];
  v12 = &g_isrs[34 * (unsigned int)v5];
  *(_QWORD *)&g_isrs[34 * (unsigned int)v5 + 18 + 2 * v10] = timer_qtimer_read_time_raw();
  v8 = (__int64 (__fastcall *)(_QWORD, __int64, __int64))*((_QWORD *)v12 + 3);
  v7 = *((_QWORD *)v12 + 4);
LABEL_5:
  result = qtiseclib_cb_spin_unlock(&g_int_svc_fiq_lock);
  if ( v8 )
  {
    result = v8(v3, a2, v7);
    *(_QWORD *)&g_isrs[34 * v6 + 8] = result;
  }
  return result;
}
// 2FEB8: using guessed type _DWORD g_isrs[1088];
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (00000000000078B0) ----------------------------------------------------
bool __fastcall int_svc_is_cpu_on(char a1)
{
  int v2; // w19

  qtiseclib_cb_spin_lock(&g_int_svc_cpu_state_lock);
  v2 = (char)((1 << a1) & g_int_cpu_on_state);
  qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
  return v2 != 0;
}
// 2FEB8: using guessed type _DWORD g_isrs[1088];
// 30FB8: using guessed type char g_int_cpu_on_state;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (000000000000790C) ----------------------------------------------------
__int64 __fastcall int_svc_core_pos_to_mpidr(unsigned int a1)
{
  if ( a1 > 7 )
    qtisec_assert("noship_src/services/int_svc/int_svc.c", 0xCBu, "core_pos < QTISECLIB_PLAT_CORE_COUNT");
  if ( g_mpidr_map[a1] == 57005LL )
    qtisec_assert("noship_src/services/int_svc/int_svc.c", 0xCCu, "INVALID_MPIDR != g_mpidr_map[core_pos]");
  return g_mpidr_map[a1];
}
// 2FE70: using guessed type _QWORD g_mpidr_map[8];

//----- (0000000000007984) ----------------------------------------------------
__int64 __fastcall int_svc_notify_cpu_state(__int64 a1)
{
  int v1; // w23
  unsigned int v2; // w0
  unsigned int v3; // w24
  int v4; // w1
  unsigned int v5; // w19
  char v6; // w23
  int v7; // w0
  unsigned int v8; // w19
  int v9; // w19
  int v10; // w0
  int v11; // w1
  __int64 v12; // x0

  v1 = a1;
  v2 = qtiseclib_cb_plat_my_core_pos(a1);
  v3 = v2;
  if ( g_mpidr_map[v2] == 57005LL )
    g_mpidr_map[v2] = _ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 5));
  qtiseclib_cb_spin_lock(&g_int_svc_cpu_state_lock);
  if ( v1 == 1 )
  {
    v4 = 1 << v3;
    if ( (((int)(unsigned __int8)g_int_cpu_on_state >> g_int_swdog_target) & 1LL) != 0 )
      v5 = 255;
    else
      v5 = v3;
    g_int_cpu_on_state |= v4;
    g_int_cpu_interruptible_state |= v4;
    if ( v5 == 255 )
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    if ( v5 > 7 )
      qtisec_assert("noship_src/services/int_svc/int_svc.c", 0x140u, "new_sec_wdog_target < QTISECLIB_PLAT_CORE_COUNT");
  }
  else if ( v1 )
  {
    if ( v3 != (unsigned __int8)g_int_swdog_target )
    {
      g_int_cpu_on_state &= ~(1 << v3);
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    }
    v9 = (unsigned __int8)g_int_cpu_on_state;
    v10 = (unsigned __int8)g_int_cpu_on_state - 1;
    v11 = (unsigned __int8)g_int_cpu_on_state & ~(1 << v3);
    g_int_cpu_on_state &= ~(1 << v3);
    if ( (v10 & v9) == 0 )
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    v5 = __clz(__rbit32(v11));
  }
  else
  {
    v6 = ~(1 << v3);
    v7 = (unsigned __int8)(v6 & g_int_cpu_interruptible_state);
    g_int_cpu_interruptible_state &= v6;
    if ( v3 != (unsigned __int8)g_int_swdog_target )
    {
      g_int_cpu_on_state &= v6;
      return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
    }
    if ( ((unsigned __int8)(g_int_cpu_on_state - 1) & (unsigned __int8)g_int_cpu_on_state) != 0 )
    {
      v8 = (unsigned __int8)(v6 & g_int_cpu_on_state);
      g_int_cpu_on_state &= v6;
    }
    else
    {
      if ( !v7 )
        qtisec_assert("noship_src/services/int_svc/int_svc.c", 0x115u, "0 != g_int_cpu_interruptible_state");
      g_int_cpu_on_state &= v6;
      v8 = (unsigned __int8)g_int_cpu_interruptible_state;
    }
    v5 = __clz(__rbit32(v8));
  }
  if ( (((int)(unsigned __int8)g_int_cpu_interruptible_state >> v5) & 1) == 0 )
    qtisec_assert(
      "noship_src/services/int_svc/int_svc.c",
      0x141u,
      "g_int_cpu_interruptible_state & (1 << new_sec_wdog_target)");
  v12 = int_svc_core_pos_to_mpidr(v5);
  qtiseclib_cb_set_spi_routing(516LL, 0LL, v12);
  g_int_swdog_target = v5;
  return qtiseclib_cb_spin_unlock(&g_int_svc_cpu_state_lock);
}
// 2FE70: using guessed type _QWORD g_mpidr_map[8];
// 2FEB0: using guessed type char g_int_swdog_target;
// 2FEB8: using guessed type _DWORD g_isrs[1088];
// 30FB8: using guessed type char g_int_cpu_on_state;
// 30FD1: using guessed type char g_int_cpu_interruptible_state;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31938: using guessed type __int64 __fastcall qtiseclib_cb_set_spi_routing(_QWORD, _QWORD, _QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (0000000000007B90) ----------------------------------------------------
__int64 int_svc_init()
{
  __int64 i; // x0

  for ( i = 0LL; i != 8; ++i )
    g_mpidr_map[i] = 57005LL;
  return int_svc_notify_cpu_state(1LL);
}
// 2FE70: using guessed type _QWORD g_mpidr_map[8];

//----- (0000000000007BBC) ----------------------------------------------------
__int64 lmh_target_config_init()
{
  __int64 result; // x0

  result = (unsigned __int8)lmh_enable;
  if ( lmh_enable )
  {
    qtiseclib_cb_memcpy(lmh_hsr_version, "1.0", 10LL);
    MEMORY[0x18378094] = 1;
    MEMORY[0x18378100] = 0;
    MEMORY[0x18378380] = 15;
    MEMORY[0x18378390] = 257;
    MEMORY[0x18378394] = 258;
    MEMORY[0x18378398] = 259;
    MEMORY[0x1837839C] = 260;
    MEMORY[0x183783A0] = 261;
    MEMORY[0x183783A4] = 262;
    MEMORY[0x18378410] = 1114112;
    MEMORY[0x18378580] = 113;
    MEMORY[0x18378600] = 18;
    MEMORY[0x18378614] = 193;
    MEMORY[0x18378620] = 193;
    MEMORY[0x18378694] = 1182721;
    MEMORY[0x183786A0] = 1117185;
    MEMORY[0x18378B00] = 18;
    MEMORY[0x18378B14] = 1;
    MEMORY[0x18378B20] = 4;
    MEMORY[0x18378B94] = 65537;
    MEMORY[0x18378BA0] = 65537;
    MEMORY[0x18378C14] = 1170;
    MEMORY[0x18378C20] = 1150;
    MEMORY[0x18378C94] = 51216;
    MEMORY[0x18378CA0] = 12817;
    MEMORY[0x18378D80] = 12;
    MEMORY[0x18378D98] = 2;
    MEMORY[0x18378D9C] = 16;
    MEMORY[0x18378E9C] = 3585;
    MEMORY[0x18378F18] = 50364417;
    MEMORY[0x18379080] = 3;
    MEMORY[0x18379090] = 2;
    MEMORY[0x18379094] = 3;
    MEMORY[0x18379110] = 272;
    MEMORY[0x18379114] = 16;
    MEMORY[0x18379194] = 196671;
    MEMORY[0x18379198] = 327805;
    MEMORY[0x1837919C] = 524476;
    MEMORY[0x183791A0] = 655610;
    MEMORY[0x183791A4] = 786745;
    MEMORY[0x183791A8] = 852343;
    MEMORY[0x183791AC] = 983478;
    MEMORY[0x183791B0] = 1049076;
    MEMORY[0x183791B4] = 1180211;
    MEMORY[0x183791B8] = 1245809;
    MEMORY[0x183791BC] = 1376944;
    MEMORY[0x183791C0] = 1442542;
    MEMORY[0x183791C4] = 1508141;
    MEMORY[0x183791C8] = 1573739;
    MEMORY[0x183791CC] = 1639338;
    MEMORY[0x183791D0] = 2161688;
    MEMORY[0x183791D4] = 1113612;
    MEMORY[0x183791D8] = 589574;
    MEMORY[0x183791DC] = 327555;
    MEMORY[0x183791E0] = 196545;
    MEMORY[0x183791E4] = 131041;
    MEMORY[0x183791E8] = 131056;
    MEMORY[0x183791F0] = -65520;
    MEMORY[0x183791F4] = -65505;
    MEMORY[0x183791F8] = -131009;
    MEMORY[0x183791FC] = -262019;
    MEMORY[0x18379200] = -524038;
    MEMORY[0x18379204] = -1048076;
    MEMORY[0x18379208] = -2096152;
    MEMORY[0x1837920C] = -2096152;
    MEMORY[0x18379A80] = 1;
    MEMORY[0x18378090] = 17;
    MEMORY[0x18370094] = 1;
    MEMORY[0x18370100] = 1;
    MEMORY[0x18370110] = 48;
    MEMORY[0x18370380] = 2047;
    MEMORY[0x18370390] = 263;
    MEMORY[0x18370394] = 264;
    MEMORY[0x18370398] = 265;
    MEMORY[0x1837039C] = 266;
    MEMORY[0x183703A0] = 267;
    MEMORY[0x183703A4] = 268;
    MEMORY[0x183703A8] = 269;
    MEMORY[0x183703AC] = 270;
    MEMORY[0x183703B0] = 261;
    MEMORY[0x183703B4] = 262;
    MEMORY[0x183703B8] = 5;
    MEMORY[0x18370410] = 1114112;
    MEMORY[0x18370448] = 78643217;
    MEMORY[0x18370580] = 113;
    MEMORY[0x18370600] = 2555;
    MEMORY[0x18370614] = 193;
    MEMORY[0x1837061C] = 1;
    MEMORY[0x18370620] = 33;
    MEMORY[0x18370624] = 65;
    MEMORY[0x18370628] = 97;
    MEMORY[0x18370630] = 193;
    MEMORY[0x1837063C] = 161;
    MEMORY[0x18370694] = 1182721;
    MEMORY[0x1837069C] = 1182721;
    MEMORY[0x183706A0] = 1182721;
    MEMORY[0x183706A4] = 1182721;
    MEMORY[0x183706A8] = 1182721;
    MEMORY[0x183706AC] = 2049;
    MEMORY[0x183706B0] = 1117185;
    MEMORY[0x18370B00] = 2555;
    MEMORY[0x18370B14] = 1;
    MEMORY[0x18370B1C] = 3;
    MEMORY[0x18370B20] = 4;
    MEMORY[0x18370B24] = 5;
    MEMORY[0x18370B28] = 6;
    MEMORY[0x18370B2C] = 7;
    MEMORY[0x18370B30] = 8;
    MEMORY[0x18370B3C] = 11;
    MEMORY[0x18370B90] = 1;
    MEMORY[0x18370B94] = 65537;
    MEMORY[0x18370B9C] = 65537;
    MEMORY[0x18370BA0] = 65537;
    MEMORY[0x18370BA4] = 65537;
    MEMORY[0x18370BA8] = 65537;
    MEMORY[0x18370BAC] = 1;
    MEMORY[0x18370BB0] = 65537;
    MEMORY[0x18370BBC] = 1;
    MEMORY[0x18370C10] = 14945208;
    MEMORY[0x18370C14] = 1170;
    MEMORY[0x18370C1C] = 900;
    MEMORY[0x18370C20] = 900;
    MEMORY[0x18370C24] = 900;
    MEMORY[0x18370C28] = 900;
    MEMORY[0x18370C2C] = 14945208;
    MEMORY[0x18370C30] = 1150;
    MEMORY[0x18370C3C] = 14943408;
    MEMORY[0x18370C90] = 2064;
    MEMORY[0x18370C94] = 51216;
    MEMORY[0x18370CAC] = 2065;
    MEMORY[0x18370CB0] = 12817;
    MEMORY[0x18370D80] = 252;
    MEMORY[0x18370D98] = 2051;
    MEMORY[0x18370D9C] = 8;
    MEMORY[0x18370DA0] = 16;
    MEMORY[0x18370DA4] = 32;
    MEMORY[0x18370DA8] = 64;
    MEMORY[0x18370DAC] = 384;
    MEMORY[0x18370EAC] = 3585;
    MEMORY[0x18370F18] = 50364417;
    MEMORY[0x18371080] = 33;
    MEMORY[0x18371090] = 2;
    MEMORY[0x18371094] = 3;
    MEMORY[0x18371098] = 4;
    MEMORY[0x1837109C] = 5;
    MEMORY[0x183710A0] = 6;
    MEMORY[0x183710A4] = 7;
    MEMORY[0x18371110] = 272;
    MEMORY[0x18371114] = 272;
    MEMORY[0x18371118] = 272;
    MEMORY[0x1837111C] = 272;
    MEMORY[0x18371120] = 272;
    MEMORY[0x18371124] = 16;
    MEMORY[0x18371194] = 196671;
    MEMORY[0x18371198] = 327805;
    MEMORY[0x1837119C] = 524476;
    MEMORY[0x183711A0] = 655610;
    MEMORY[0x183711A4] = 786745;
    MEMORY[0x183711A8] = 852343;
    MEMORY[0x183711AC] = 983478;
    MEMORY[0x183711B0] = 1049076;
    MEMORY[0x183711B4] = 1180211;
    MEMORY[0x183711B8] = 1245809;
    MEMORY[0x183711BC] = 1376944;
    MEMORY[0x183711C0] = 1442542;
    MEMORY[0x183711C4] = 1508141;
    MEMORY[0x183711C8] = 1573739;
    MEMORY[0x183711CC] = 1639338;
    MEMORY[0x183711D0] = 196608;
    MEMORY[0x183711D4] = 8388613;
    MEMORY[0x183711D8] = 10747914;
    MEMORY[0x183711DC] = 13107215;
    MEMORY[0x183711E0] = 13369364;
    MEMORY[0x183711E4] = 8454169;
    MEMORY[0x183711E8] = 10813470;
    MEMORY[0x183711EC] = 13172771;
    MEMORY[0x183711F0] = 13434920;
    MEMORY[0x183711F4] = 8519725;
    MEMORY[0x183711F8] = 10879026;
    MEMORY[0x183711FC] = 13238327;
    MEMORY[0x18371200] = 13500476;
    MEMORY[0x18371204] = 14286913;
    MEMORY[0x18371208] = 14286918;
    MEMORY[0x1837120C] = 14286923;
    MEMORY[0x18371210] = 196608;
    MEMORY[0x18371214] = 8388613;
    MEMORY[0x18371218] = 10747914;
    MEMORY[0x1837121C] = 13107215;
    MEMORY[0x18371220] = 13369364;
    MEMORY[0x18371224] = 8454169;
    MEMORY[0x18371228] = 10813470;
    MEMORY[0x1837122C] = 13172771;
    MEMORY[0x18371230] = 13434920;
    MEMORY[0x18371234] = 8519725;
    MEMORY[0x18371238] = 10879026;
    MEMORY[0x1837123C] = 13238327;
    MEMORY[0x18371240] = 13500476;
    MEMORY[0x18371244] = 14286913;
    MEMORY[0x18371248] = 14286918;
    MEMORY[0x1837124C] = 14286923;
    MEMORY[0x18371250] = 196608;
    MEMORY[0x18371254] = 8388613;
    MEMORY[0x18371258] = 10747914;
    MEMORY[0x1837125C] = 13107215;
    MEMORY[0x18371260] = 13369364;
    MEMORY[0x18371264] = 8454169;
    MEMORY[0x18371268] = 10813470;
    MEMORY[0x1837126C] = 13172771;
    MEMORY[0x18371270] = 13434920;
    MEMORY[0x18371274] = 8519725;
    MEMORY[0x18371278] = 10879026;
    MEMORY[0x1837127C] = 13238327;
    MEMORY[0x18371280] = 13500476;
    MEMORY[0x18371284] = 14286913;
    MEMORY[0x18371288] = 14286918;
    MEMORY[0x1837128C] = 14286923;
    MEMORY[0x18371290] = 196608;
    MEMORY[0x18371294] = 8388613;
    MEMORY[0x18371298] = 10747914;
    MEMORY[0x1837129C] = 13107215;
    MEMORY[0x183712A0] = 13369364;
    MEMORY[0x183712A4] = 8454169;
    MEMORY[0x183712A8] = 10813470;
    MEMORY[0x183712AC] = 13172771;
    MEMORY[0x183712B0] = 13434920;
    MEMORY[0x183712B4] = 8519725;
    MEMORY[0x183712B8] = 10879026;
    MEMORY[0x183712BC] = 13238327;
    MEMORY[0x183712C0] = 13500476;
    MEMORY[0x183712C4] = 14286913;
    MEMORY[0x183712C8] = 14286918;
    MEMORY[0x183712CC] = 14286923;
    MEMORY[0x183712D0] = 2161688;
    MEMORY[0x183712D4] = 1113612;
    MEMORY[0x183712D8] = 589574;
    MEMORY[0x183712DC] = 327555;
    MEMORY[0x183712E0] = 196545;
    MEMORY[0x183712E4] = 131041;
    MEMORY[0x183712E8] = 131056;
    MEMORY[0x183712F0] = -65520;
    MEMORY[0x183712F4] = -65505;
    MEMORY[0x183712F8] = -131009;
    MEMORY[0x183712FC] = -262019;
    MEMORY[0x18371300] = -524038;
    MEMORY[0x18371304] = -1048076;
    MEMORY[0x18371308] = -2096152;
    MEMORY[0x1837130C] = -2096152;
    MEMORY[0x18371A80] = 1;
    result = 406257808LL;
    MEMORY[0x18370090] = 17;
  }
  return result;
}
// 1AEB0: using guessed type char lmh_enable;
// 31898: using guessed type __int64 lmh_hsr_version[1];
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000008440) ----------------------------------------------------
__int64 CPR11_SVSL1_QUOT_VMIN()
{
  return 16 * (unsigned int)MEMORY[0x7842B0] + (MEMORY[0x7842AC] >> 28);
}

//----- (0000000000008460) ----------------------------------------------------
__int64 cpucp_prepare()
{
  MEMORY[0x18598000] |= 1u;
  MEMORY[0x18580000] |= 1u;
  while ( (MEMORY[0x18580000] & 1) == 0 )
    ;
  return 0LL;
}

//----- (0000000000008494) ----------------------------------------------------
__int64 cpucp_unprepare()
{
  MEMORY[0x18598000] &= ~1u;
  MEMORY[0x18580000] &= ~1u;
  return 0LL;
}

//----- (00000000000084C0) ----------------------------------------------------
__int64 cpucp_host_configure_shared_data()
{
  __int64 result; // x0
  char v1; // w20
  __int16 v2; // w0
  __int16 v3; // x5^2
  _DWORD *v4; // x6
  int *v5; // x3
  int v6; // w0
  char v7; // w2
  _DWORD *v8; // x4

  result = 0xFFFFFFFFLL;
  v1 = MEMORY[0x18508000];
  if ( MEMORY[0x18508000] == 3 )
  {
    calculate_cpumasks(407930404LL);
    MEMORY[0x18508634] |= MEMORY[0x1850862C] | MEMORY[0x18508628] | MEMORY[0x18508624] | MEMORY[0x18508630];
    MEMORY[0x18508220] = MEMORY[0x1FC8000] | (MEMORY[0x1FC8001] << 16);
    MEMORY[0x18508224] = (MEMORY[0x784210] >> 6) & 0xF;
    MEMORY[0x18508228] = MEMORY[0x784180] >> 29;
    MEMORY[0x18508234] = MEMORY[0x78070C] & 0xF;
    MEMORY[0x18508238] = MEMORY[0x7802DC] >> 29;
    MEMORY[0x1850822C] = (unsigned __int8)((unsigned __int64)MEMORY[0x784180] >> 20);
    MEMORY[0x185082A1] = 8;
    MEMORY[0x185082A2] = 8;
    MEMORY[0x185082A3] = 8;
    MEMORY[0x185085D3] = 0;
    MEMORY[0x185085DC] = 0;
    MEMORY[0x185085CA] = 0;
    MEMORY[0x18508230] = MEMORY[0x784180] & 0xFFFFF;
    MEMORY[0x1850837A] = 8
                       * ((MEMORY[0x784290] >> 13) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x784290] << 45) >> 63) | 1);
    MEMORY[0x1850837C] = 8
                       * ((4 * (MEMORY[0x7842AC] & 0xF) + (MEMORY[0x7842A8] >> 30)) & 0x1F)
                       * (((__int64)((unsigned __int64)(4 * (MEMORY[0x7842AC] & 0xFu) + (MEMORY[0x7842A8] >> 30)) << 58) >> 63) | 1);
    MEMORY[0x1850837E] = 8 * (MEMORY[0x7842AB] & 0x1F) * (((__int16)(MEMORY[0x7842A8] >> 14) >> 15) | 1);
    MEMORY[0x1850847C] = CPR11_SVSL1_QUOT_VMIN() - ((MEMORY[0x7842B0] >> 8) & 0xFFF);
    v2 = CPR11_SVSL1_QUOT_VMIN();
    MEMORY[0x1850847E] = (v3 & 0xFFF) - v2;
    MEMORY[0x1850857A] = (*v4 >> 8) & 0xFFF;
    MEMORY[0x1850857C] = CPR11_SVSL1_QUOT_VMIN();
    v6 = *v5;
    MEMORY[0x185082A4] = v7;
    MEMORY[0x1850857E] = HIWORD(v6) & 0xFFF;
    MEMORY[0x18508380] = 8 * ((*v8 >> 18) & 0x1F) * (((__int64)((unsigned __int64)(unsigned int)*v8 << 40) >> 63) | 1);
    MEMORY[0x18508480] = ((unsigned __int16)*v5 >> 4) - (HIWORD(*v5) & 0xFFF);
    MEMORY[0x18508580] = (unsigned __int16)*v5 >> 4;
    MEMORY[0x185082A9] = v7;
    MEMORY[0x185082AA] = v7;
    MEMORY[0x18508244] = (unsigned __int64)MEMORY[0x7842B4] >> 10;
    MEMORY[0x185082AB] = 9;
    MEMORY[0x1850838A] = 8
                       * ((MEMORY[0x7842B8] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B8] << 54) >> 63) | 1);
    MEMORY[0x1850838C] = 8
                       * ((4 * (MEMORY[0x7842B8] & 0xF) + (MEMORY[0x7842B4] >> 30)) & 0x1F)
                       * (((__int64)((unsigned __int64)(4 * (MEMORY[0x7842B8] & 0xFu) + (MEMORY[0x7842B4] >> 30)) << 58) >> 63) | 1);
    MEMORY[0x1850838E] = 8
                       * (MEMORY[0x7842B7] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B4] << 34) >> 63) | 1);
    MEMORY[0x1850848C] = (((unsigned __int64)MEMORY[0x7842BC] >> 2) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842BC] >> 14) & 0xFFF);
    MEMORY[0x1850848E] = 5 * (((MEMORY[0x7842C0] & 3) << 6) + (MEMORY[0x7842BC] >> 26));
    MEMORY[0x1850858A] = ((unsigned __int64)MEMORY[0x7842BC] >> 14) & 0xFFF;
    MEMORY[0x1850858C] = ((unsigned __int64)MEMORY[0x7842BC] >> 2) & 0xFFF;
    MEMORY[0x185082AC] = 9;
    MEMORY[0x1850858E] = ((MEMORY[0x7842BC] & 3) << 10) + (MEMORY[0x7842B8] >> 22);
    MEMORY[0x18508390] = 8
                       * ((MEMORY[0x7842B4] >> 18) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842B4] << 40) >> 63) | 1);
    MEMORY[0x185082B9] = v7;
    MEMORY[0x185082BA] = v7;
    MEMORY[0x18508245] = (unsigned __int64)MEMORY[0x7842B4] >> 10;
    MEMORY[0x185082BB] = v7;
    MEMORY[0x18508590] = ((unsigned __int64)MEMORY[0x7842B8] >> 10) & 0xFFF;
    MEMORY[0x18508490] = MEMORY[0x18508590] - (MEMORY[0x7842B8] >> 22) - ((MEMORY[0x7842BC] & 3) << 10);
    MEMORY[0x185083AA] = 8
                       * (((unsigned __int64)MEMORY[0x7842D4] >> 22) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 36) >> 63) | 1);
    MEMORY[0x185083AC] = 8
                       * (MEMORY[0x7842D6] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 42) >> 63) | 1);
    MEMORY[0x185083AE] = 8
                       * ((MEMORY[0x7842D4] >> 10) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 48) >> 63) | 1);
    MEMORY[0x185084AC] = (MEMORY[0x7842D8] >> 20) - (MEMORY[0x7842DC] & 0xFFF);
    MEMORY[0x185084AE] = ((MEMORY[0x7842D8] >> 8) & 0xFFF) - (MEMORY[0x7842D8] >> 20);
    MEMORY[0x185085AA] = MEMORY[0x7842DC] & 0xFFF;
    MEMORY[0x185085AC] = MEMORY[0x7842D8] >> 20;
    MEMORY[0x185082BD] = v7;
    MEMORY[0x185085AE] = (MEMORY[0x7842D8] >> 8) & 0xFFF;
    MEMORY[0x185083B2] = 8
                       * (((unsigned __int64)MEMORY[0x7842D4] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842D4] << 54) >> 63) | 1);
    MEMORY[0x185084B2] = 16 * MEMORY[0x7842D8] + (MEMORY[0x7842D4] >> 28) - ((MEMORY[0x7842D8] >> 8) & 0xFFF);
    MEMORY[0x185085B2] = 16 * MEMORY[0x7842D8] + (MEMORY[0x7842D4] >> 28);
    MEMORY[0x185082B3] = 11;
    MEMORY[0x185082B1] = 13;
    MEMORY[0x18508247] = 16 * (MEMORY[0x7842D4] & 0xF) + (MEMORY[0x7842D0] >> 28);
    MEMORY[0x185082B2] = 13;
    MEMORY[0x1850839A] = 8
                       * ((16 * (MEMORY[0x7842C8] & 3) + (MEMORY[0x7842C4] >> 28)) & 0x1F)
                       * (((__int64)((unsigned __int64)(16 * (MEMORY[0x7842C8] & 3u) + (MEMORY[0x7842C4] >> 28)) << 58) >> 63) | 1);
    MEMORY[0x1850839C] = 8
                       * ((MEMORY[0x7842C4] >> 22) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 36) >> 63) | 1);
    MEMORY[0x1850839E] = 8
                       * (MEMORY[0x7842C6] & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 42) >> 63) | 1);
    MEMORY[0x1850849C] = (((unsigned __int64)MEMORY[0x7842CC] >> 6) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842CC] >> 18) & 0xFFF);
    MEMORY[0x1850849E] = 5 * (unsigned __int8)((unsigned __int64)MEMORY[0x7842D0] >> 14);
    MEMORY[0x1850859A] = ((unsigned __int64)MEMORY[0x7842CC] >> 18) & 0xFFF;
    MEMORY[0x1850859C] = ((unsigned __int64)MEMORY[0x7842CC] >> 6) & 0xFFF;
    MEMORY[0x185082B5] = 11;
    MEMORY[0x1850859E] = ((MEMORY[0x7842CC] & 0x3F) << 6) + (MEMORY[0x7842C8] >> 26);
    MEMORY[0x185083A2] = 8
                       * ((MEMORY[0x7842C4] >> 4) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 54) >> 63) | 1);
    MEMORY[0x185084A2] = (((unsigned __int64)MEMORY[0x7842C8] >> 2) & 0xFFF)
                       - (((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF);
    MEMORY[0x185082B4] = 11;
    MEMORY[0x185085A2] = ((unsigned __int64)MEMORY[0x7842C8] >> 2) & 0xFFF;
    MEMORY[0x185083A0] = 8
                       * ((MEMORY[0x7842C4] >> 10) & 0x1F)
                       * (((__int64)((unsigned __int64)MEMORY[0x7842C4] << 48) >> 63) | 1);
    MEMORY[0x185084A0] = (((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF)
                       - (MEMORY[0x7842C8] >> 26)
                       - ((MEMORY[0x7842CC] & 0x3F) << 6);
    MEMORY[0x185085A0] = ((unsigned __int64)MEMORY[0x7842C8] >> 14) & 0xFFF;
    MEMORY[0x18508246] = MEMORY[0x18508247];
    cmd_db_tzbsp_init();
    MEMORY[0x185085F0] = cmd_db_query_addr((__int64)"mx.lvl");
    MEMORY[0x185085F4] = 28;
    cmd_db_query_aux_data((__int64)"mx.lvl", (_BYTE *)0x185085F4, 407930358LL);
    MEMORY[0x18508614] = v1;
    MEMORY[0x18508615] = 13;
    MEMORY[0x18508618] = 0;
    MEMORY[0x18508616] = 1;
    MEMORY[0x18508617] = 1;
    MEMORY[0x18508619] = 1;
    MEMORY[0x1850861B] = 1;
    MEMORY[0x1850861D] = 1;
    MEMORY[0x1850861F] = 1;
    result = 0LL;
    MEMORY[0x1850861A] = 0;
    MEMORY[0x1850861C] = 0;
    MEMORY[0x1850861E] = 0;
    MEMORY[0x18508620] = 0;
  }
  return result;
}
// 8684: variable 'v3' is possibly undefined
// 8690: variable 'v4' is possibly undefined
// 86A4: variable 'v5' is possibly undefined
// 86AC: variable 'v7' is possibly undefined
// 86B8: variable 'v8' is possibly undefined
// 478C: using guessed type __int64 cmd_db_tzbsp_init(void);

//----- (0000000000008BC8) ----------------------------------------------------
__int64 cpucp_start()
{
  __int64 result; // x0

  MEMORY[0x182A00B0] = MEMORY[0x182A00B0] & 3 | 0x200;
  MEMORY[0x182A00B0] = MEMORY[0x182A00B0] & 0xF00 | 1;
  MEMORY[0x182A000C] = MEMORY[0x182A000C] & 0xF0000000 | 1;
  MEMORY[0x182A0010] = 2;
  MEMORY[0x182A007C] = MEMORY[0x182A007C] & 0xF0000000 | 1;
  MEMORY[0x182A0080] = 0;
  MEMORY[0x182A005C] = MEMORY[0x182A005C] & 0xF0000000 | 1;
  MEMORY[0x182A0060] = 0;
  MEMORY[0x182A008C] = MEMORY[0x182A008C] & 0xF0000000 | 1;
  MEMORY[0x182A0090] = 1;
  MEMORY[0x18598018] = 19230;
  MEMORY[0x18598010] |= 1u;
  result = cpucp_host_configure_shared_data();
  if ( !(_DWORD)result )
  {
    MEMORY[0x18598000] &= ~1u;
    MEMORY[0x18598024] = 0;
    MEMORY[0x18598004] |= 1u;
    result = MEMORY[0x18580000] | 2u;
    MEMORY[0x18580000] |= 2u;
  }
  return result;
}

//----- (0000000000008D10) ----------------------------------------------------
__int64 cpucp_load_firmware()
{
  return 0LL;
}

//----- (0000000000008D18) ----------------------------------------------------
__int64 __fastcall pdcMap_getInterruptTable(__int64 a1)
{
  if ( !a1 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/mapping.c", 0x3Fu, "((void *) 0) != (intMap)");
  *(_QWORD *)a1 = g_pdcInterruptMapping;
  *(_DWORD *)(a1 + 8) = 70;
  return 0LL;
}
// 1AB68: using guessed type _DWORD g_pdcInterruptMapping[210];

//----- (0000000000008D6C) ----------------------------------------------------
__int64 __fastcall pdcMap_getGpioTable(__int64 a1)
{
  if ( !a1 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/mapping.c", 0x48u, "((void *) 0) != (gpioMap)");
  *(_QWORD *)a1 = g_pdcGpioInputs;
  *(_QWORD *)(a1 + 8) = g_pdcGpioMapping;
  *(_DWORD *)(a1 + 16) = 98;
  *(_DWORD *)(a1 + 20) = 98;
  return 0LL;
}
// 1A670: using guessed type _WORD g_pdcGpioInputs[196];
// 1AEB8: using guessed type _QWORD g_pdcGpioMapping[294];

//----- (0000000000008DD8) ----------------------------------------------------
__int64 __fastcall mapOS_getInterruptTable(__int64 a1)
{
  *(_QWORD *)a1 = g_pdcInterruptMapping;
  *(_DWORD *)(a1 + 8) = 70;
  return 0LL;
}
// 1AB68: using guessed type _DWORD g_pdcInterruptMapping[210];

//----- (0000000000008DF8) ----------------------------------------------------
__int64 __fastcall mapOS_getGpioTable(__int64 a1)
{
  *(_QWORD *)a1 = g_pdcGpioInputs;
  *(_QWORD *)(a1 + 8) = g_pdcGpioMapping;
  *(_DWORD *)(a1 + 16) = 98;
  *(_DWORD *)(a1 + 20) = 98;
  return 0LL;
}
// 1A670: using guessed type _WORD g_pdcGpioInputs[196];
// 1AEB8: using guessed type _QWORD g_pdcGpioMapping[294];

//----- (0000000000008E30) ----------------------------------------------------
__int64 __fastcall mem_get_next_block(__int64 a1, __int64 a2)
{
  __int64 v3; // x19
  unsigned __int16 v4; // w0
  unsigned int v5; // w1
  const char *v6; // x2

  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0xF9u, "block_ptr != ((void *) 0)");
  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0xFAu, "heap_ptr != ((void *) 0)");
  if ( !*(_DWORD *)(a2 + 4) )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0xFBu, "block_ptr->forw_offset != 0");
  if ( a2 + (unsigned __int64)*(unsigned int *)(a2 + 4) > *(_QWORD *)(a1 + 8)
                                                        + (unsigned __int64)*(unsigned int *)(a1 + 28) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0xFCu,
      "((((mem_block_header_type *)block_ptr)->forw_offset + (char *)block_ptr) <= ((((char*)((mem_heap_type*)heap_ptr)->"
      "first_block) + ((mem_heap_type*)heap_ptr)->total_bytes)))");
  if ( (*(_DWORD *)(a2 + 4) & 0xFLL) != 0 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0xFDu, "!((block_ptr->forw_offset)%kMinChunkSize)");
  if ( (*(_BYTE *)(a2 + 3) & 0xF0) != 0 )
    v3 = *(_QWORD *)(a1 + 8);
  else
    v3 = a2 + *(unsigned int *)(a2 + 4);
  v4 = *(_WORD *)v3 ^ *(_WORD *)(v3 + 2) ^ *(_WORD *)(v3 + 4) ^ *(_WORD *)(v3 + 6);
  if ( (*(_BYTE *)(v3 + 3) & 0xF) == 1 )
  {
    if ( *(unsigned __int16 *)(a1 + 72) != v4 )
    {
      v5 = 259;
      v6 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_free)";
      goto LABEL_19;
    }
  }
  else if ( *(unsigned __int16 *)(a1 + 74) != v4 )
  {
    v5 = 262;
    v6 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_used)";
LABEL_19:
    qtisec_assert("noship_src/services/heap/memheap_lite.c", v5, v6);
  }
  return v3;
}

//----- (0000000000008F94) ----------------------------------------------------
__int64 __fastcall mem_heap_leave_crit_sect(__int64 a1)
{
  qtiseclib_cb_spin_unlock(*(_QWORD *)(a1 + 64));
  return 1LL;
}
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000008FB0) ----------------------------------------------------
__int64 __fastcall mem_heap_enter_crit_sect(__int64 a1)
{
  qtiseclib_cb_spin_lock(*(_QWORD *)(a1 + 64));
  return 1LL;
}
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);

//----- (0000000000008FCC) ----------------------------------------------------
__int64 __fastcall mem_init_block_header_isra_0(__int64 a1, int a2)
{
  __int64 result; // x0

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x19Bu, "block_ptr");
  qtiseclib_cb_memset(a1, 0LL, 8LL);
  *(_DWORD *)(a1 + 4) = a2;
  result = 1LL;
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a1 + 3) & 0xF0 | 1;
  return result;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000902C) ----------------------------------------------------
__int64 __fastcall mem_init_heap(int *a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  int v8; // w0
  __int64 v9; // x21
  __int64 i; // x0
  __int64 v11; // x4
  unsigned __int16 v12; // w1
  __int16 v13; // w1
  int v14; // w21
  _WORD *v15; // x1
  __int16 v16; // w2
  __int16 v17; // w3
  __int16 v18; // w0
  __int16 v19; // w2
  __int16 v20; // w0

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x138u, "heap_ptr");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x139u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Au, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Bu, "mem_magic_number->magic_num_index_array");
  if ( *((_WORD *)a2 + 8) )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x13Du, "mem_magic_number->magic_num_index < 1");
  v8 = *a1;
  if ( !*a1 || v8 != *(_DWORD *)(*a2 + 4LL * *((unsigned __int16 *)a1 + 38)) )
  {
    qtiseclib_cb_memset(a1, 0LL, 80LL);
    if ( !a3 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x147u, "heap_mem_ptr");
    if ( !a4 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x148u, "heap_mem_size");
    if ( a4 <= 0x1E )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x149u, "heap_mem_size >= (2*kMinChunkSize-1)");
    v9 = a3 + a4;
    while ( (a3 & 0xF) != 0 )
      ++a3;
    *((_QWORD *)a1 + 8) = a3;
    qtiseclib_cb_memset(a3, 0LL, 4LL);
    *((_QWORD *)a1 + 6) = mem_heap_enter_crit_sect;
    *((_QWORD *)a1 + 7) = mem_heap_leave_crit_sect;
    for ( i = a3 + 4; (i & 0xF) != 0; ++i )
      ;
    v11 = *a2;
    v12 = *(_WORD *)(a2[1] + 2LL * *((unsigned __int16 *)a2 + 8));
    *((_QWORD *)a1 + 1) = i;
    *((_QWORD *)a1 + 2) = i;
    *(_DWORD *)(v11 + 4LL * v12) = -1412571974;
    *((_WORD *)a1 + 38) = v12;
    *((_WORD *)a1 + 36) = -21555;
    *((_WORD *)a1 + 37) = -21555;
    v13 = *((_WORD *)a2 + 8);
    *a1 = -1412571974;
    *((_WORD *)a2 + 8) = v13 + 1;
    v14 = 16 * ((v9 - i) / 16);
    mem_init_block_header_isra_0(i, v14);
    *(_BYTE *)(*((_QWORD *)a1 + 1) + 3LL) = *(_BYTE *)(*((_QWORD *)a1 + 1) + 3LL) & 0xF | 0x10;
    v15 = (_WORD *)*((_QWORD *)a1 + 1);
    v16 = v15[1];
    v17 = v15[3];
    a1[6] = 1;
    a1[7] = v14;
    v18 = v15[2];
    a1[8] = 0;
    a1[9] = 0;
    v19 = v16 ^ v18;
    v20 = *((_WORD *)a1 + 36);
    a1[10] = 0;
    *v15 = v19 ^ v17 ^ v20;
  }
  return 1LL;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (0000000000009270) ----------------------------------------------------
unsigned __int64 __fastcall mem_malloc(__int64 a1, _QWORD *a2, unsigned int a3)
{
  unsigned __int64 result; // x0
  void (__fastcall *v8)(__int64); // x1
  unsigned __int64 v9; // x21
  char v10; // w24
  __int16 *v11; // x2
  __int16 v12; // w3
  __int16 v13; // w4
  __int16 v14; // w1
  __int16 v15; // w0
  unsigned int v16; // w1
  const char *v17; // x2
  __int64 v18; // x25
  unsigned __int64 i; // x22
  unsigned __int64 v20; // x20
  unsigned int v21; // w0
  char v23; // w1
  _WORD *v24; // x1
  unsigned __int64 v25; // x20
  unsigned __int64 v26; // x1
  __int16 v27; // w1
  __int16 v28; // w2
  int v29; // w0
  char v30; // w0
  unsigned int v31; // w1
  unsigned int v32; // w0
  unsigned int v33; // w0
  void (__fastcall *v34)(__int64); // x1

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D2u, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D4u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D5u, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1D6u, "mem_magic_number->magic_num_index_array");
  result = 0LL;
  if ( a3 )
  {
    result = 0LL;
    if ( a3 <= *(_DWORD *)(a1 + 28) && a3 <= 0xFFFFFFE7 )
    {
      v8 = *(void (__fastcall **)(__int64))(a1 + 48);
      v9 = (a3 + 23LL) & 0x1FFFFFFF0LL;
      v10 = v9 - a3 - 8;
      if ( v8 )
        v8(a1);
      if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
        qtisec_assert(
          "noship_src/services/heap/memheap_lite.c",
          0x1EFu,
          "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
      if ( !*(_QWORD *)(a1 + 8) )
        qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2CAu, "heap_ptr->first_block");
      v11 = *(__int16 **)(a1 + 16);
      v12 = v11[2];
      v13 = *v11;
      v14 = v11[1];
      v15 = v11[3];
      if ( (*((_BYTE *)v11 + 3) & 0xF) == 1 )
      {
        if ( *(unsigned __int16 *)(a1 + 72) != (unsigned __int16)(v12 ^ v15 ^ v13 ^ v14) )
        {
          v16 = 718;
          v17 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_free)";
          goto LABEL_25;
        }
      }
      else if ( *(unsigned __int16 *)(a1 + 74) != (unsigned __int16)(v13 ^ v14 ^ v12 ^ v15) )
      {
        v16 = 722;
        v17 = "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_used)";
LABEL_25:
        qtisec_assert("noship_src/services/heap/memheap_lite.c", v16, v17);
      }
      v18 = *(unsigned int *)(a1 + 24);
      for ( i = mem_get_next_block(a1, *(_QWORD *)(a1 + 16)); ; i = mem_get_next_block(a1, i) )
      {
        if ( v18 <= 0 )
        {
          v25 = 0LL;
          goto LABEL_53;
        }
        if ( !*(_DWORD *)(*(_QWORD *)(a1 + 16) + 4LL) )
          qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2DCu, "heap_ptr->next_block->forw_offset > 0");
        if ( !*(_DWORD *)(i + 4) )
          qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x2DDu, "followingBlock->forw_offset > 0");
        if ( (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 3LL) & 0xF) != 0 )
          break;
LABEL_40:
        *(_QWORD *)(a1 + 16) = i;
        --v18;
      }
      while ( 1 )
      {
        v20 = *(_QWORD *)(a1 + 16);
        v21 = *(_DWORD *)(v20 + 4);
        if ( v9 <= v21 )
          break;
        if ( (*(_BYTE *)(i + 3) & 0xF) == 0 || i <= v20 )
          goto LABEL_40;
        --v18;
        v23 = *(_BYTE *)(v20 + 3);
        *(_DWORD *)(v20 + 4) = *(_DWORD *)(i + 4) + v21;
        *(_BYTE *)(v20 + 3) = v23 & 0xF | (16 * ((*(_BYTE *)(i + 3) >> 4) & 0xF));
        v24 = *(_WORD **)(a1 + 16);
        *v24 = v24[3] ^ *(_WORD *)(a1 + 72) ^ v24[1] ^ v24[2];
        --*(_DWORD *)(a1 + 24);
        *(_DWORD *)i = 0;
        *(_DWORD *)(i + 4) = 0;
        i = mem_get_next_block(a1, (__int64)v24);
      }
      if ( !v21 )
        qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x1F6u, "freeBlock->forw_offset > 0");
      v26 = *(unsigned int *)(v20 + 4);
      if ( v9 < v26 )
      {
        mem_init_block_header_isra_0(v20 + v9, v26 - v9);
        *(_BYTE *)(v20 + v9 + 3) = *(_BYTE *)(v20 + v9 + 3) & 0xF | (16 * ((*(_BYTE *)(v20 + 3) >> 4) & 0xF));
        *(_BYTE *)(v20 + 3) &= 0xFu;
        v27 = *(_WORD *)(v20 + v9 + 2);
        v28 = *(_WORD *)(v20 + v9 + 6);
        v29 = *(_DWORD *)(a1 + 24) + 1;
        *(_DWORD *)(v20 + 4) = v9;
        *(_DWORD *)(a1 + 24) = v29;
        *(_WORD *)(v20 + v9) = v27 ^ *(_WORD *)(v20 + v9 + 4) ^ v28 ^ *(_WORD *)(a1 + 72);
      }
      v30 = *(_BYTE *)(v20 + 3);
      *(_BYTE *)(v20 + 2) = v10;
      *(_BYTE *)(v20 + 3) = v30 & 0xF0;
      *(_QWORD *)(a1 + 16) = mem_get_next_block(a1, v20);
      v31 = *(_DWORD *)(a1 + 28);
      v32 = a3 + *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 32) = v32;
      if ( v32 > v31 )
        qtisec_assert(
          "noship_src/services/heap/memheap_lite.c",
          0x210u,
          "heap_ptr->total_bytes >= heap_ptr->used_bytes");
      v33 = *(_DWORD *)(a1 + 32);
      if ( v33 > *(_DWORD *)(a1 + 36) )
        *(_DWORD *)(a1 + 36) = v33;
      if ( a3 > *(_DWORD *)(a1 + 40) )
        *(_DWORD *)(a1 + 40) = a3;
      *(_WORD *)v20 = *(_WORD *)(v20 + 2) ^ *(_WORD *)(v20 + 4) ^ *(_WORD *)(v20 + 6) ^ *(_WORD *)(a1 + 74);
      v25 = v20 + 8;
LABEL_53:
      v34 = *(void (__fastcall **)(__int64))(a1 + 56);
      result = v25;
      if ( v34 )
      {
        v34(a1);
        return v25;
      }
    }
  }
  return result;
}

//----- (0000000000009690) ----------------------------------------------------
__int64 __fastcall mem_free(__int64 a1, _QWORD *a2, __int64 a3)
{
  void (__fastcall *v5)(__int64); // x1
  unsigned __int64 v6; // x21
  unsigned __int64 v7; // x1
  unsigned int v8; // w0
  unsigned int v9; // w1
  int v10; // w1
  __int64 v11; // x0
  _WORD *v12; // x1
  __int16 v13; // w2
  __int16 v14; // w3
  void (__fastcall *v15)(__int64); // x1

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Bu, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Cu, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Du, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x24Eu, "mem_magic_number->magic_num_index_array");
  if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x251u,
      "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
  if ( !a3 )
  {
    qtiseclib_cb_log(10LL, "NULL ptr occurenaces in mem_free()");
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x258u, "0");
  }
  if ( !*(_QWORD *)(a1 + 8) )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x25Eu, "heap_ptr->first_block");
  v5 = *(void (__fastcall **)(__int64))(a1 + 48);
  if ( v5 )
    v5(a1);
  v6 = a3 - 8;
  if ( ((a3 - 8) & 0xF) != 0 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x26Du, "(((uintptr_t)theBlock)%kMinChunkSize) == 0");
  v7 = *(_QWORD *)(a1 + 8);
  if ( v6 < v7 || v6 >= v7 + *(unsigned int *)(a1 + 28) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x270u,
      "((theBlock >= ((mem_heap_type*)heap_ptr)->first_block) && (((char*)(theBlock)) < ((char*)(((mem_heap_type*)heap_pt"
      "r)->first_block) + ((mem_heap_type*)(heap_ptr))->total_bytes)))");
  if ( (*(_BYTE *)(a3 - 5) & 0xF) != 0 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x274u, "!theBlock->free_flag");
  if ( *(_DWORD *)(a3 - 4) <= 7u )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x277u, "theBlock->forw_offset >= sizeBlockHeader");
  if ( *(unsigned __int8 *)(a3 - 6) > 0xFu )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x279u, "theBlock->extra < kMinChunkSize");
  if ( v6 + *(unsigned int *)(a3 - 4) > *(_QWORD *)(a1 + 8) + (unsigned __int64)*(unsigned int *)(a1 + 28) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x27Cu,
      "((((mem_block_header_type *)theBlock)->forw_offset + (char *)theBlock) <= ((((char*)((mem_heap_type*)heap_ptr)->fi"
      "rst_block) + ((mem_heap_type*)heap_ptr)->total_bytes)))");
  if ( *(unsigned __int16 *)(a1 + 74) != (unsigned __int16)(*(_WORD *)(a3 - 8) ^ *(_WORD *)(a3 - 6) ^ *(_WORD *)(a3 - 4) ^ *(_WORD *)(a3 - 2)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x280u,
      "!(pblk[0]^pblk[1]^pblk[2]^pblk[3]^heap_ptr->magic_num_used)");
  if ( (*(_BYTE *)(a3 - 5) & 0xF) == 0 )
  {
    if ( *(_DWORD *)(a3 - 4) - 8 - (unsigned int)*(unsigned __int8 *)(a3 - 6) > *(_DWORD *)(a1 + 32) )
      qtisec_assert(
        "noship_src/services/heap/memheap_lite.c",
        0x287u,
        "(theBlock->forw_offset - sizeBlockHeader - theBlock->extra) <= heap_ptr->used_bytes");
    v8 = *(unsigned __int8 *)(a3 - 6) - *(_DWORD *)(a3 - 4) + *(_DWORD *)(a1 + 32) + 8;
    v9 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 32) = v8;
    if ( v8 > v9 )
      qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x28Au, "heap_ptr->total_bytes >= heap_ptr->used_bytes");
    *(_BYTE *)(a3 - 5) = *(_BYTE *)(a3 - 5) & 0xF0 | 1;
    if ( v6 < *(_QWORD *)(a1 + 16) )
      *(_QWORD *)(a1 + 16) = v6;
    *(_WORD *)(a3 - 8) = *(_WORD *)(a3 - 6) ^ *(_WORD *)(a3 - 4) ^ *(_WORD *)(a3 - 2) ^ *(_WORD *)(a1 + 72);
    if ( !*(_DWORD *)(a1 + 32) )
    {
      v10 = *(_DWORD *)(a1 + 28);
      v11 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v11;
      mem_init_block_header_isra_0(v11, v10);
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + 3LL) = *(_BYTE *)(*(_QWORD *)(a1 + 8) + 3LL) & 0xF | 0x10;
      v12 = *(_WORD **)(a1 + 8);
      v13 = v12[1];
      v14 = v12[3];
      *(_DWORD *)(a1 + 24) = 1;
      *v12 = v13 ^ v12[2] ^ v14 ^ *(_WORD *)(a1 + 72);
    }
  }
  v15 = *(void (__fastcall **)(__int64))(a1 + 56);
  if ( v15 )
    v15(a1);
  return 1LL;
}
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (0000000000009A24) ----------------------------------------------------
__int64 __fastcall mem_get_buffer_size(__int64 a1)
{
  if ( a1 )
    return (unsigned int)(*(_DWORD *)(a1 - 4) - 8);
  else
    return 0LL;
}

//----- (0000000000009A3C) ----------------------------------------------------
unsigned __int64 __fastcall mem_realloc(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4)
{
  __int64 v9; // x1
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x23
  __int64 v12; // x2

  if ( !a1 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x33Fu, "heap_ptr != ((void *) 0)");
  if ( !a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x340u, "mem_magic_number");
  if ( !*a2 )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x341u, "mem_magic_number->magic_num");
  if ( !a2[1] )
    qtisec_assert("noship_src/services/heap/memheap_lite.c", 0x342u, "mem_magic_number->magic_num_index_array");
  if ( *(_DWORD *)a1 != *(_DWORD *)(*a2 + 4LL * *(unsigned __int16 *)(a1 + 76)) )
    qtisec_assert(
      "noship_src/services/heap/memheap_lite.c",
      0x343u,
      "heap_ptr->magic_num == mem_magic_number->magic_num[heap_ptr->magic_num_index]");
  if ( !a3 )
    return mem_malloc(a1, a2, a4);
  if ( a4 )
  {
    v10 = mem_malloc(a1, a2, a4);
    v11 = v10;
    v9 = 0LL;
    if ( v10 )
    {
      LODWORD(v12) = *(_DWORD *)(a3 - 4) - 8;
      if ( (unsigned int)v12 > a4 )
        v12 = a4;
      else
        v12 = (unsigned int)v12;
      qtiseclib_cb_memcpy(v10, a3, v12);
      mem_free(a1, a2, a3);
      return v11;
    }
  }
  else
  {
    mem_free(a1, a2, a3);
    return 0LL;
  }
  return v9;
}
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000009BA8) ----------------------------------------------------
__int64 __fastcall NOC_Error_Handle_Interrupt(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // w7
  __int64 v5; // x20
  unsigned int v6; // w21
  const char *v7; // x0
  unsigned int i; // w22
  unsigned int v9; // w22
  int v10; // w6
  const char *v11; // x0
  unsigned int j; // w0
  unsigned int k; // w1
  __int64 v14; // x27
  const char **v15; // x19
  const char *v16; // x1
  const char *v17; // x2
  __int64 v18; // x3
  const char *v19; // x2
  __int64 v20; // x3
  const char *v21; // x2
  __int64 v22; // x3
  const char *v23; // x2
  __int64 v24; // x3
  const char *v25; // x2
  __int64 v26; // x3
  const char *v27; // x2
  __int64 v28; // x3
  const char *v29; // x2
  __int64 v30; // x3
  const char *v31; // x2
  __int64 v32; // x3
  int v33; // w1
  int v34; // w4
  const char *v35; // x2
  int v36; // w0
  __int64 v37; // x4
  const char *v38; // x2
  int v39; // w0
  __int64 v40; // x4
  const char *v41; // x2
  int v42; // w0
  __int64 v43; // x4
  const char *v44; // x2
  __int64 v45; // x24
  const char *v46; // x1
  __int64 v47; // x2
  int v48; // w0
  int v49; // w0
  int v50; // w0
  int v51; // w1
  unsigned __int16 *v52; // x0
  int v53; // w5
  __int64 v54; // x6
  int v55; // w3
  __int64 v56; // x5
  int v57; // w3
  __int64 v58; // x5
  int v59; // w3
  __int64 v60; // x2
  __int64 v61; // x0
  int v63; // [xsp+68h] [xbp+68h]
  int v64; // [xsp+6Ch] [xbp+6Ch]

  if ( !NOCInfo || !NOCInfoOEM )
  {
    qtiseclib_cb_log(10LL, "Invalid NOC info data structures!");
    return a3;
  }
  v4 = 0;
  v5 = 0LL;
  v6 = 0;
LABEL_17:
  if ( v6 < *(_DWORD *)(NOCERR_propdata + 12) )
  {
    v14 = NOCInfo;
    v15 = (const char **)(NOCInfo + 176LL * v6);
    if ( v15[3] != (const char *)(unsigned int)a3 )
      goto LABEL_16;
    v5 = NOCInfoOEM + 48LL * v6;
    if ( !v5 )
    {
      qtiseclib_cb_log(10LL, "Invalid Interrupt Vector!");
      return a3;
    }
    v7 = v15[2];
    if ( v7 )
    {
      v16 = v15[1];
      if ( *(_DWORD *)&v7[*((unsigned __int16 *)v16 + 3)] )
      {
        v17 = *(const char **)(NOCInfo + 176LL * v6);
        v18 = *(unsigned int *)&v7[*((unsigned __int16 *)v16 + 5)];
        *((_DWORD *)v15 + 18) = v18;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG0_LOW = 0x%08x", v17, v18);
        v19 = *(const char **)(v14 + 176LL * v6);
        v20 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 6)];
        *((_DWORD *)v15 + 19) = v20;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG0_HIGH = 0x%08x", v19, v20);
        v21 = *(const char **)(v14 + 176LL * v6);
        v22 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 7)];
        *((_DWORD *)v15 + 20) = v22;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG1_LOW = 0x%08x", v21, v22);
        v23 = *(const char **)(v14 + 176LL * v6);
        v24 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 8)];
        *((_DWORD *)v15 + 21) = v24;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG1_HIGH = 0x%08x", v23, v24);
        v25 = *(const char **)(v14 + 176LL * v6);
        v26 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 9)];
        *((_DWORD *)v15 + 22) = v26;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG2_LOW = 0x%08x", v25, v26);
        v27 = *(const char **)(v14 + 176LL * v6);
        v28 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 10)];
        *((_DWORD *)v15 + 23) = v28;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG2_HIGH = 0x%08x", v27, v28);
        v29 = *(const char **)(v14 + 176LL * v6);
        v30 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 11)];
        *((_DWORD *)v15 + 24) = v30;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG3_LOW = 0x%08x", v29, v30);
        v31 = *(const char **)(v14 + 176LL * v6);
        v32 = *(unsigned int *)&v15[2][*((unsigned __int16 *)v15[1] + 12)];
        *((_DWORD *)v15 + 25) = v32;
        qtiseclib_cb_log(10LL, "%s ERROR: ERRLOG3_HIGH = 0x%08x", v31, v32);
        v4 = 1;
      }
    }
    for ( i = 0; i < *((_DWORD *)v15 + 8); ++i )
    {
      v33 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 8LL);
      if ( v33 != 0xFFFF )
      {
        v34 = *(_DWORD *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v33);
        if ( v34 )
        {
          v35 = *v15;
          *(_DWORD *)&v15[17][16 * i] = v34;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS0_LOW = 0x%08x", v35, i);
          v4 = 1;
        }
      }
      v36 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 10LL);
      if ( v36 != 0xFFFF )
      {
        v37 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v36);
        if ( (_DWORD)v37 )
        {
          v38 = *v15;
          *(_DWORD *)&v15[17][16 * i + 4] = v37;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS0_HIGH = 0x%08x", v38, i, v37);
          v4 = 1;
        }
      }
      v39 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 16LL);
      if ( v39 != 0xFFFF )
      {
        v40 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v39);
        if ( (_DWORD)v40 )
        {
          v41 = *v15;
          *(_DWORD *)&v15[17][16 * i + 8] = v40;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS1_LOW = 0x%08x", v41, i, v40);
          v4 = 1;
        }
      }
      v42 = *(unsigned __int16 *)(*(_QWORD *)&v15[5][8 * i] + 18LL);
      if ( v42 != 0xFFFF )
      {
        v43 = *(unsigned int *)(*(_QWORD *)&v15[6][8 * i] + (unsigned __int16)v42);
        if ( (_DWORD)v43 )
        {
          v44 = *v15;
          *(_DWORD *)&v15[17][16 * i + 12] = v43;
          qtiseclib_cb_log(10LL, "%s ERROR: SBM%d FAULTINSTATUS1_HIGH = 0x%08x", v44, i, v43);
          v4 = 1;
        }
      }
    }
    v9 = 0;
    v10 = 0xFFFF;
    while ( 1 )
    {
      if ( v9 >= *((_DWORD *)v15 + 38) )
      {
        v11 = v15[2];
        if ( v11 )
          *(_DWORD *)&v11[*((unsigned __int16 *)v15[1] + 4)] = 1;
        for ( j = 0; j < *((_DWORD *)v15 + 38); ++j )
        {
          v51 = *(unsigned __int16 *)(*(_QWORD *)&v15[20][8 * j] + 8LL);
          if ( v51 != 0xFFFF )
            *(_DWORD *)(*(_QWORD *)&v15[21][8 * j] + (unsigned __int16)v51) = 1;
        }
        for ( k = 0; k < *((_DWORD *)v15 + 8); ++k )
        {
          v52 = *(unsigned __int16 **)&v15[5][8 * k];
          v53 = v52[4];
          if ( v53 != 0xFFFF )
          {
            v54 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v54 + v52[2]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k) | ~*(_DWORD *)(v54 + (unsigned __int16)v53);
          }
          v55 = v52[5];
          if ( v55 != 0xFFFF )
          {
            v56 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v56 + v52[3]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 4) | ~*(_DWORD *)(v56 + (unsigned __int16)v55);
          }
          v57 = v52[8];
          if ( v57 != 0xFFFF )
          {
            v58 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v58 + v52[6]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 8) | ~*(_DWORD *)(v58 + (unsigned __int16)v57);
          }
          v59 = v52[9];
          if ( v59 != 0xFFFF )
          {
            v60 = *(_QWORD *)&v15[6][8 * k];
            *(_DWORD *)(v60 + v52[7]) &= *(_DWORD *)(*(_QWORD *)(v5 + 24) + 16LL * k + 12) | ~*(_DWORD *)(v60 + (unsigned __int16)v59);
          }
        }
LABEL_16:
        ++v6;
        goto LABEL_17;
      }
      v45 = 8LL * v9;
      v46 = v15[18];
      v47 = *(_QWORD *)&v15[20][v45];
      v48 = *(unsigned __int16 *)(v47 + 4);
      if ( v48 != v10 )
      {
        v49 = *(_DWORD *)(*(_QWORD *)&v15[21][8 * v9] + (unsigned __int16)v48);
        *(_DWORD *)&v46[8 * v9] = v49;
        if ( (v49 & 2) == 0 )
          goto LABEL_43;
        v4 = 1;
      }
      v50 = *(unsigned __int16 *)(v47 + 6);
      if ( v50 != v10 )
        *(_DWORD *)&v46[8 * v9 + 4] = *(_DWORD *)(*(_QWORD *)&v15[21][8 * v9] + (unsigned __int16)v50);
      v63 = v10;
      v64 = v4;
      qtiseclib_cb_log(10LL, "%s ERROR: NOC_POS%d ERRLOG_LOW = 0x%08x", *v15, v9, *(unsigned int *)&v46[8 * v9]);
      qtiseclib_cb_log(10LL, "%s ERROR: NOC_POS%d ERRLOG_HIGH = 0x%08x", *v15, v9, *(unsigned int *)&v15[18][v45 + 4]);
      v10 = v63;
      v4 = v64;
LABEL_43:
      ++v9;
    }
  }
  if ( v4 )
  {
    if ( (unsigned __int8)dbg_is_sdi_enable() )
    {
      if ( *(_BYTE *)(v5 + 9) )
      {
        qtiseclib_cb_log(10LL, "NOC error fatal");
        dbg_err_fatal(3u);
      }
    }
    else if ( *(_BYTE *)(v5 + 9) )
    {
      v61 = qtiseclib_cb_log(10LL, "NOC error fatal");
      qtiseclib_cb_console_flush(v61);
    }
  }
  return a3;
}
// 310B8: using guessed type __int64 NOCERR_propdata;
// 310C0: using guessed type __int64 NOCInfoOEM;
// 310C8: using guessed type __int64 NOCInfo;
// 31998: using guessed type __int64 __fastcall qtiseclib_cb_console_flush(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000A1D0) ----------------------------------------------------
__int64 NOC_Error_Init()
{
  __int64 result; // x0
  __int64 v1; // x2
  unsigned int i; // w1
  __int64 v3; // x3
  unsigned int j; // w19
  __int64 v5; // x26
  __int64 v6; // x1
  unsigned int v7; // w2
  __int64 v8; // x0
  __int64 v9; // x7
  int v10; // w3
  int v11; // w3
  unsigned int k; // w2
  __int64 v13; // x3

  result = (__int64)NOC_Error_Platform_Get_Propdata();
  NOCERR_propdata = result;
  if ( result )
  {
    result = (__int64)NOC_Error_Platform_Get_Propdata_OEM();
    if ( result )
    {
      v1 = NOCERR_propdata;
      NOCInfo = *(_QWORD *)(NOCERR_propdata + 16);
      if ( NOCInfo )
      {
        NOCInfoOEM = *(_QWORD *)(result + 16);
        if ( NOCInfoOEM )
        {
          for ( i = 0; i < *(_DWORD *)(v1 + 24); ++i )
          {
            v3 = i;
            **(_DWORD **)(*(_QWORD *)(v1 + 32) + 8 * v3) = *(_DWORD *)(*(_QWORD *)(result + 24) + 4 * v3);
          }
          for ( j = 0; ; ++j )
          {
            result = *(unsigned int *)(NOCERR_propdata + 12);
            if ( j >= (unsigned int)result )
              break;
            v5 = 176LL * j;
            if ( (unsigned int)int_svc_register_isr(
                                 *(_QWORD *)(NOCInfo + v5 + 24),
                                 (__int64)"NOCERR",
                                 7uLL,
                                 (__int64)NOC_Error_Handle_Interrupt,
                                 *(_QWORD *)(NOCInfo + v5 + 24)) )
              qtisec_assert(
                "noship_src/drivers/systemdrivers/icb/src/common/NOC_error.c",
                0x1A8u,
                "0 == int_svc_register_isr(NOCInfo[i].intr_vector, \"NOCERR\",sizeof(\"NOCERR\"), NOC_Error_Handle_Interr"
                "upt, ((void*)((uint64_t)(NOCInfo[i].intr_vector))))");
            v6 = NOCInfoOEM + 48LL * j;
            if ( *(_BYTE *)(v6 + 8) )
            {
              v7 = 0;
              v8 = NOCInfo + v5;
              while ( v7 < *(_DWORD *)(v8 + 32) )
              {
                v9 = *(_QWORD *)(*(_QWORD *)(v8 + 40) + 8LL * v7);
                v10 = *(unsigned __int16 *)(v9 + 4);
                if ( v10 != 0xFFFF )
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8LL * v7) + (unsigned __int16)v10) = *(_DWORD *)(*(_QWORD *)(v6 + 16) + 16LL * v7);
                v11 = *(unsigned __int16 *)(v9 + 6);
                if ( v11 != 0xFFFF )
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8LL * v7) + (unsigned __int16)v11) = *(_DWORD *)(*(_QWORD *)(v6 + 16) + 16LL * v7 + 4);
                ++v7;
              }
              for ( k = 0; k < *(_DWORD *)(v8 + 56); ++k )
              {
                v13 = k;
                **(_DWORD **)(*(_QWORD *)(v8 + 64) + 8 * v13) = *(_DWORD *)(*(_QWORD *)(v6 + 32) + 4 * v13);
              }
              *(_DWORD *)(*(_QWORD *)(v8 + 16) + *(unsigned __int16 *)(*(_QWORD *)(v8 + 8) + 4LL)) = 1;
            }
          }
        }
      }
    }
  }
  return result;
}
// 310B8: using guessed type __int64 NOCERR_propdata;
// 310C0: using guessed type __int64 NOCInfoOEM;
// 310C8: using guessed type __int64 NOCInfo;

//----- (000000000000A3BC) ----------------------------------------------------
void *NOC_Error_Platform_Get_Propdata()
{
  return off_1BFF0;
}
// 1BFF0: using guessed type void *off_1BFF0;

//----- (000000000000A3C8) ----------------------------------------------------
void *NOC_Error_Platform_Get_Propdata_OEM()
{
  return off_1C360;
}
// 1C360: using guessed type void *off_1C360;

//----- (000000000000A3D4) ----------------------------------------------------
__int64 init_system_configuration()
{
  MEMORY[0x180800F4] = 1;
  MEMORY[0x18080118] = 1;
  MEMORY[0x18080158] = 1;
  MEMORY[0x18080188] = 1;
  MEMORY[0x18100000] = 3;
  MEMORY[0x1810000C] = MEMORY[0x1810000C] & 0xFFFFFFE0 | 0x14;
  MEMORY[0x18100040] = 50528384;
  MEMORY[0x18100044] = 196608;
  MEMORY[0x18101000] = 3;
  MEMORY[0x1810100C] = MEMORY[0x1810100C] & 0xFFFFFFE0 | 0x14;
  MEMORY[0x18101040] = 50528384;
  MEMORY[0x18101044] = 196608;
  MEMORY[0x180800F8] = *(_DWORD *)((char *)&loc_28 + (_QWORD)off_1C6D8);
  MEMORY[0x1808011C] = *(_DWORD *)((char *)&loc_28 + (_QWORD)off_1C700);
  MEMORY[0x1808015C] = *(_DWORD *)((char *)&loc_28 + (_QWORD)off_1C728);
  MEMORY[0x1808018C] = *(_DWORD *)((char *)&loc_28 + (_QWORD)off_1C750);
  return 0LL;
}
// 1C6D8: using guessed type void *off_1C6D8;
// 1C700: using guessed type void *off_1C700;
// 1C728: using guessed type void *off_1C728;
// 1C750: using guessed type void *off_1C750;

//----- (000000000000A4C0) ----------------------------------------------------
void *pcu_sequencer_target_init()
{
  void *result; // x0

  result = &unk_31000;
  *(_QWORD *)hmss_pcu_memory_base = 403439616LL;
  return result;
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000A4D0) ----------------------------------------------------
__int64 get_max_cmd_size()
{
  return 504LL;
}

//----- (000000000000A4D8) ----------------------------------------------------
__int64 __fastcall pcu_config_seq_ctl(__int64 result, int a2, int a3, int a4)
{
  if ( (a2 & 0x80000000) != 0 )
    *(_DWORD *)(result + 36) = 0;
  else
    *(_DWORD *)(result + 36) = ((a2 & 0xF) << 8) | a4 | (a3 << 16);
  return result;
}

//----- (000000000000A4F8) ----------------------------------------------------
_DWORD *__fastcall pcu_write_cmds(unsigned __int8 a1, int a2)
{
  _DWORD *result; // x0

  result = (_DWORD *)(4LL * ((a1 + 100859904) & 0xFFFFFFF));
  *result = a2;
  return result;
}

//----- (000000000000A50C) ----------------------------------------------------
__int64 __fastcall pcu_node_init(__int64 a1)
{
  void (*v1)(void); // x0

  v1 = *(void (**)(void))(a1 + 16);
  if ( v1 )
    v1();
  return 0LL;
}

//----- (000000000000A534) ----------------------------------------------------
__int64 __fastcall pcu_get_node(int a1, _QWORD *a2)
{
  if ( (unsigned __int64)a1 >= 0xD )
    return 1LL;
  *a2 = &(&target_pcu_node)[5 * a1];
  return 0LL;
}
// 1C580: using guessed type char *target_pcu_node;

//----- (000000000000A56C) ----------------------------------------------------
__int64 __fastcall pcu_config_low_power_mode(__int64 *a1, int a2)
{
  __int64 v2; // x3
  __int64 i; // x2

  v2 = a1[4];
  for ( i = 0LL; v2 != i && *(_DWORD *)(a1[3] + 48 * i) != a2; ++i )
    ;
  if ( a2 >= 0 && v2 == i )
    return 5LL;
  pcu_config_seq_ctl(
    a1[1],
    *(unsigned __int8 *)(a1[3] + 48 * i + 28),
    *(_DWORD *)(a1[3] + 48 * i + 40),
    *(unsigned __int8 *)(a1[3] + 48 * i + 29));
  return 0LL;
}

//----- (000000000000A5F4) ----------------------------------------------------
__int64 __fastcall pcu_write_seq_memory(__int64 a1, int a2)
{
  __int64 v4; // x23
  int max_cmd_size; // w0
  __int64 v6; // x20
  __int64 v7; // x5
  __int64 v8; // x19
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x21
  __int64 v11; // x4
  unsigned __int64 v12; // x2
  int v13; // w0
  int v14; // w1
  __int64 v16; // [xsp+68h] [xbp+68h]

  v4 = *(_QWORD *)(a1 + 32);
  max_cmd_size = get_max_cmd_size();
  v6 = 0LL;
  v7 = 48LL;
  ::max_cmd_size = max_cmd_size;
  while ( 1 )
  {
    if ( v6 == v4 )
      return 0LL;
    v8 = *(_QWORD *)(a1 + 24) + v6 * v7;
    if ( !*(_BYTE *)(v8 + 44) )
      break;
LABEL_18:
    ++v6;
  }
  if ( *(_DWORD *)(v8 + 24) )
  {
    if ( !(_DWORD)v6 )
      return 1LL;
    *(_DWORD *)(v8 + 40) = *(_DWORD *)(v8 - 8);
    goto LABEL_16;
  }
  if ( !*(_QWORD *)(v8 + 8) )
    goto LABEL_18;
  v9 = *(_QWORD *)(v8 + 16);
  if ( v9 + (unsigned int)cmd_word_count_1139 < ::max_cmd_size )
  {
    v10 = 0LL;
    *(_DWORD *)(v8 + 40) = cmd_word_count_1139;
    while ( v9 > v10 )
    {
      v11 = *(_QWORD *)(v8 + 8);
      v12 = v10 + 1;
      v13 = 8;
      v14 = *(unsigned __int8 *)(v11 + v10);
      do
      {
        if ( v12 < v9 )
          v14 |= *(unsigned __int8 *)(v11 + v12) << v13;
        v13 += 8;
        ++v12;
      }
      while ( v13 != 32 );
      v10 += 4LL;
      v16 = v7;
      pcu_write_cmds((unsigned int)cmd_word_count_1139 >> 2, v14);
      v7 = v16;
      cmd_word_count_1139 += 4;
    }
LABEL_16:
    if ( a2 )
      *(_BYTE *)(v8 + 44) = 1;
    goto LABEL_18;
  }
  return 3LL;
}
// 310D0: using guessed type int cmd_word_count_1139;
// 318B0: using guessed type int max_cmd_size;

//----- (000000000000A73C) ----------------------------------------------------
__int64 pcu_seq_memory_init()
{
  unsigned __int64 v0; // x19
  char **v1; // x0
  __int64 result; // x0

  v0 = 0LL;
  while ( v0 < 0xD )
  {
    v1 = &(&target_pcu_node)[5 * v0++];
    result = pcu_write_seq_memory((__int64)v1, 1);
    if ( (_DWORD)result )
      return result;
  }
  return 0LL;
}
// 1C580: using guessed type char *target_pcu_node;

//----- (000000000000A798) ----------------------------------------------------
__int64 pcu_init()
{
  pcu_sequencer_target_init();
  return pcu_seq_memory_init();
}

//----- (000000000000A7AC) ----------------------------------------------------
__int64 __fastcall int_findEntry(int a1)
{
  __int64 result; // x0
  int *v3; // x1
  int v4; // t1

  result = 0LL;
  v3 = (int *)(g_pdcInterrupts[0] + 8);
  while ( (_DWORD)result != LODWORD(g_pdcInterrupts[1]) )
  {
    v4 = *v3;
    v3 += 3;
    if ( v4 == a1 )
      break;
    result = (unsigned int)(result + 1);
  }
  return result;
}
// 318B8: using guessed type __int64 g_pdcInterrupts[2];

//----- (000000000000A7E8) ----------------------------------------------------
unsigned __int16 *__fastcall gpio_findEntry(int a1, _DWORD *a2)
{
  unsigned __int16 *v3; // x3
  int i; // w2
  unsigned __int16 *result; // x0

  v3 = (unsigned __int16 *)g_pdcGpios[0];
  for ( i = 0; ; ++i )
  {
    if ( i == LODWORD(g_pdcGpios[2]) )
      return 0LL;
    result = v3;
    v3 += 2;
    if ( *result == a1 )
      break;
  }
  if ( a2 )
    *a2 = i;
  return result;
}
// 31890: using guessed type _QWORD g_pdcGpios[3];

//----- (000000000000A838) ----------------------------------------------------
__int64 __fastcall pdcInt_config(int a1, __int64 a2)
{
  unsigned int Entry; // w0
  _DWORD *v3; // x5
  _DWORD *v4; // x3

  if ( !a2 )
    return 19LL;
  Entry = int_findEntry(a1);
  if ( Entry >= LODWORD(g_pdcInterrupts[1]) )
    return 18LL;
  v4 = (_DWORD *)(g_pdcInterrupts[0] + 12LL * Entry);
  *v4 = *v3;
  v4[1] = v3[1];
  return pdcHAL_setTriggerConfig(Entry, 0, v3);
}
// A868: variable 'v3' is possibly undefined
// 318B8: using guessed type __int64 g_pdcInterrupts[2];

//----- (000000000000A8AC) ----------------------------------------------------
__int64 __fastcall pdcInt_enable(int a1)
{
  unsigned int Entry; // w0

  Entry = int_findEntry(a1);
  if ( Entry >= hmss_pcu_memory_base[0] )
    return 18LL;
  else
    return pdcHAL_enable(Entry, 0);
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000A8E0) ----------------------------------------------------
__int64 __fastcall pdcInt_disable(int a1)
{
  unsigned int Entry; // w0

  Entry = int_findEntry(a1);
  if ( Entry >= hmss_pcu_memory_base[0] )
    return 18LL;
  else
    return pdcHAL_disable(Entry, 0);
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000A914) ----------------------------------------------------
__int64 __fastcall pdcGpio_unconfig(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  unsigned __int16 *v3; // x19
  __int64 result; // x0
  __int64 v5; // x1

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  v3 = Entry;
  result = 19LL;
  if ( v2 != 0xFFFF )
  {
    result = pdcHAL_disable(v2, 1);
    if ( !(_DWORD)result )
    {
      v5 = lmh_hsr_version[0] + 24LL * v3[1];
      *(_QWORD *)(v5 + 8) = 0LL;
      *(_DWORD *)(v5 + 4) = -1;
      v3[1] = -1;
    }
  }
  return result;
}
// 31898: using guessed type __int64 lmh_hsr_version[1];

//----- (000000000000A98C) ----------------------------------------------------
__int64 __fastcall pdcGpio_config(int a1, _DWORD *a2, _DWORD *a3)
{
  unsigned __int16 *Entry; // x20
  __int64 result; // x0
  unsigned int v7; // w0
  __int64 v8; // x0
  int v9; // w1
  __int64 v10; // x2
  __int64 v11; // x1
  unsigned int v12; // [xsp+3Ch] [xbp+3Ch] BYREF

  if ( !a2 )
    return 19LL;
  if ( !a3 )
    qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0xECu, "((void *) 0) != (subsystemInterrupt)");
  Entry = gpio_findEntry(a1, &v12);
  result = 18LL;
  if ( Entry )
  {
    v7 = Entry[1];
    if ( v7 == 0xFFFF )
    {
      v9 = 0;
      v10 = g_pdcGpios[1];
      while ( v9 != HIDWORD(g_pdcGpios[2]) )
      {
        v8 = v10;
        v10 += 24LL;
        if ( !*(_QWORD *)(v10 - 16) )
        {
          Entry[1] = v9;
          *(_QWORD *)(v8 + 8) = Entry;
          goto LABEL_16;
        }
        ++v9;
      }
      return 20LL;
    }
    else
    {
      if ( v7 >= g_cmd_set[1] )
        qtisec_assert(
          "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
          0x116u,
          "gpioInput->mux_idx_num < g_pdcGpios.numMux");
      v8 = g_pdcGpios[1] + 24LL * Entry[1];
LABEL_16:
      *(_DWORD *)v8 = *a2;
      *(_DWORD *)(v8 + 4) = a2[1];
      v11 = v12;
      *a3 = *(_DWORD *)(v8 + 16);
      return pdcHAL_setGPIOConfig(Entry[1], v11, a2);
    }
  }
  return result;
}
// 31890: using guessed type _QWORD g_pdcGpios[3];
// 318A0: using guessed type int g_cmd_set[51];

//----- (000000000000AAB8) ----------------------------------------------------
__int64 __fastcall pdcGpio_enable(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  __int64 result; // x0

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  result = 19LL;
  if ( v2 != 0xFFFF )
    return pdcHAL_enable(v2, 1);
  return result;
}

//----- (000000000000AAFC) ----------------------------------------------------
__int64 __fastcall pdcGpio_disable(int a1)
{
  unsigned __int16 *Entry; // x0
  unsigned int v2; // w2
  __int64 result; // x0

  Entry = gpio_findEntry(a1, 0LL);
  if ( !Entry )
    return 18LL;
  v2 = Entry[1];
  result = 19LL;
  if ( v2 != 0xFFFF )
    return pdcHAL_disable(v2, 1);
  return result;
}

//----- (000000000000AB40) ----------------------------------------------------
__int64 pdc_initialize()
{
  __int64 result; // x0

  if ( (unsigned int)pdcMap_getInterruptTable((__int64)g_pdcInterrupts) )
    qtisec_assert(
      "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
      0x171u,
      "PDC_SUCCESS == pdcMap_getInterruptTable(&g_pdcInterrupts)");
  result = pdcMap_getGpioTable((__int64)g_pdcGpios);
  if ( (_DWORD)result )
    qtisec_assert(
      "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
      0x173u,
      "PDC_SUCCESS == pdcMap_getGpioTable(&g_pdcGpios)");
  return result;
}
// 31890: using guessed type _QWORD g_pdcGpios[3];
// 318B8: using guessed type __int64 g_pdcInterrupts[2];

//----- (000000000000ABA4) ----------------------------------------------------
unsigned __int64 __fastcall pdc_getTriggerConfig(int a1, unsigned int a2)
{
  __int64 v3; // x0
  unsigned int v4; // w1

  if ( a1 )
  {
    if ( !g_pdcGpios[1] )
      qtisec_assert(
        "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
        0x185u,
        "((void *) 0) != (g_pdcGpios.map.mux_map)");
    if ( a2 >= g_cmd_set[1] )
      qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0x186u, "index < g_pdcGpios.numMux");
    v4 = 24;
    v3 = g_pdcGpios[1];
  }
  else
  {
    if ( !g_pdcInterrupts[0] )
      qtisec_assert(
        "noship_src/drivers/pdc/interrupt/common/pdc_driver.c",
        0x180u,
        "((void *) 0) != (g_pdcInterrupts.map)");
    if ( hmss_pcu_memory_base[0] <= a2 )
      qtisec_assert("noship_src/drivers/pdc/interrupt/common/pdc_driver.c", 0x181u, "index < g_pdcInterrupts.numInt");
    v3 = g_pdcInterrupts[0];
    v4 = 12;
  }
  return v3 + a2 * (unsigned __int64)v4;
}
// 31890: using guessed type _QWORD g_pdcGpios[3];
// 318A0: using guessed type int g_cmd_set[51];
// 318B8: using guessed type __int64 g_pdcInterrupts[2];
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000AC7C) ----------------------------------------------------
__int64 __fastcall HALInternal_setInterruptState(unsigned int a1, int a2, unsigned __int8 a3)
{
  unsigned int v4; // w20
  int v5; // w19
  unsigned __int64 TriggerConfig; // x0
  int v7; // w1
  __int64 result; // x0
  unsigned __int64 v9; // x3

  v4 = a1;
  v5 = a3;
  TriggerConfig = pdc_getTriggerConfig(a2, a1);
  if ( a2 )
    v4 += hmss_pcu_memory_base[0];
  v7 = *(_DWORD *)(TriggerConfig + 4);
  result = 19LL;
  if ( v7 != -1 )
  {
    v9 = (v7 << 16) + 186646544 + 4 * (v4 >> 5);
    result = 0LL;
    *(_DWORD *)v9 ^= (1 << v4) & (v5 ^ *(_DWORD *)v9);
  }
  return result;
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000AD08) ----------------------------------------------------
__int64 __fastcall pdcHAL_enable(unsigned int a1, int a2)
{
  return HALInternal_setInterruptState(a1, a2, 1u);
}

//----- (000000000000AD10) ----------------------------------------------------
__int64 __fastcall pdcHAL_disable(unsigned int a1, int a2)
{
  return HALInternal_setInterruptState(a1, a2, 0);
}

//----- (000000000000AD18) ----------------------------------------------------
__int64 __fastcall pdcHAL_setTriggerConfig(int a1, int a2, _DWORD *a3)
{
  int v3; // w4

  if ( a2 )
    a1 += hmss_pcu_memory_base[0];
  v3 = a3[1];
  *(_DWORD *)(unsigned int)((v3 << 16) + 186646800 + 4 * a1) = *a3 & 7;
  *(_DWORD *)(unsigned int)(4 * a1 + 186664448) = v3 & 7;
  return 0LL;
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000AD70) ----------------------------------------------------
__int64 __fastcall pdcHAL_setGPIOConfig(int a1, __int64 a2, _DWORD *a3)
{
  return pdcHAL_setTriggerConfig(a1, 1, a3);
}

//----- (000000000000AD78) ----------------------------------------------------
int *__fastcall pdcHAL_setOwner(int a1, int a2, char a3)
{
  int *result; // x0

  if ( a2 )
    a1 += hmss_pcu_memory_base[0];
  result = (int *)(4LL * ((a1 + 46666112) & 0x3FFFFFFF));
  *result = a3 & 7;
  return result;
}
// 318C0: using guessed type int hmss_pcu_memory_base[2];

//----- (000000000000ADA8) ----------------------------------------------------
int *pdcOS_initialize()
{
  pdcTarget_preInit();
  pdc_initialize();
  return pdcTarget_postInit();
}

//----- (000000000000ADC0) ----------------------------------------------------
__int64 __fastcall pdc_seq_handle_env_init(_QWORD *a1)
{
  unsigned int v1; // w3
  __int64 v2; // x2

  if ( !g_pdc_aoss_base )
    g_pdc_aoss_base = 184549376LL;
  if ( !g_pdc_ss_base )
    g_pdc_ss_base = 394264576LL;
  v1 = -2;
  if ( a1 )
  {
    v1 = 0;
    a1[6] = g_pdc_aoss_base + a1[4];
    v2 = a1[5];
    if ( v2 )
      a1[7] = g_pdc_ss_base + v2;
  }
  return v1;
}
// 31120: using guessed type __int64 g_pdc_ss_base;
// 31128: using guessed type __int64 g_pdc_aoss_base;

//----- (000000000000AE20) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_enable(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1280) = *(_DWORD *)(result + 1280) & 0x80000100 | (a2 != 0);
  return result;
}

//----- (000000000000AE48) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_clk_gate_enable(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1280) = *(_DWORD *)(result + 1280) & 0x101 | ((a2 == 0) << 31);
  return result;
}

//----- (000000000000AE6C) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_wakeup_time(__int64 result, __int64 a2)
{
  *(_DWORD *)(result + 64) = a2;
  *(_DWORD *)(result + 56) = HIDWORD(a2) | 0x80000000;
  return result;
}

//----- (000000000000AE80) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_wakeup_time_ex(__int64 a1, __int64 a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_QWORD *)(result + 1296) = a2;
  return result;
}

//----- (000000000000AE94) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_start_addr(__int64 result, unsigned __int16 a2)
{
  *(_DWORD *)(result + 72) = a2 | 0x80000000;
  return result;
}

//----- (000000000000AEA4) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_start_addr_ex(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1312) = a2;
  return result;
}

//----- (000000000000AEB8) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_enable_arc_timer(__int64 a1, char a2)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1304) = a2 == 0;
  return result;
}

//----- (000000000000AECC) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_pwr_ctl_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1328) = a2;
  *(_DWORD *)(result + 1332) = a3;
  return result;
}

//----- (000000000000AEDC) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_wait_event_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1344) = a2;
  *(_DWORD *)(result + 1348) = a3;
  return result;
}

//----- (000000000000AEEC) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_br_event_override(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  result = a1 + 0x4000;
  *(_DWORD *)(result + 1360) = a2;
  *(_DWORD *)(result + 1364) = a3;
  return result;
}

//----- (000000000000AEFC) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_br_addr(__int64 a1, unsigned __int16 a2, unsigned __int8 a3)
{
  if ( a2 > 3u )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 4LL * a2 + 17760) = a3;
  return 0LL;
}

//----- (000000000000AF28) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_cfg_delay(__int64 a1, unsigned __int16 a2, int a3)
{
  if ( a2 > 0xFu )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 4LL * a2 + 17824) = a3;
  return 0LL;
}

//----- (000000000000AF50) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_profile_ts_count(__int64 a1)
{
  return (unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12;
}

//----- (000000000000AF5C) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_enable_profile_ts(__int64 a1, unsigned __int8 a2, char a3)
{
  if ( a2 >= (unsigned int)((unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12) )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 20LL * a2 + 20480) = a3 != 0;
  return 0LL;
}

//----- (000000000000AF9C) ----------------------------------------------------
unsigned __int64 __fastcall pdc_seq_hal_profile_ts(__int64 a1, unsigned __int8 a2)
{
  if ( a2 >= (unsigned int)((unsigned __int16)*(_DWORD *)(a1 + 4100) >> 12) )
    return 0LL;
  else
    return ((unsigned __int64)(*(_DWORD *)(a1 + 20LL * a2 + 4616) & 0xFFFFFF) << 32) | *(unsigned int *)(a1 + 20LL * a2 + 4612);
}

//----- (000000000000AFE4) ----------------------------------------------------
__int64 __fastcall pdc_seq_hal_copy_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w5
  unsigned int v5; // w4
  __int64 v6; // x8
  int v7; // w6
  int v8; // w10
  int v9; // w11
  char v10; // w7
  __int64 v11; // x5
  int v12; // w7
  int v13; // w9
  int v14; // w5
  __int64 v15; // x1

  a4 = (unsigned __int16)a4;
  v4 = 4 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 4104));
  if ( v4 <= a2 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v4 < v5 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)(unsigned __int16)v6 )
    {
      v9 = ((_BYTE)a2 + (_BYTE)v6) & 3;
      v10 = 16;
      if ( v9 != 2 )
      {
        v10 = 24;
        if ( v9 != 3 )
        {
          v10 = 8;
          if ( v9 != 1 )
          {
            v10 = 0;
            if ( (_WORD)v6 )
            {
              v11 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 4) + 0x200000LL;
              v12 = *(_DWORD *)(a1 + v11);
              v13 = v7 ^ v12;
              v7 = 0;
              *(_DWORD *)(a1 + v11) = v13 & v8 ^ v12;
              v10 = 0;
            }
          }
        }
      }
      v8 |= 255 << v10;
      v14 = *(unsigned __int8 *)(a3 + v6++);
      v7 |= v14 << v10;
    }
    v15 = 4 * (((unsigned __int16)v5 - 1) / 4) + 0x200000LL;
    *(_DWORD *)(a1 + v15) ^= (v7 ^ *(_DWORD *)(a1 + v15)) & v8;
  }
  return a4;
}

//----- (000000000000B0F0) ----------------------------------------------------
__int64 __fastcall pdc_seq_count(unsigned __int8 a1)
{
  int v1; // w3
  unsigned __int8 *v2; // x1
  __int64 result; // x0
  int v4; // t1

  v1 = a1;
  v2 = (unsigned __int8 *)g_pdc_seqs;
  result = 0LL;
  while ( v2 != (unsigned __int8 *)(g_pdc_seqs + 120LL * (unsigned int)g_pdc_seq_count) )
  {
    v4 = *v2;
    v2 += 120;
    if ( v4 == v1 )
      result = (unsigned int)(result + 1);
    else
      result = (unsigned int)result;
  }
  return result;
}
// 31130: using guessed type __int64 g_pdc_seqs;
// 31138: using guessed type int g_pdc_seq_count;

//----- (000000000000B12C) ----------------------------------------------------
__int64 __fastcall pdc_seq_handles(unsigned __int8 a1, unsigned int a2, __int64 a3)
{
  int v3; // w5
  bool v4; // zf
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 result; // x0

  v3 = a1;
  if ( a2 )
    v4 = a3 == 0;
  else
    v4 = 1;
  if ( v4 || a1 > 1u )
    return 0LL;
  v6 = 0LL;
  v7 = 120LL * (unsigned int)g_pdc_seq_count;
  result = 0LL;
  while ( v6 != v7 )
  {
    if ( *(unsigned __int8 *)(g_pdc_seqs + v6) == v3 )
    {
      if ( (unsigned int)result >= a2 )
        return result;
      *(_QWORD *)(a3 + 8LL * (unsigned int)result) = g_pdc_seqs + v6;
      result = (unsigned int)(result + 1);
    }
    v6 += 120LL;
  }
  return result;
}
// 31130: using guessed type __int64 g_pdc_seqs;
// 31138: using guessed type int g_pdc_seq_count;

//----- (000000000000B19C) ----------------------------------------------------
__int64 __fastcall pdc_seq_handle_internal_cfg(__int64 a1)
{
  __int64 v1; // x21
  unsigned int i; // w19
  unsigned int j; // w19

  v1 = *(_QWORD *)(a1 + 8);
  for ( i = 0; i < *(_DWORD *)(v1 + 8); ++i )
  {
    if ( (unsigned int)pdc_seq_hal_cfg_br_addr(*(_QWORD *)(a1 + 48), i, *(_BYTE *)(*(_QWORD *)v1 + i)) )
      return 4294967294LL;
  }
  for ( j = 0; j < *(_DWORD *)(v1 + 24); ++j )
  {
    if ( (unsigned int)pdc_seq_hal_cfg_delay(*(_QWORD *)(a1 + 48), j, *(_DWORD *)(*(_QWORD *)(v1 + 16) + 4LL * j)) )
      return 4294967294LL;
  }
  if ( (unsigned int)pdc_seq_hal_profile_ts_count(*(_QWORD *)(a1 + 48)) != 5 )
    return 4294967294LL;
  return 0LL;
}

//----- (000000000000B240) ----------------------------------------------------
__int64 __fastcall pdc_seq_copy_cmd_seq(__int64 a1)
{
  unsigned int v2; // w20
  __int64 v3; // x1
  __int64 v4; // x21
  __int64 v5; // x4
  int i; // w2
  __int64 v7; // x5
  __int16 v8; // w0
  __int16 v9; // w1

  v2 = 0;
LABEL_2:
  if ( (unsigned __int64)v2 >= *(_QWORD *)(a1 + 24) )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = v3 + 32LL * v2;
  if ( !*(_WORD *)(v4 + 8) )
    return 4294967294LL;
  v5 = *(_QWORD *)(a1 + 16);
  for ( i = 0; v2 != i; ++i )
  {
    v7 = v5;
    v5 += 32LL;
    if ( *(_QWORD *)v7 == *(_QWORD *)v4 )
    {
      *(_WORD *)(v4 + 24) = *(_WORD *)(v7 + 24);
LABEL_11:
      ++v2;
      goto LABEL_2;
    }
  }
  v8 = pdc_seq_hal_copy_cmd_seq(
         *(_QWORD *)(a1 + 48),
         *(_WORD *)(a1 + 112),
         *(_QWORD *)(v3 + 32LL * v2),
         *(unsigned __int16 *)(v3 + 32LL * v2 + 8));
  if ( v8 )
  {
    v9 = *(_WORD *)(a1 + 112);
    *(_WORD *)(v4 + 24) = v9;
    *(_WORD *)(a1 + 112) = v8 + v9;
    goto LABEL_11;
  }
  return 4294967292LL;
}

//----- (000000000000B30C) ----------------------------------------------------
__int64 __fastcall pdc_seq_mode_index(__int64 a1, unsigned __int16 a2)
{
  unsigned int i; // w2

  for ( i = 0; (unsigned __int64)i < *(_QWORD *)(a1 + 24); ++i )
  {
    if ( *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 32LL * i + 10) == a2 )
      return i;
  }
  return 4294967293LL;
}

//----- (000000000000B350) ----------------------------------------------------
__int64 __fastcall pdc_seq_handle_init(_QWORD *a1)
{
  __int64 result; // x0

  if ( !a1 || !a1[1] || !a1[2] || !a1[4] )
    return 0xFFFFFFFFLL;
  result = pdc_seq_handle_env_init(a1);
  if ( !(_DWORD)result )
  {
    result = pdc_seq_handle_target_init((__int64)a1);
    if ( !(_DWORD)result )
    {
      result = pdc_seq_handle_internal_cfg((__int64)a1);
      if ( !(_DWORD)result )
        return pdc_seq_copy_cmd_seq((__int64)a1);
    }
  }
  return result;
}

//----- (000000000000B3C0) ----------------------------------------------------
__int64 __fastcall pdc_seq_enable(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 48);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    pdc_seq_hal_enable(v2, a2 != 0);
    return 0LL;
  }
  return result;
}

//----- (000000000000B404) ----------------------------------------------------
__int64 __fastcall pdc_seq_set_wakeup_time(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v4; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 48) )
  {
    v4 = *(_QWORD *)(a1 + 56);
    if ( v4 )
      pdc_seq_hal_cfg_wakeup_time(v4, a2);
    else
      pdc_seq_hal_cfg_wakeup_time_ex(*(_QWORD *)(a1 + 48), a2);
    return 0LL;
  }
  return result;
}

//----- (000000000000B450) ----------------------------------------------------
__int64 __fastcall pdc_seq_set_lpm(_QWORD *a1, unsigned __int16 a2)
{
  unsigned int v2; // w2
  signed int v4; // w0
  __int64 v5; // x1
  __int64 v6; // x0
  __int16 v7; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = -1;
  if ( a1[6] )
  {
    v4 = pdc_seq_mode_index((__int64)a1, a2);
    v2 = v4;
    if ( v4 != -3 )
    {
      v5 = a1[2] + 32LL * v4;
      v6 = a1[7];
      v7 = *(_WORD *)(v5 + 24);
      if ( v6 )
        pdc_seq_hal_cfg_start_addr(v6, v7);
      else
        pdc_seq_hal_cfg_start_addr_ex(a1[6], v7);
      return 0;
    }
  }
  return v2;
}

//----- (000000000000B4D0) ----------------------------------------------------
__int64 __fastcall pdc_seq_profile_ts_count(__int64 a1)
{
  __int64 v1; // x0

  if ( a1 && (v1 = *(_QWORD *)(a1 + 48)) != 0 )
    return pdc_seq_hal_profile_ts_count(v1);
  else
    return 0LL;
}

//----- (000000000000B4E8) ----------------------------------------------------
__int64 __fastcall pdc_seq_enable_profile_ts(__int64 a1, unsigned __int8 a2)
{
  int v2; // w22
  unsigned int v3; // w1
  int v5; // w21
  int i; // w20
  unsigned __int8 v7; // w1

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  if ( *(_QWORD *)(a1 + 48) )
  {
    v5 = pdc_seq_profile_ts_count(a1);
    for ( i = 0; i != v5; ++i )
    {
      v7 = i;
      pdc_seq_hal_enable_profile_ts(*(_QWORD *)(a1 + 48), v7, v2 != 0);
    }
    return 0;
  }
  return v3;
}

//----- (000000000000B568) ----------------------------------------------------
__int64 __fastcall pdc_seq_profile_ts(__int64 a1)
{
  unsigned __int64 *v1; // x22
  __int64 v3; // x20
  int v4; // w23
  int i; // w21
  unsigned __int8 v6; // w1

  if ( !a1 || !*(_QWORD *)(a1 + 48) )
    return 0LL;
  v1 = (unsigned __int64 *)(a1 + 64);
  v3 = a1 + 64;
  v4 = pdc_seq_profile_ts_count(a1);
  for ( i = 0; i != v4; ++i )
  {
    v6 = i;
    *v1++ = pdc_seq_hal_profile_ts(*(_QWORD *)(a1 + 48), v6);
  }
  return v3;
}

//----- (000000000000B5E8) ----------------------------------------------------
__int64 __fastcall pdc_seq_enable_arc_timer(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 48);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    pdc_seq_hal_enable_arc_timer(v2, a2 != 0);
    return 0LL;
  }
  return result;
}

//----- (000000000000B62C) ----------------------------------------------------
__int64 pdc_seq_sys_init()
{
  unsigned int v0; // w19
  __int64 result; // x0
  _QWORD *v2; // x20
  int v3; // w0
  int v4; // w0

  v0 = 0;
  pdc_seq_driver_init();
  while ( 1 )
  {
    result = (unsigned int)g_pdc_seq_count;
    if ( v0 >= g_pdc_seq_count )
      break;
    v2 = (_QWORD *)(g_pdc_seqs + 120LL * v0);
    v3 = pdc_seq_handle_init(v2);
    while ( v3 )
      ;
    v4 = pdc_seq_enable((__int64)v2, 1);
    while ( v4 )
      ;
    ++v0;
  }
  return result;
}
// 31130: using guessed type __int64 g_pdc_seqs;
// 31138: using guessed type int g_pdc_seq_count;

//----- (000000000000B6A4) ----------------------------------------------------
__int64 pdc_seq_test()
{
  int v0; // w19
  __int64 result; // x0
  _QWORD *v2; // [xsp+28h] [xbp+28h] BYREF

  pdc_seq_driver_init();
  pdc_seq_handles(0, 1u, (__int64)&v2);
  v0 = pdc_seq_handle_init(v2);
  pdc_seq_set_lpm(v2, 2u);
  result = pdc_seq_set_wakeup_time((__int64)v2, 0x123456789ABCDLL);
  if ( v0 )
  {
    while ( 1 )
      ;
  }
  return result;
}

//----- (000000000000B708) ----------------------------------------------------
void *pdc_seq_driver_init()
{
  void *result; // x0

  g_pdc_seqs = (__int64)&g_pdc_seq_instances;
  result = &unk_31000;
  g_pdc_seq_count = g_pdc_seq_instance_count;
  return result;
}
// 1CBF8: using guessed type int g_pdc_seq_instance_count;
// 31130: using guessed type __int64 g_pdc_seqs;
// 31138: using guessed type int g_pdc_seq_count;

//----- (000000000000B72C) ----------------------------------------------------
__int64 __fastcall pdc_seq_handle_target_init(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 48) )
    return 0LL;
  return 0xFFFFFFFFLL;
}

//----- (000000000000B748) ----------------------------------------------------
__int64 pdcTarget_preInit()
{
  __int64 result; // x0

  for ( result = 0LL; result != 98; ++result )
  {
    g_pdcGpioMapping[3 * (int)result + 1] = &g_pdcGpioInputs[2 * result];
    g_pdcGpioInputs[2 * (int)result + 1] = result;
  }
  return result;
}
// 1A670: using guessed type _WORD g_pdcGpioInputs[196];
// 1AEB8: using guessed type _QWORD g_pdcGpioMapping[294];

//----- (000000000000B7A8) ----------------------------------------------------
int *pdcTarget_postInit()
{
  unsigned int i; // w19
  int v1; // w2
  int v2; // w0
  int *result; // x0
  unsigned int j; // w19
  int v5; // w2
  int v6; // w0

  for ( i = 0; i < 0x46; ++i )
  {
    v1 = g_pdcInterruptMapping[3 * i + 1];
    v2 = i;
    pdcHAL_setOwner(v2, 0, v1);
  }
  result = (int *)&unk_16000;
  for ( j = 0; j < 0x62; ++j )
  {
    v5 = HIDWORD(g_pdcGpioMapping[3 * (int)j]);
    v6 = j;
    result = pdcHAL_setOwner(v6, 1, v5);
  }
  return result;
}
// 1AB68: using guessed type _DWORD g_pdcInterruptMapping[210];
// 1AEB8: using guessed type _QWORD g_pdcGpioMapping[294];

//----- (000000000000B848) ----------------------------------------------------
__int64 pdcTcs_initialize()
{
  int v0; // w19
  unsigned int v1; // w23
  char *v2; // x21
  char *v3; // x20
  char *v4; // x22
  int v5; // w24
  __int64 result; // x0
  unsigned __int64 v7; // x20
  __int64 i; // x5
  unsigned int v9; // w19
  char *v10; // x4
  int v11; // w1
  int v12; // w0
  int *v13; // x14
  unsigned int v14; // w0
  unsigned __int64 v15; // x2
  char **v16; // x2
  unsigned __int64 v17; // x2
  int v18; // w3
  __int64 v19[2]; // [xsp+40h] [xbp+40h]

  v0 = unk_1CC68;
  v1 = unk_1CC6C;
  v19[0] = 0LL;
  v19[1] = 0LL;
  v2 = (char *)off_1CC58;
  if ( unk_1CC6C > 4u )
    qtisec_assert("noship_src/drivers/pdc/tcs/src/pdcTcs.c", 0x81u, "(TCS_NUM_TOTAL >= TotalnTCS)");
  v3 = off_1CC60 + 8;
  v4 = off_1CC60 + 72;
  v5 = 0;
  do
  {
    result = cmd_db_query_addr(*((_QWORD *)v3 - 1));
    if ( (_DWORD)result )
    {
      result = (unsigned int)(*(_DWORD *)v3 + result);
      *(_DWORD *)v3 = result;
    }
    else
    {
      ++v5;
    }
    v3 += 16;
  }
  while ( v4 != v3 );
  if ( !v5 )
  {
    v7 = (unsigned int)(v0 + 4100);
    if ( (unsigned __int8)*(_DWORD *)v7 >> 5 != 4 )
      qtisec_assert(
        "noship_src/drivers/pdc/tcs/src/pdcTcs.c",
        0x9Bu,
        "4 == (((*((volatile uint32_t *) ((uintptr_t) ((pdc_res.subsytem_addr) + 0X1004 + (0x10000*(0)))))) & (0xe0)) >> 5)");
    if ( ((*(_DWORD *)v7 >> 8) & 0xFu) < v1 )
      qtisec_assert(
        "noship_src/drivers/pdc/tcs/src/pdcTcs.c",
        0x9Cu,
        "TotalnTCS <= (((*((volatile uint32_t *) ((uintptr_t) ((pdc_res.subsytem_addr) + 0X1004 + (0x10000*(0)))))) & (0xf00)) >> 8)");
    for ( i = 0LL; i != v1; ++i )
    {
      v10 = &v2[96 * i];
      v11 = 0;
      v12 = v0 + 200 * (unsigned __int16)i;
      v13 = (int *)(unsigned int)(v12 + 21768);
      v14 = v12 + 21776;
      do
      {
        v15 = *((unsigned int *)v10 + 3);
        if ( (v15 & 0x10) == 0 )
        {
          if ( (v15 & 8) == 0 )
            *((_DWORD *)v19 + i) |= 1 << v11;
          *(_DWORD *)(v14 - 4) = (((v15 >> 1) & 1) << 8) | ((((v15 ^ 4) >> 2) & 1) << 16);
          if ( (v15 & 1) != 0 )
            *v13 = (1 << v11) | *v13 & 0xF;
          v16 = &(&g_pdcResourceList)[2 * (unsigned __int8)*v10];
          *(_QWORD *)v10 = v16;
          *(_DWORD *)v14 = *((_DWORD *)v16 + 2) + *((_DWORD *)v10 + 4);
          *(_DWORD *)(v14 + 4) = *((_DWORD *)v10 + 2);
        }
        ++v11;
        v10 += 24;
        v14 += 16;
      }
      while ( v11 != 4 );
    }
    v9 = v0 + 21764;
    for ( result = 0LL; result != v1; ++result )
    {
      v17 = v9;
      v18 = *((_DWORD *)v19 + result);
      v9 += 200;
      *(_DWORD *)v17 = v18;
    }
  }
  return result;
}
// 1CC58: using guessed type void *;
// 1CC60: using guessed type char *;
// 1DA78: using guessed type char *g_pdcResourceList;

//----- (000000000000BA4C) ----------------------------------------------------
char *__fastcall pdcTcs_getResources(unsigned int a1)
{
  if ( a1 > 3 )
    qtisec_assert("noship_src/drivers/pdc/tcs/src/pdcTcs.c", 0xC1u, "tcsNum < TCS_NUM_TOTAL");
  return (char *)&g_pdcTCSConfig + 96 * a1;
}

//----- (000000000000BA98) ----------------------------------------------------
char **pdcTcs_getAllResourceList()
{
  return &g_pdcResourceList;
}
// 1DA78: using guessed type char *g_pdcResourceList;

//----- (000000000000BAA4) ----------------------------------------------------
__int64 __fastcall pm_app_ps_hold_cfg(unsigned int a1)
{
  __int64 result; // x0
  unsigned int v3; // w21
  unsigned int v4; // w19
  unsigned int i; // w20
  int pmic_model; // w0
  unsigned int v8; // [xsp+3Ch] [xbp+3Ch] BYREF

  v8 = 15;
  if ( a1 > 4 )
    return 2LL;
  result = 4LL;
  if ( a1 - 3 > 1 )
  {
    v3 = a1;
    result = pm_comm_channel_init_internal();
    if ( !(_DWORD)result )
    {
      result = pm_version_detect();
      v4 = result;
      if ( !(_DWORD)result )
      {
        for ( i = 0; i != 7; ++i )
        {
          pmic_model = pm_get_pmic_model(i);
          if ( pmic_model != 0x7FFFFFFF && pmic_model != 0 )
          {
            v4 |= pm_tgt_get_pshold_reset_cfg(i, v3, &v8);
            if ( v4 )
              return v4;
            if ( v8 != 15 )
              v4 = pm_pon_ps_hold_cfg(i, v8);
            v4 |= pm_pon_tgt_specific_pshold_cfg(i, v3);
          }
        }
        return v4;
      }
    }
  }
  return result;
}

//----- (000000000000BB78) ----------------------------------------------------
__int64 pm_comm_channel_init_internal()
{
  int v0; // w0
  unsigned int v1; // w1

  v0 = SpmiBus_Init();
  v1 = 128;
  if ( !v0 )
  {
    spmi_initialized = 1;
    return 0;
  }
  return v1;
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BBA8) ----------------------------------------------------
__int64 __fastcall pm_comm_read_byte(char a1, unsigned __int16 a2, char *a3, unsigned __int8 a4)
{
  int Long; // w0
  unsigned int v5; // w1
  int v7; // [xsp+1Ch] [xbp+1Ch] BYREF

  v7 = 0;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  Long = SpmiBus_ReadLong(a1, a4, a2, a3, 1u, (__int64 *)&v7);
  v5 = 0;
  if ( Long )
    return 128;
  return v5;
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BC04) ----------------------------------------------------
__int64 __fastcall pm_comm_read_byte_mask(char a1, unsigned __int16 a2, char a3, char *a4, unsigned __int8 a5)
{
  __int64 result; // x0

  result = pm_comm_read_byte(a1, a2, a4, a5);
  if ( (_DWORD)result )
    return 128LL;
  *a4 &= a3;
  return result;
}

//----- (000000000000BC48) ----------------------------------------------------
__int64 __fastcall pm_comm_write_byte(char a1, unsigned __int16 a2, char a3, unsigned __int8 a4)
{
  int v4; // w0
  unsigned int v5; // w1
  char v7; // [xsp+1Fh] [xbp+1Fh] BYREF

  v7 = a3;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  v4 = SpmiBus_WriteLong(a1, a4, a2, &v7, 1u);
  v5 = 0;
  if ( v4 )
    return 128;
  return v5;
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BCA0) ----------------------------------------------------
__int64 __fastcall pm_comm_write_byte_mask(char a1, unsigned __int16 a2, char a3, char a4, unsigned __int8 a5)
{
  int v5; // w21
  int v7; // w23
  char v11; // [xsp+4Bh] [xbp+4Bh] BYREF
  int v12; // [xsp+4Ch] [xbp+4Ch] BYREF

  v5 = a2;
  v11 = 0;
  v12 = 1;
  if ( (unsigned __int8)spmi_initialized > (unsigned int)(a2 == 0xFFFF)
    && ((v7 = a5, (unsigned int)SpmiBus_ReadLong(a1, a5, a2, &v11, 1u, (__int64 *)&v12))
     || (v11 = v11 & ~a3 | a3 & a4, !(unsigned int)SpmiBus_WriteLong(a1, v7, v5, &v11, 1u))) )
  {
    return 0LL;
  }
  else
  {
    return 128LL;
  }
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BD5C) ----------------------------------------------------
__int64 __fastcall pm_comm_write_byte_array(
        char a1,
        unsigned __int16 a2,
        unsigned int a3,
        char *a4,
        unsigned __int8 a5)
{
  int v5; // w0
  unsigned int v6; // w1

  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128LL;
  v5 = SpmiBus_WriteLong(a1, a5, a2, a4, a3);
  v6 = 0;
  if ( v5 )
    return 128;
  return v6;
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BDB8) ----------------------------------------------------
__int64 __fastcall pm_comm_read_byte_array(char a1, unsigned __int16 a2, unsigned int a3, char *a4, unsigned __int8 a5)
{
  int Long; // w0
  unsigned int v6; // w1
  int v8; // [xsp+1Ch] [xbp+1Ch] BYREF

  v8 = 0;
  if ( (unsigned __int8)spmi_initialized <= (unsigned int)(a2 == 0xFFFF) )
    return 128;
  Long = SpmiBus_ReadLong(a1, a5, a2, a4, a3, (__int64 *)&v8);
  v6 = 0;
  if ( Long )
    return 128;
  return v6;
}
// 31148: using guessed type char spmi_initialized;

//----- (000000000000BE10) ----------------------------------------------------
__int64 pm_pon_init()
{
  int v0; // w19
  __int64 result; // x0
  __int16 v2; // w1
  char v3; // [xsp+25h] [xbp+25h] BYREF
  char v4; // [xsp+26h] [xbp+26h] BYREF
  char v5; // [xsp+27h] [xbp+27h] BYREF
  __int16 v6; // [xsp+28h] [xbp+28h] BYREF

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v0 = pm_comm_read_byte(0, 0x804u, &v3, 0);
  result = v0 | (unsigned int)pm_comm_read_byte(0, 0x805u, &v4, 0);
  if ( !(_DWORD)result )
  {
    result = 4LL;
    if ( v3 == 1 )
    {
      if ( v4 == 8 )
      {
        pon_ps_hold_reg = 2130;
        word_31152 = 2131;
        word_31154 = 255;
        v2 = 128;
      }
      else
      {
        pon_ps_hold_reg = 2138;
        word_31152 = 2139;
        word_31154 = 128;
        v2 = 15;
      }
      word_31156 = v2;
      result = pm_comm_read_byte(0, 0x801u, &v5, 0);
      if ( !(_DWORD)result )
      {
        if ( !v5 )
          word_31152 = pon_ps_hold_reg;
        if ( v4 == 8
          || (result = pm_comm_read_byte_array(0, 0x80Au, 2u, (char *)&v6, 0), !(_DWORD)result)
          && (!v6 || (result = pm_comm_write_byte_mask(0, 0x88Du, 1, 1, 0), !(_DWORD)result)) )
        {
          pm_pon_initialized = 1;
          return 0LL;
        }
      }
    }
  }
  return result;
}
// 31150: using guessed type __int16 pon_ps_hold_reg;
// 31152: using guessed type __int16 word_31152;
// 31154: using guessed type __int16 word_31154;
// 31156: using guessed type __int16 word_31156;
// 31158: using guessed type char pm_pon_initialized;

//----- (000000000000BF64) ----------------------------------------------------
__int64 __fastcall pm_pon_ps_hold_cfg(unsigned __int8 a1, unsigned int a2)
{
  unsigned int inited; // w1
  int slave_id; // w0
  char v6; // w19
  int v7; // w19
  unsigned int v9; // [xsp+3Ch] [xbp+3Ch] BYREF

  v9 = 0;
  inited = pm_comm_channel_init_internal();
  if ( !inited )
  {
    slave_id = pm_get_slave_id(a1, 0, &v9);
    inited = 2;
    if ( !slave_id )
    {
      inited = 4;
      if ( a2 <= 0xE && (pm_pon_initialized || (inited = pm_pon_init()) == 0) )
      {
        switch ( a2 )
        {
          case 0u:
            v6 = 1;
            goto LABEL_17;
          case 1u:
            v6 = 4;
            goto LABEL_17;
          case 2u:
            v6 = 5;
            goto LABEL_17;
          case 3u:
            v6 = 6;
            goto LABEL_17;
          case 4u:
            v6 = 7;
            goto LABEL_17;
          case 5u:
          case 6u:
            v6 = 8;
            goto LABEL_17;
          case 7u:
            v6 = 9;
            goto LABEL_17;
          case 8u:
            v6 = 2;
            goto LABEL_17;
          case 0xEu:
            v6 = 15;
LABEL_17:
            inited = pm_comm_write_byte(v9, word_31152, 0, 0);
            if ( !inited )
            {
              qtiseclib_cb_udelay(300LL);
              v7 = pm_comm_write_byte(v9, pon_ps_hold_reg, v6, 0);
              inited = v7 | pm_comm_write_byte(v9, word_31152, word_31154, 0);
            }
            break;
          default:
            inited = 4;
            break;
        }
      }
    }
  }
  return inited;
}
// 31150: using guessed type __int16 pon_ps_hold_reg;
// 31152: using guessed type __int16 word_31152;
// 31154: using guessed type __int16 word_31154;
// 31158: using guessed type char pm_pon_initialized;
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (000000000000C0A8) ----------------------------------------------------
__int64 __fastcall pm_pon_get_reset_config_val(int a1, char *a2)
{
  char v2; // w0
  __int64 result; // x0

  switch ( a1 )
  {
    case 0:
      v2 = 1;
      goto LABEL_11;
    case 1:
      v2 = 4;
      goto LABEL_11;
    case 2:
      v2 = 5;
      goto LABEL_11;
    case 3:
      v2 = 6;
      goto LABEL_11;
    case 4:
      v2 = 7;
      goto LABEL_11;
    case 5:
      v2 = 8;
      goto LABEL_11;
    case 7:
      v2 = 9;
      goto LABEL_11;
    case 8:
      v2 = 2;
      goto LABEL_11;
    case 14:
      v2 = 15;
LABEL_11:
      *a2 = v2;
      result = 0LL;
      break;
    default:
      result = 4LL;
      break;
  }
  return result;
}

//----- (000000000000C120) ----------------------------------------------------
__int64 __fastcall pm_pon_gp_reset_cfg(unsigned __int8 a1, int a2, unsigned int a3)
{
  int slave_id; // w0
  void *v7; // x20
  unsigned int reset_config_val; // w19
  char v9; // w2
  char v11; // [xsp+2Ah] [xbp+2Ah] BYREF
  char v12; // [xsp+2Bh] [xbp+2Bh] BYREF
  unsigned int v13; // [xsp+2Ch] [xbp+2Ch] BYREF

  v12 = 0;
  v13 = 0;
  slave_id = pm_get_slave_id(a1, 0, &v13);
  if ( a3 > 0xE || slave_id != 0 )
    return 2;
  if ( a2 == 4 )
  {
    v7 = &pon_gp1_reg;
  }
  else
  {
    if ( a2 != 5 )
      return 2;
    v7 = &pon_gp2_reg;
  }
  reset_config_val = pm_pon_get_reset_config_val(a3, &v12);
  if ( !reset_config_val )
  {
    reset_config_val = pm_comm_read_byte(v13, *((_WORD *)v7 + 5), &v11, 0);
    if ( !reset_config_val )
    {
      v9 = *((_BYTE *)v7 + 12);
      v11 &= v9;
      if ( v11 )
      {
        reset_config_val = pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 5), v9, 0, 0);
        qtiseclib_cb_udelay(300LL);
      }
      reset_config_val |= pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 4), *((_BYTE *)v7 + 14), v12, 0);
      if ( v11 )
        reset_config_val |= pm_comm_write_byte_mask(v13, *((_WORD *)v7 + 5), *((_BYTE *)v7 + 12), -1, 0);
    }
  }
  return reset_config_val;
}
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (000000000000C234) ----------------------------------------------------
__int64 __fastcall pm_tgt_get_pshold_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  if ( a2 > 4 || a3 == 0LL || a1 > 6 )
    return 2LL;
  *a3 = pm_pon_pshold_reset_cfg_arr[7 * a2 + a1];
  return 0LL;
}
// 169E8: using guessed type _DWORD pm_pon_pshold_reset_cfg_arr[36];

//----- (000000000000C274) ----------------------------------------------------
__int64 __fastcall pm_tgt_get_pshold_gp1_reset_cfg(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  if ( a2 > 4 || a3 == 0LL || a1 > 6 )
    return 2LL;
  *a3 = pm_pon_pshold_gp1_reset_cfg_arr[7 * a2 + a1];
  return 0LL;
}
// 16958: using guessed type _DWORD pm_pon_pshold_gp1_reset_cfg_arr[36];

//----- (000000000000C2B4) ----------------------------------------------------
__int64 __fastcall pm_pon_tgt_specific_pshold_cfg(unsigned int a1, unsigned int a2)
{
  bool v2; // cc
  unsigned int pshold_gp1_reset_cfg; // w19
  unsigned __int8 v4; // w4
  unsigned int v6; // [xsp+2Ch] [xbp+2Ch] BYREF

  v2 = a1 > 6 || a2 > 4;
  pshold_gp1_reset_cfg = 2;
  v6 = 15;
  if ( !v2 )
  {
    pshold_gp1_reset_cfg = pm_tgt_get_pshold_gp1_reset_cfg(a1, a2, &v6);
    if ( v6 != 15 )
      pshold_gp1_reset_cfg |= pm_pon_gp_reset_cfg(v4, 4, v6);
  }
  return pshold_gp1_reset_cfg;
}
// C2FC: variable 'v4' is possibly undefined

//----- (000000000000C314) ----------------------------------------------------
__int64 pm_version_detect()
{
  __int64 result; // x0
  int *v1; // x19
  __int64 v2; // x20
  int v3; // w21
  char v4[8]; // [xsp+40h] [xbp+40h] BYREF
  char v5; // [xsp+48h] [xbp+48h] BYREF

  qtiseclib_cb_memset(&v5, 0LL, 6LL);
  qtiseclib_cb_memset(v4, 0LL, 4LL);
  result = 0LL;
  if ( !pm_version_initialized )
  {
    v1 = pm_device_info_arr;
    v2 = 0LL;
    qtiseclib_cb_memset(pm_primary_slave_id, 255LL, 28LL);
    while ( 1 )
    {
      v3 = 2 * v2;
      result = pm_comm_read_byte_array(2 * (unsigned __int8)v2, 0x102u, 4u, v4, 0);
      if ( (_DWORD)result )
      {
        result = 0LL;
      }
      else if ( v4[2] == 81 )
      {
        *v1 = (unsigned __int8)v4[3];
        v1[1] = (unsigned __int8)v4[1];
        v1[2] = (unsigned __int8)v4[0];
        result = pm_comm_read_byte_array(v3, 0x100u, 6u, &v5, 0);
        pm_primary_slave_id[v2] = v3;
      }
      if ( v2 == 6 )
        break;
      ++v2;
      v1 += 3;
    }
    pm_version_initialized = 1;
  }
  return result;
}
// 31160: using guessed type int pm_device_info_arr[];
// 311B8: using guessed type char pm_version_initialized;
// 311C0: using guessed type _DWORD pm_primary_slave_id[8];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000C420) ----------------------------------------------------
__int64 __fastcall pm_get_pmic_model(unsigned __int8 a1)
{
  if ( (unsigned __int8)pm_version_initialized <= (unsigned int)(a1 > 6u) )
    return 0x7FFFFFFFLL;
  else
    return (unsigned int)pm_device_info_arr[3 * a1];
}
// 31160: using guessed type int pm_device_info_arr[];
// 311B8: using guessed type char pm_version_initialized;

//----- (000000000000C45C) ----------------------------------------------------
__int64 __fastcall pm_get_slave_id(unsigned __int8 a1, unsigned __int8 a2, unsigned int *a3)
{
  unsigned int v4; // w1

  if ( !a3 || (unsigned __int8)pm_version_initialized <= (unsigned int)(a2 > 1u) )
    return 4LL;
  if ( a1 != 7 )
  {
    if ( a1 <= 6u )
    {
      v4 = a2 + pm_primary_slave_id[a1];
      *a3 = v4;
      if ( v4 <= 0xD )
        return 0LL;
    }
    return 4LL;
  }
  *a3 = a2 + 14;
  return 0LL;
}
// 311B8: using guessed type char pm_version_initialized;
// 311C0: using guessed type _DWORD pm_primary_slave_id[8];

//----- (000000000000C4C8) ----------------------------------------------------
__int64 __fastcall qtiseclib_psci_init(unsigned __int64 a1)
{
  _QWORD *v1; // x19
  unsigned __int64 v2; // x20
  __int64 result; // x0
  _QWORD *v4; // x22
  __int64 (__fastcall **v5)(_QWORD *); // x0

  v1 = &unk_1CD38;
  set_boot_remap(a1);
  v2 = 0LL;
  pcu_init();
  result = (__int64)&unk_16000;
  while ( v2 < 9 )
  {
    v4 = v1 - 8;
    if ( (unsigned int)pcu_get_node(*((_DWORD *)v1 - 2), v1) )
    {
      qtiseclib_cb_log(10LL, "PSCI: Sequencer query failed (node: %s)", (&g_psci_asic_nodes)[10 * v2]);
      return 4294967290LL;
    }
    v5 = (__int64 (__fastcall **)(_QWORD *))*(v1 - 7);
    v1 += 10;
    result = (*v5)(v4);
    if ( (_DWORD)result )
      return result;
    ++v2;
  }
  result = (__int64)&(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(result)];
  do
  {
    *(_DWORD *)(result + 40) &= 0xFFFFFFEE;
    result = *(_QWORD *)(result + 48);
  }
  while ( result );
  return result;
}
// 1CCF8: using guessed type char *g_psci_asic_nodes;
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000C59C) ----------------------------------------------------
__int64 __fastcall qtiseclib_psci_node_power_on(__int64 a1)
{
  char **v2; // x0
  __int64 i; // x1
  int v4; // w19
  bool v5; // cc
  __int64 v6; // x20
  __int64 (__fastcall *v7)(__int64, __int64); // x2
  unsigned int v8; // w0
  unsigned int v9; // w21
  __int64 v11[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v11, 0, sizeof(v11));
  v2 = &(&g_psci_asic_nodes)[10 * (int)qtiseclib_cb_plat_core_pos_by_mpidr(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = i;
    v5 = v2 && (int)i <= 7;
    if ( !v5 || ((_DWORD)v2[5] & 0x10) == 0 )
      break;
    v11[i] = (__int64)v2;
    v2 = (char **)v2[6];
  }
  while ( 1 )
  {
    if ( --v4 == -1 )
      return 0;
    v6 = v11[v4];
    v7 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v6 + 8) + 8LL);
    if ( v7 )
    {
      v8 = v7(v11[v4], a1);
      v9 = v8;
      if ( v8 )
        break;
    }
    *(_DWORD *)(v6 + 40) &= ~0x10u;
  }
  qtiseclib_cb_log(10LL, "PSCI_PLAT: Node on (%s, %d)", *(const char **)v6, v8);
  return v9;
}
// 1CCF8: using guessed type char *g_psci_asic_nodes;
// 31950: using guessed type __int64 __fastcall qtiseclib_cb_plat_core_pos_by_mpidr(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000C684) ----------------------------------------------------
char **__fastcall qtiseclib_psci_node_on_finish(__int64 a1)
{
  char **result; // x0
  __int64 i; // x1
  bool v4; // zf
  int j; // w19
  __int64 v6; // x20
  __int64 (__fastcall *v7)(__int64, __int64); // x2
  unsigned int v8; // w0
  __int64 v9[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v9, 0, sizeof(v9));
  result = &(&g_psci_asic_nodes)[10 * (int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = (int)i > 7 || result == 0LL;
    if ( v4 || !*(_BYTE *)(a1 + i) )
      break;
    v9[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v6 = v9[j];
    v7 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v6 + 8) + 16LL);
    if ( v7 )
    {
      v8 = v7(v9[j], a1);
      if ( v8 )
        qtiseclib_cb_log(10LL, "PSCI_PLAT: Node on finish (%s, %d)", *(const char **)v6, v8);
    }
    result = (char **)(*(_DWORD *)(v6 + 40) & 0xFFFFFFFE);
    *(_DWORD *)(v6 + 40) = (_DWORD)result;
  }
  return result;
}
// 1CCF8: using guessed type char *g_psci_asic_nodes;
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000C76C) ----------------------------------------------------
char **__fastcall qtisec_psci_node_down(__int64 a1, unsigned int a2)
{
  char **result; // x0
  __int64 i; // x1
  bool v6; // zf
  int j; // w19
  __int64 v8; // x22
  __int64 v9[8]; // [xsp+40h] [xbp+40h] BYREF

  memset(v9, 0, sizeof(v9));
  result = &(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v6 = (int)i > 7 || result == 0LL;
    if ( v6 || !*(_BYTE *)(a1 + i) )
      break;
    if ( a2 == 2 )
      *((_DWORD *)result + 10) |= 0x10u;
    v9[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v8 = v9[j];
    result = (char **)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(v8 + 8) + 24LL))(v8, a1, a2);
    if ( (_DWORD)result )
      result = (char **)qtiseclib_cb_log(
                          30LL,
                          "PSCI PLAT: Node down (%s, %d, %d)",
                          *(const char **)v8,
                          (unsigned int)result,
                          a2);
  }
  return result;
}
// 1CCF8: using guessed type char *g_psci_asic_nodes;
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000C864) ----------------------------------------------------
char **__fastcall qtiseclib_psci_node_power_off(__int64 a1)
{
  return qtisec_psci_node_down(a1, 2u);
}

//----- (000000000000C86C) ----------------------------------------------------
char **__fastcall qtiseclib_psci_node_suspend(__int64 a1)
{
  return qtisec_psci_node_down(a1, 1u);
}

//----- (000000000000C874) ----------------------------------------------------
char **__fastcall qtiseclib_psci_node_suspend_finish(__int64 a1)
{
  char **result; // x0
  __int64 i; // x1
  bool v4; // zf
  int j; // w19
  __int64 v6; // x21
  __int64 v7[8]; // [xsp+30h] [xbp+30h] BYREF

  memset(v7, 0, sizeof(v7));
  result = &(&g_psci_asic_nodes)[10 * (unsigned int)qtiseclib_cb_plat_my_core_pos(a1)];
  for ( i = 0LL; ; ++i )
  {
    v4 = (int)i > 7 || result == 0LL;
    if ( v4 || !*(_BYTE *)(a1 + i) )
      break;
    v7[i] = (__int64)result;
    result = (char **)result[6];
  }
  for ( j = i - 1; j != -1; --j )
  {
    v6 = v7[j];
    result = (char **)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(v6 + 8) + 32LL))(v6, a1, 1LL);
    if ( (_DWORD)result )
      result = (char **)qtiseclib_cb_log(
                          30LL,
                          "PSCI PLAT: Suspend finish (%s, %d)",
                          *(const char **)v6,
                          (unsigned int)result);
  }
  return result;
}
// 1CCF8: using guessed type char *g_psci_asic_nodes;
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000C948) ----------------------------------------------------
void __noreturn qtiseclib_psci_system_off()
{
  pm_app_ps_hold_cfg(2u);
  MEMORY[0xC264000] = 0;
  while ( 1 )
    ;
}

//----- (000000000000C968) ----------------------------------------------------
void __noreturn qtiseclib_psci_system_reset()
{
  pm_app_ps_hold_cfg(0);
  MEMORY[0xC264000] = 0;
  while ( 1 )
    ;
}

//----- (000000000000C988) ----------------------------------------------------
__int64 __fastcall cpu_power_on_finish(__int64 a1, __int64 a2)
{
  unsigned int v2; // w19
  __int64 v3; // x19
  __int64 (__fastcall *v5)(__int64, __int64, _QWORD); // x3

  if ( !a1 )
    goto LABEL_2;
  v3 = a1;
  if ( (*(_DWORD *)(a1 + 40) & 1) != 0 )
    qtiseclib_cb_gic_pcpu_init();
  a1 = *(_QWORD *)(v3 + 8);
  v5 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 32);
  if ( v5 )
  {
    a1 = v5(v3, a2, 0LL);
    v2 = a1;
  }
  else
  {
LABEL_2:
    v2 = 0;
  }
  cpucp_clkdom_init(a1);
  return v2;
}
// 31968: using guessed type __int64 qtiseclib_cb_gic_pcpu_init(void);

//----- (000000000000C9E8) ----------------------------------------------------
__int64 __fastcall cpu_power_on(__int64 a1, __int64 a2)
{
  int v4; // w0
  _DWORD *v5; // x19
  bool v6; // cc

  v4 = qtiseclib_cb_plat_core_pos_by_mpidr(a2);
  if ( !a1 )
    return 4294967290LL;
  v5 = *(_DWORD **)(a1 + 32);
  if ( (*(_DWORD *)(a1 + 40) & 1) != 0 )
  {
    if ( rail_on_1712 )
      v6 = 0;
    else
      v6 = (unsigned __int64)v4 > 3;
    if ( v6 )
    {
      HAL_avs_SecondaryRailInit();
      rail_on_1712 = 1;
    }
    v5[2] = 40;
    v5[7] = 0;
    v5[8] = 1602;
    qtiseclib_cb_udelay(2LL);
    v5[8] = 1026;
    v5[8] = 1034;
    qtiseclib_cb_udelay(4LL);
    v5[8] = 1038;
    qtiseclib_cb_udelay(4LL);
    v5[8] = 1294;
    qtiseclib_cb_udelay(2LL);
    v5[8] = 1038;
    v5[8] = 1036;
    qtiseclib_cb_udelay(2LL);
    v5[17] = 1;
    v5[8] = 1084;
    v5[17] = 0;
    v5[8] = 17468;
    v5[2] = 1064;
  }
  else
  {
    qtiseclib_cb_ic_raise_sgi(8LL, a2);
    v5[17] &= 0xFFFC3FFu;
  }
  return 0LL;
}
// 311E4: using guessed type char rail_on_1712;
// 31908: using guessed type __int64 __fastcall qtiseclib_cb_ic_raise_sgi(_QWORD, _QWORD);
// 31950: using guessed type __int64 __fastcall qtiseclib_cb_plat_core_pos_by_mpidr(_QWORD);
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (000000000000CB08) ----------------------------------------------------
__int64 __fastcall cpu_init(__int64 a1)
{
  pcu_node_init(*(_QWORD *)(a1 + 64));
  return 0LL;
}

//----- (000000000000CB24) ----------------------------------------------------
__int64 __fastcall l3_lpm_entry(__int64 a1, unsigned __int8 *a2)
{
  unsigned int v2; // w2
  unsigned int v4; // w1
  int v5; // w21
  unsigned int v6; // w19
  unsigned __int64 v7; // x1
  unsigned __int64 v8; // x3
  int v9; // w0
  int v11; // [xsp+34h] [xbp+34h] BYREF
  unsigned int *v12; // [xsp+38h] [xbp+38h] BYREF

  v2 = -2;
  v4 = a2[1];
  if ( v4 <= 4 )
  {
    v2 = -2;
    if ( ((1LL << v4) & 0x16) != 0 )
    {
      pcu_config_low_power_mode(*(__int64 **)(a1 + 64), v4);
      v2 = 0;
      if ( a2[2] )
      {
        v5 = rsc_set_low_power_mode(g_apss_rsc, a2[2]);
        v6 = v5 | pdc_seq_set_lpm((_QWORD *)g_apss_pdc, a2[3]);
        v12 = 0LL;
        v11 = 0;
        timer_qtimer_get_frames_list(&v12, &v11);
        v7 = 0LL;
        if ( v12 && v11 )
        {
          v7 = -1LL;
          if ( (*(_DWORD *)((_BYTE *)&loc_2C + *v12) & 1) != 0 && (*(_DWORD *)((_BYTE *)&loc_2C + *v12) & 2) == 0 )
            v7 = *(unsigned int *)((char *)&power_up_sequence + *v12) | ((unsigned __int64)*(unsigned int *)((char *)&loc_24 + *v12) << 32);
          v8 = -1LL;
          if ( (*(_DWORD *)((_BYTE *)&loc_3C + *v12) & 1) != 0 && (*(_DWORD *)((_BYTE *)&loc_3C + *v12) & 2) == 0 )
            v8 = *(unsigned int *)((char *)&loc_30 + *v12) | ((unsigned __int64)*(unsigned int *)((char *)&en_dbg_feat
                                                                                                + *v12) << 32);
          if ( v7 > v8 )
            v7 = v8;
        }
        v9 = pdc_seq_set_wakeup_time(g_apss_pdc, v7);
        v2 = -3;
        if ( !v9 )
        {
          g_psci_sys_cache_active = MEMORY[0x9601004] & 1;
          v2 = v6;
          if ( (MEMORY[0x9601004] & 1) != 0 )
          {
            MEMORY[0x9601000] = 4;
            while ( (MEMORY[0x9601004] & 1) != 0 )
              ;
            return v6;
          }
        }
      }
    }
  }
  return v2;
}
// 311E0: using guessed type int g_psci_sys_cache_active;
// 311E8: using guessed type __int64 g_apss_pdc;
// 311F0: using guessed type __int64 g_apss_rsc;

//----- (000000000000CC7C) ----------------------------------------------------
__int64 __fastcall l3_init(__int64 a1)
{
  __int64 v1; // x0

  v1 = pcu_node_init(*(_QWORD *)(a1 + 64));
  rsc_driver_init(v1);
  rsc_get_handles(0, 1, (__int64)&g_apss_rsc);
  if ( (unsigned int)rsc_instance_init(g_apss_rsc) )
    return 4294967290LL;
  pdc_seq_handles(0, 1u, (__int64)&g_apss_pdc);
  return 0LL;
}
// 120D0: using guessed type __int64 __fastcall rsc_driver_init(_QWORD);
// 311E8: using guessed type __int64 g_apss_pdc;
// 311F0: using guessed type __int64 g_apss_rsc;

//----- (000000000000CCDC) ----------------------------------------------------
__int64 __fastcall cpu_lpm_exit(__int64 a1, unsigned __int8 *a2, int a3)
{
  __int64 v5; // x0
  __int64 v6; // x0

  v5 = *a2;
  if ( (unsigned int)(v5 - 3) <= 1 )
  {
    if ( (_DWORD)v5 == 4 )
    {
      v6 = qtiseclib_cb_plat_my_core_pos(v5);
      lmh_c4_exit(v6);
    }
    int_svc_notify_cpu_state(1LL);
  }
  pcu_config_low_power_mode(*(__int64 **)(a1 + 64), 1);
  if ( !a3 )
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 68LL) &= 0xFFFC3FFu;
  return 0LL;
}
// 843C: using guessed type __int64 __fastcall lmh_c4_exit(_QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (000000000000CD50) ----------------------------------------------------
__int64 __fastcall cpu_lpm_entry(__int64 a1, _BYTE *a2, int a3)
{
  __int64 v6; // x0
  __int64 v7; // x0
  int v8; // w0
  unsigned int v9; // w1

  switch ( *a2 )
  {
    case 1:
    case 2:
      goto LABEL_8;
    case 3:
    case 4:
      if ( *a2 == 4 )
      {
        v6 = qtiseclib_cb_plat_my_core_pos(a1);
        lmh_c4_entry(v6);
      }
      v7 = 0LL;
      if ( a3 == 2 )
        goto LABEL_7;
      if ( a3 == 1 )
      {
        v7 = 2LL;
LABEL_7:
        int_svc_notify_cpu_state(v7);
      }
LABEL_8:
      v8 = pcu_config_low_power_mode(*(__int64 **)(a1 + 64), (char)*a2);
      v9 = -2;
      if ( !v8 )
      {
        v9 = 0;
        if ( a3 == 2 )
          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 68LL) = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 68LL) & 0xFFFC3FF | 0x2000;
      }
      return v9;
    default:
      return 4294967294LL;
  }
}
// 8438: using guessed type __int64 __fastcall lmh_c4_entry(_QWORD);
// 31990: using guessed type __int64 __fastcall qtiseclib_cb_plat_my_core_pos(_QWORD);

//----- (000000000000CE20) ----------------------------------------------------
__int64 __fastcall l3_lpm_exit(__int64 a1, __int64 a2)
{
  if ( *(_BYTE *)(a2 + 1) == 4 && g_psci_sys_cache_active )
  {
    MEMORY[0x9601000] = 2;
    while ( (MEMORY[0x9601004] & 2) != 0 )
      ;
    g_psci_sys_cache_active = 0;
  }
  pcu_config_low_power_mode(*(__int64 **)(a1 + 64), 1);
  rsc_set_low_power_mode(g_apss_rsc, 0);
  if ( g_psci_sys_cache_active )
  {
    MEMORY[0x9601000] = 2;
    while ( (MEMORY[0x9601004] & 2) != 0 )
      ;
    g_psci_sys_cache_active = 0;
  }
  return 0LL;
}
// 311E0: using guessed type int g_psci_sys_cache_active;
// 311F0: using guessed type __int64 g_apss_rsc;

//----- (000000000000CED0) ----------------------------------------------------
__int64 pwr_utils_lvl_init()
{
  unsigned int v0; // w20
  __int64 result; // x0
  __int64 v2; // x0
  __int64 v3; // x27
  __int64 v4; // x24
  unsigned int len; // w0
  unsigned int v6; // w19
  char *v7; // x2
  __int64 v8; // x19
  __int64 i; // x1
  unsigned __int8 v11; // [xsp+6Fh] [xbp+6Fh] BYREF

  g_res = (__int64)&resource_list;
  v0 = 0;
  g_res_count = 9LL;
  while ( 1 )
  {
    result = g_res_count;
    if ( g_res_count <= (unsigned __int64)v0 )
      break;
    v2 = 24LL * v0;
    v3 = *(_QWORD *)(g_res + v2);
    v4 = g_res + v2;
    len = cmd_db_query_len(v3);
    v11 = len;
    v6 = len;
    if ( len )
    {
      if ( len > 0x20 )
        qtisec_assert("noship_src/services/pwr_utils/pwr_utils_lvl.c", 0x74u, "data_len <= MAX_AUX_DATA_LEN");
      if ( (unsigned __int64)len + alloc_offset_1210 > 0x1FF )
        qtisec_assert(
          "noship_src/services/pwr_utils/pwr_utils_lvl.c",
          0x77u,
          "(alloc_offset + data_len) < (sizeof (lvl_buf)/sizeof (lvl_buf[0]))");
      v7 = (char *)&lvl_buf + 2 * alloc_offset_1210;
      alloc_offset_1210 += len;
      *(_QWORD *)(v4 + 8) = v7;
      cmd_db_query_aux_data(v3, &v11, (__int64)v7);
      if ( v6 != v11 )
        qtisec_assert("noship_src/services/pwr_utils/pwr_utils_lvl.c", 0x7Cu, "data_len == (uint32_t)aux_len");
      v8 = v6 >> 1;
      for ( i = 0LL; i != v8; ++i )
      {
        if ( !*(_WORD *)(*(_QWORD *)(v4 + 8) + 2 * i) && (_DWORD)i != 0 )
          break;
      }
      *(_QWORD *)(v4 + 16) = (unsigned int)i;
    }
    ++v0;
  }
  return result;
}
// 1CFC8: using guessed type char *resource_list;
// 311F8: using guessed type __int64 alloc_offset_1210;
// 31200: using guessed type __int64 g_res_count;
// 31208: using guessed type __int64 g_res;

//----- (000000000000D044) ----------------------------------------------------
__int64 __fastcall pwr_utils_lvl_resource_idx(__int64 a1)
{
  unsigned int i; // w19

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( g_res && g_res_count )
  {
    for ( i = 0; g_res_count > (unsigned __int64)i; ++i )
    {
      if ( !(unsigned int)qtiseclib_cb_strcmp(*(_QWORD *)(g_res + 24LL * i)) )
        return i;
    }
  }
  return 0xFFFFFFFFLL;
}
// 31200: using guessed type __int64 g_res_count;
// 31208: using guessed type __int64 g_res;
// 31940: using guessed type __int64 __fastcall qtiseclib_cb_strcmp(_QWORD);

//----- (000000000000D0E0) ----------------------------------------------------
__int64 __fastcall pwr_utils_hlvl(int a1, int a2, char *a3)
{
  int v3; // wzr
  __int64 v5; // x3
  __int64 result; // x0
  int v7; // w4
  char v8; // [xsp+Ch] [xbp-4h] BYREF

  if ( !a3 )
    a3 = &v8;
  if ( a1 >= (unsigned __int64)g_res_count || a2 < v3 )
  {
    result = 0xFFFFFFFFLL;
    *(_DWORD *)a3 = -1;
  }
  else
  {
    v5 = g_res + 24LL * a1;
    for ( result = 0LL; (unsigned __int64)(unsigned int)result < *(_QWORD *)(v5 + 16); result = (unsigned int)(result + 1) )
    {
      v7 = *(unsigned __int16 *)(*(_QWORD *)(v5 + 8) + 2LL * (unsigned int)result);
      if ( a2 <= v7 )
      {
        *(_DWORD *)a3 = v7;
        return result;
      }
    }
    *(_DWORD *)a3 = -2;
    return 0xFFFFFFFFLL;
  }
  return result;
}
// D100: variable 'v3' is possibly undefined
// 31200: using guessed type __int64 g_res_count;
// 31208: using guessed type __int64 g_res;

//----- (000000000000D16C) ----------------------------------------------------
__int64 __fastcall pwr_utils_hlvl_named_resource(__int64 a1, int a2, char *a3)
{
  int v5; // w0

  v5 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_hlvl(v5, a2, a3);
}

//----- (000000000000D198) ----------------------------------------------------
__int64 __fastcall pwr_utils_resource_lvls_count(int a1)
{
  if ( g_res_count <= (unsigned __int64)a1 )
    return 0xFFFFFFFFLL;
  else
    return *(unsigned int *)(g_res + 24LL * a1 + 16);
}
// 31200: using guessed type __int64 g_res_count;
// 31208: using guessed type __int64 g_res;

//----- (000000000000D1C8) ----------------------------------------------------
__int64 __fastcall pwr_utils_named_resource_lvls_count(__int64 a1)
{
  int v1; // w0

  v1 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_resource_lvls_count(v1);
}

//----- (000000000000D1DC) ----------------------------------------------------
__int64 __fastcall pwr_utils_vlvl(int a1, int a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( g_res_count <= (unsigned __int64)a1 )
    return 0xFFFFFFFFLL;
  v2 = g_res + 24LL * a1;
  result = 0xFFFFFFFFLL;
  if ( (unsigned __int64)a2 < *(_QWORD *)(v2 + 16) )
    return *(unsigned __int16 *)(*(_QWORD *)(v2 + 8) + 2LL * a2);
  return result;
}
// 31200: using guessed type __int64 g_res_count;
// 31208: using guessed type __int64 g_res;

//----- (000000000000D224) ----------------------------------------------------
__int64 __fastcall pwr_utils_vlvl_named_resource(__int64 a1, int a2)
{
  int v3; // w0

  v3 = pwr_utils_lvl_resource_idx(a1);
  return pwr_utils_vlvl(v3, a2);
}

//----- (000000000000D248) ----------------------------------------------------
void __fastcall __noreturn qtisec_assert(const char *a1, unsigned int a2, const char *a3)
{
  qtiseclib_cb_log(10LL, "ASSERT: %s:%d:%s\n", a1, a2, a3);
  dbg_err_fatal(5u);
}
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000D278) ----------------------------------------------------
void (*qtiseclib_bl31_platform_setup())(void)
{
  __int64 v0; // x19
  void (*result)(void); // x0

  qtiseclib_cb_log(20LL, "%s", qtisec_version_string);
  qtiseclib_cb_log(20LL, "%s", qtisec_variant_string);
  qtiseclib_cb_log(20LL, "%s", qtisec_oem_string);
  v0 = 0LL;
  qtiseclib_cb_log(20LL, "%s", qtisec_build_string);
  while ( 1 )
  {
    result = (void (*)(void))platform_init_functions[v0++];
    if ( !result )
      break;
    result();
  }
  return result;
}
// 1D0A0: using guessed type __int64 (__fastcall *platform_init_functions[25])();
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

//----- (000000000000D30C) ----------------------------------------------------
_DWORD *__fastcall get_cmd_in_progress_isra_1_constprop_3(__int64 a1, _QWORD *a2, int a3)
{
  _DWORD *result; // x0
  unsigned int *v6[3]; // [xsp+28h] [xbp+28h] BYREF

  inq_it_begin(a1, v6);
  while ( 1 )
  {
    result = (_DWORD *)inq_it_deref((__int64)v6);
    *a2 = result;
    if ( !result )
      break;
    if ( *result == a3 )
      return (_DWORD *)(cortex_a78_aarch64_sysini + 1);
    inq_it_next(v6);
  }
  return result;
}

//----- (000000000000D360) ----------------------------------------------------
_QWORD *rpmh_clientq_create()
{
  _QWORD *v0; // x19

  v0 = (_QWORD *)rpmh_malloc(0x10u);
  rpmh_core_verify_ptr((__int64)v0);
  qtiseclib_cb_memset(v0, 0LL, 16LL);
  *v0 = inq_create(72);
  v0[1] = inq_create(72);
  return v0;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D3B4) ----------------------------------------------------
__int64 __fastcall rpmh_client_handle_add(unsigned int **a1)
{
  __int64 v2; // x0
  __int64 v3; // x19

  v2 = inq_pop(a1[1]);
  if ( v2 )
  {
    v3 = v2;
    inq_append(*a1, v2);
  }
  else
  {
    v3 = rpmh_malloc(0x50u);
    rpmh_core_verify_ptr(v3);
    qtiseclib_cb_memset(v3, 0LL, 80LL);
    *(_DWORD *)(v3 + 52) = -1;
    inq_append(*a1, v3);
    *(_QWORD *)(v3 + 32) = inq_create(24);
    *(_QWORD *)(v3 + 40) = inq_create(24);
    *(_QWORD *)(v3 + 16) = inq_create(16);
    *(_QWORD *)(v3 + 24) = inq_create(16);
  }
  return v3;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D458) ----------------------------------------------------
__int64 __fastcall rpmh_client_command_add(__int64 a1)
{
  _DWORD *v2; // x20
  int v3; // w0
  unsigned int v4; // w1
  __int64 result; // x0

  v2 = (_DWORD *)inq_pop(*(unsigned int **)(a1 + 24));
  if ( !v2 )
  {
    v2 = (_DWORD *)rpmh_malloc(0x18u);
    rpmh_core_verify_ptr((__int64)v2);
    qtiseclib_cb_memset(v2, 0LL, 24LL);
  }
  v3 = *(_DWORD *)(a1 + 48) + 1;
  *(_DWORD *)(a1 + 48) = v3;
  *v2 = v3;
  inq_append(*(unsigned int **)(a1 + 16), (__int64)v2);
  v4 = *(_DWORD *)(a1 + 52);
  ++*(_DWORD *)(a1 + 56);
  LODWORD(result) = *(_DWORD *)(a1 + 48);
  if ( (unsigned int)result > v4 )
    result = v4;
  else
    result = (unsigned int)result;
  *(_DWORD *)(a1 + 52) = result;
  return result;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D4DC) ----------------------------------------------------
__int64 __fastcall check_for_events(__int64 a1, int a2)
{
  __int64 result; // x0
  __int64 v5; // x19
  int v6; // w0
  unsigned int *v7[3]; // [xsp+38h] [xbp+38h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 32), v7);
  while ( 1 )
  {
    result = inq_it_deref((__int64)v7);
    v5 = result;
    if ( !result )
      return result;
    v6 = *(_DWORD *)(result + 16);
    if ( v6 == 1 )
    {
      if ( *(_DWORD *)v5 >= *(_DWORD *)(a1 + 52) )
        goto LABEL_9;
LABEL_8:
      rpmh_event_set(*(_QWORD *)(v5 + 8));
      inq_it_delete(v7);
      qtiseclib_cb_memset(v5, 0LL, 32LL);
      inq_append(*(unsigned int **)(a1 + 40), v5);
      inq_it_begin(*(_QWORD *)(a1 + 32), v7);
    }
    else
    {
      if ( !v6 && *(_DWORD *)v5 == a2 )
        goto LABEL_8;
LABEL_9:
      inq_it_next(v7);
    }
  }
}
// 1D228: using guessed type __int64 (__fastcall *rpmh_event_set)(_QWORD);
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D5A0) ----------------------------------------------------
__int64 __fastcall rpmh_client_command_remove(__int64 a1, int a2)
{
  _DWORD *v4; // x20
  int *v5; // x0
  int v6; // w0
  __int64 result; // x0
  unsigned int *v8[3]; // [xsp+38h] [xbp+38h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 16), v8);
  while ( 1 )
  {
    v4 = (_DWORD *)inq_it_deref((__int64)v8);
    if ( !v4 )
      rpmh_err_fatal("Inconsistent client cmds_in_progress state.");
    if ( a2 == *v4 )
      break;
    inq_it_next(v8);
  }
  inq_it_delete(v8);
  qtiseclib_cb_memset(v4, 0LL, 24LL);
  inq_append(*(unsigned int **)(a1 + 24), (__int64)v4);
  v5 = (int *)inq_head(*(_QWORD *)(a1 + 16));
  if ( v5 )
    v6 = *v5;
  else
    v6 = -1;
  *(_DWORD *)(a1 + 52) = v6;
  result = (unsigned int)(*(_DWORD *)(a1 + 56) - 1);
  *(_DWORD *)(a1 + 56) = result;
  return result;
}
// EAE4: using guessed type void __fastcall __noreturn rpmh_err_fatal(_QWORD);
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D654) ----------------------------------------------------
__int64 __fastcall rpmh_client_command_finish(__int64 a1, int a2)
{
  __int64 v4; // x0
  __int64 result; // x0
  __int64 v6; // [xsp+28h] [xbp+28h] BYREF

  v4 = *(_QWORD *)(a1 + 16);
  v6 = 0LL;
  result = (__int64)get_cmd_in_progress_isra_1_constprop_3(v4, &v6, a2);
  if ( (_BYTE)result )
  {
    result = *(unsigned __int8 *)(v6 + 8);
    if ( !*(_BYTE *)(v6 + 8) )
    {
      rpmh_client_command_remove(a1, a2);
      return check_for_events(a1, a2);
    }
  }
  return result;
}

//----- (000000000000D6B4) ----------------------------------------------------
__int64 __fastcall rpmh_client_wait_on_cmd(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v6; // x0
  int v8; // w20
  __int64 result; // x0
  __int64 v10; // x20
  __int64 v11; // x22
  unsigned int *v12; // x0
  __int64 v13; // [xsp+48h] [xbp+48h] BYREF

  v6 = *(_QWORD *)(a1 + 16);
  v13 = 0LL;
  v8 = a4;
  result = (__int64)get_cmd_in_progress_isra_1_constprop_3(v6, &v13, a2);
  if ( (_BYTE)result || a3 == 1 && (result = *(unsigned int *)(a1 + 52), a2 > (unsigned int)result) )
  {
    if ( v8 )
    {
      while ( !is_amc_finished(*(_DWORD *)a1) )
        ;
      rpmh_finish_amc_internal(*(_DWORD *)a1, 0);
      return rpmh_client_wait_on_cmd(a1, a2, a3, 1LL);
    }
    else
    {
      v10 = inq_pop(*(unsigned int **)(a1 + 40));
      if ( !v10 )
      {
        v10 = rpmh_malloc(0x20u);
        rpmh_core_verify_ptr(v10);
        qtiseclib_cb_memset(v10, 0LL, 32LL);
      }
      v11 = rpmh_event_create();
      v12 = *(unsigned int **)(a1 + 32);
      *(_DWORD *)v10 = a2;
      *(_QWORD *)(v10 + 8) = v11;
      *(_DWORD *)(v10 + 16) = a3;
      inq_append(v12, v10);
      rpmh_unlock();
      rpmh_event_wait(v11);
      rpmh_lock();
      return rpmh_event_destroy(v11);
    }
  }
  return result;
}
// 1D230: using guessed type __int64 (*rpmh_event_create)(void);
// 1D238: using guessed type __int64 (__fastcall *rpmh_event_destroy)(_QWORD);
// 1D248: using guessed type __int64 (__fastcall *rpmh_event_wait)(_QWORD);
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D7DC) ----------------------------------------------------
__int64 rpmh_epcb_timeout()
{
  rpmh_core_verify(1LL);
  return rpmh_core_verify(0LL);
}

//----- (000000000000D7F8) ----------------------------------------------------
int *__fastcall set_g_cmd_set_single(int a1, int a2, char a3, int a4)
{
  int *result; // x0

  qtiseclib_cb_memset(&unk_318AC, 0LL, 192LL);
  result = g_cmd_set;
  g_cmd_set[0] = a4;
  LOBYTE(g_cmd_set[5]) = a3;
  g_cmd_set[3] = a1;
  g_cmd_set[4] = a2;
  *(_QWORD *)&g_cmd_set[1] = 1LL;
  return result;
}
// 318A0: using guessed type int g_cmd_set[51];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000D858) ----------------------------------------------------
__int64 __fastcall add_cmd_set_for_sleep_isra_0_constprop_3(int a1, int a2)
{
  __int64 v3; // x0

  if ( (unsigned int)tcs_slots_available(a1, a2, g_cmd_set[1]) == -1 )
  {
    v3 = 0LL;
  }
  else
  {
    rpmh_core_verify(1LL);
    v3 = tcs_prepare_sleep_add_cmd_set(g_cmd_set, a1);
  }
  return rpmh_core_verify(v3);
}
// 318A0: using guessed type int g_cmd_set[51];

//----- (000000000000D8A8) ----------------------------------------------------
__int64 __fastcall add_rc_for_sleep(int *a1, int a2)
{
  char v4; // w21
  __int64 result; // x0

  v4 = resource_command_sets_dirty((__int64)a1, a2);
  result = rpmh_resource_command_get_priority((__int64)a1, a2);
  if ( (v4 & 2) != 0 )
  {
    set_g_cmd_set_single(*a1, 0, 0, 1);
    result = add_cmd_set_for_sleep_isra_0_constprop_3(a2, 1);
  }
  if ( (v4 & 4) != 0 )
  {
    set_g_cmd_set_single(*a1, 0, 1, 2);
    return add_cmd_set_for_sleep_isra_0_constprop_3(a2, 2);
  }
  return result;
}

//----- (000000000000D938) ----------------------------------------------------
__int64 __fastcall rpmh_wait_for_cmd_constprop_5(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4)
{
  int v4; // w19
  __int64 result; // x0

  v4 = a4;
  if ( a4 )
    rpmh_lock();
  rpmh_core_verify_ptr(a1);
  if ( a3 > 1 )
    result = rpmh_core_verify(0LL);
  else
    result = rpmh_client_wait_on_cmd(a1, a2, a3, 1u);
  if ( v4 )
    return rpmh_unlock();
  return result;
}

//----- (000000000000D9C0) ----------------------------------------------------
__int64 __fastcall rpmh_create_handle_internal(int a1, __int64 a2, unsigned __int8 a3)
{
  int v5; // w21
  __int64 v6; // x0
  __int64 v7; // x0
  __int64 v8; // x19
  __int64 v9; // x0

  v5 = a3;
  rpmh_lock();
  v6 = drv_valid(a1);
  rpmh_core_verify(v6);
  rpmh_core_verify(1LL);
  v7 = rpmh_client_handle_add((unsigned int **)memcpy);
  *(_DWORD *)v7 = a1;
  *(_QWORD *)(v7 + 8) = a2;
  v8 = v7;
  *(_DWORD *)(v7 + 48) = 0;
  if ( v5 )
  {
    v9 = rpmh_malloc(0x10u);
    *(_QWORD *)(v8 + 64) = v9;
    rpmh_core_verify_ptr(v9);
    qtiseclib_cb_memset(*(_QWORD *)(v8 + 64), 0LL, 16LL);
  }
  rpmh_unlock();
  return v8;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000DA54) ----------------------------------------------------
__int64 __fastcall rpmh_create_handle_explicit(int a1, __int64 a2)
{
  return rpmh_create_handle_internal(a1, a2, 1u);
}

//----- (000000000000DA5C) ----------------------------------------------------
__int64 __fastcall rpmh_create_handle(int a1, __int64 a2)
{
  return rpmh_create_handle_internal(a1, a2, 0);
}

//----- (000000000000DA64) ----------------------------------------------------
__int64 __fastcall rpmh_invalidate_explicit_cmds(__int64 a1)
{
  __int64 v2; // x0
  unsigned int v3; // w2

  rpmh_core_verify_ptr(*(_QWORD *)(a1 + 64));
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_DWORD *)(v2 + 4);
  *(_DWORD *)v2 = 0;
  qtiseclib_cb_memset(*(_QWORD *)(v2 + 8), 0LL, 204LL * v3);
  return tcs_clean_sleep_wake(*(_DWORD *)a1);
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000DAAC) ----------------------------------------------------
unsigned int *__fastcall rpmh_find_resource_command(unsigned int a1)
{
  unsigned int v2; // w3
  unsigned int v3; // w2
  unsigned int v4; // w4
  unsigned int v6; // w1
  unsigned int *result; // x0

  v2 = HIDWORD(rpmh[1]);
  v3 = v2 - 1;
  if ( v2 )
  {
    v4 = 0;
    while ( v4 <= v3 && v3 < v2 )
    {
      v6 = (v4 + v3) >> 1;
      result = (unsigned int *)(rpmh[2] + 24LL * v6);
      if ( *result >= a1 )
      {
        if ( *result <= a1 )
          return result;
        v3 = v6 - 1;
      }
      else
      {
        v4 = v6 + 1;
      }
    }
  }
  return 0LL;
}
// 31900: using guessed type _QWORD rpmh[6];

//----- (000000000000DB14) ----------------------------------------------------
unsigned int *__fastcall get_rc(unsigned int a1)
{
  unsigned int *result; // x0
  unsigned int v3; // w19
  __int64 v4; // x0
  int v5; // w21
  unsigned int *v6; // x2
  unsigned int *v7; // x1
  unsigned int v8; // t1
  unsigned int v9; // w2
  __int64 v10; // x19

  result = rpmh_find_resource_command(a1);
  if ( !result )
  {
    v3 = HIDWORD(rpmh[1]);
    HIDWORD(rpmh[1]) = v3 + 1;
    v4 = rpmh_realloc(rpmh[2], 24 * (v3 + 1));
    rpmh[2] = v4;
    rpmh_core_verify_ptr(v4);
    v5 = 0;
    v6 = (unsigned int *)rpmh[2];
    while ( v3 != v5 )
    {
      v7 = v6;
      v8 = *v6;
      v6 += 6;
      if ( a1 < v8 )
      {
        v9 = v3 - v5;
        v3 = v5;
        qtiseclib_cb_memmove(rpmh[2] + 24LL * (unsigned int)(v5 + 1), v7, 24LL * v9);
        break;
      }
      ++v5;
    }
    v10 = 24LL * v3;
    rpmh_resource_command_init((_DWORD *)(rpmh[2] + v10), a1);
    return (unsigned int *)(rpmh[2] + v10);
  }
  return result;
}
// 31900: using guessed type _QWORD rpmh[6];
// 319A0: using guessed type __int64 __fastcall qtiseclib_cb_memmove(_QWORD, _QWORD, _QWORD);

//----- (000000000000DBDC) ----------------------------------------------------
__int64 __fastcall add_explicit_cmd_set_for_sleep(int a1, int a2)
{
  __int64 result; // x0
  __int64 v5; // x19
  __int64 i; // x21
  __int64 v7; // x0
  __int64 v8; // x25
  unsigned int v9; // w22
  unsigned int v10; // w2
  __int64 v11; // x23
  unsigned int *rc; // x0
  unsigned int priority; // w0
  unsigned int *v14; // x0
  unsigned int v15; // [xsp+6Ch] [xbp+6Ch]
  unsigned int *v16[3]; // [xsp+88h] [xbp+88h] BYREF

  inq_it_begin(*(_QWORD *)memcpy, v16);
  while ( 1 )
  {
    result = inq_it_deref((__int64)v16);
    v5 = result;
    if ( !result )
      break;
    if ( *(_QWORD *)(result + 64) && *(_DWORD *)result == a2 )
    {
      for ( i = 0LL; ; ++i )
      {
        v7 = *(_QWORD *)(v5 + 64);
        if ( *(_DWORD *)v7 <= (unsigned int)i )
          break;
        v8 = *(_QWORD *)(v7 + 8);
        v9 = 0;
        v10 = 0;
        v11 = v8 + 204 * i;
        while ( *(_DWORD *)(v11 + 4) > v9 )
        {
          v15 = v10;
          rc = get_rc(*(_DWORD *)(v11 + 12LL * (int)v9 + 12));
          priority = rpmh_resource_command_get_priority((__int64)rc, a2);
          v10 = v15;
          if ( v15 <= priority )
          {
            v14 = get_rc(*(_DWORD *)(v11 + 12LL * (int)v9 + 12));
            v10 = rpmh_resource_command_get_priority((__int64)v14, a2);
          }
          ++v9;
        }
        if ( v10 == a1 )
        {
          qtiseclib_cb_memcpy(g_cmd_set, v8 + 204 * i, 204LL);
          add_cmd_set_for_sleep_isra_0_constprop_3(a2, *(_DWORD *)(v8 + 204 * i));
        }
      }
    }
    inq_it_next(v16);
  }
  return result;
}
// 318A0: using guessed type int g_cmd_set[51];
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000000DD1C) ----------------------------------------------------
__int64 __fastcall rpmh_churn_all(__int64 a1, unsigned int a2)
{
  return rpmh_wait_for_cmd_constprop_5(a1, a2, 1u, 1u);
}

//----- (000000000000DD28) ----------------------------------------------------
__int64 __fastcall rpmh_churn_single(__int64 a1, unsigned int a2)
{
  return rpmh_wait_for_cmd_constprop_5(a1, a2, 0, 1u);
}

//----- (000000000000DD3C) ----------------------------------------------------
__int64 __fastcall rpmh_finish_amc_internal(int a1, unsigned __int8 a2)
{
  int v2; // w21
  int finished_drv; // w20
  __int64 v5; // x0
  __int64 v6; // x22
  int active; // w20
  __int64 result; // x0
  __int64 v9; // [xsp+38h] [xbp+38h] BYREF

  v2 = a2;
  v9 = 0LL;
  if ( a2 )
    rpmh_lock();
  finished_drv = get_finished_drv(a1);
  if ( finished_drv == 0x3FFFFFFF )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    rpmh_core_verify(1LL);
    v5 = drv_valid(finished_drv);
    rpmh_core_verify(v5);
    v6 = 8LL * (unsigned int)lookup_drv_index(finished_drv);
    active = tcs_finish_active_amc(&v9, *(_QWORD *)(rpmh[3] + v6), finished_drv);
    rpmh_core_verify(active != 0);
    rpmh_core_verify(1LL);
    rpmh_client_command_finish(v9, active);
    while ( (unsigned __int8)rpmh_cmdq_send_cmd_at_head(*(_QWORD *)(rpmh[3] + v6)) )
      ;
  }
  result = rpmh_core_verify(1LL);
  if ( v2 )
    return rpmh_unlock();
  return result;
}
// 31900: using guessed type _QWORD rpmh[6];

//----- (000000000000DE1C) ----------------------------------------------------
__int64 __fastcall rpmh_finish_amc(int a1)
{
  return rpmh_finish_amc_internal(a1, 1u);
}

//----- (000000000000DE24) ----------------------------------------------------
__int64 __fastcall rpmh_issue_command_set_internal(__int64 a1, unsigned int *a2, unsigned __int8 a3)
{
  int v4; // w23
  unsigned int *v6; // x25
  unsigned int v7; // w24
  unsigned int v8; // w21
  unsigned int v9; // w1
  unsigned int v10; // w0
  int v11; // w21
  __int64 v12; // x26
  int v13; // w2
  unsigned int v14; // t1
  unsigned __int8 v15; // w0
  unsigned int **v16; // x21
  int v17; // w0
  unsigned int v18; // w21
  __int64 v19; // x21
  unsigned int v20; // w1
  unsigned int v21; // w0
  int v23; // [xsp+64h] [xbp+64h]
  unsigned int *rc; // [xsp+68h] [xbp+68h]

  v4 = a3;
  rpmh_is_processing = 1;
  if ( a3 )
    rpmh_lock();
  v6 = a2 + 3;
  v7 = 0;
  v8 = lookup_drv_index(*(_DWORD *)a1);
  rpmh_core_verify(1LL);
  v9 = a2[1];
  v10 = *((_DWORD *)&_compound_literal_1_2 + 12 * v8 + 7);
  v11 = 0;
  a2[2] = 0;
  rpmh_core_verify(v9 <= v10);
  v12 = *(_QWORD *)(a1 + 64);
  while ( a2[1] > v7 )
  {
    v13 = v6[1];
    ++v7;
    v14 = *v6;
    v6 += 3;
    v23 = v13;
    rc = get_rc(v14);
    rpmh_core_verify(1LL);
    if ( rpmh_resource_command_update((__int64)rc, *a2, v23, *(_DWORD *)a1, v12 != 0) )
      v11 = 1;
  }
  if ( *a2 )
  {
    v18 = 0;
    if ( !v12 )
      goto LABEL_19;
    v19 = *(_QWORD *)(a1 + 64);
    v20 = *(_DWORD *)(v19 + 4);
    v21 = *(_DWORD *)v19 + 1;
    *(_DWORD *)v19 = v21;
    if ( v21 > v20 )
    {
      *(_QWORD *)(v19 + 8) = rpmh_realloc(*(_QWORD *)(v19 + 8), 204 * v21);
      *(_DWORD *)(v19 + 4) = *(_DWORD *)v19;
    }
    qtiseclib_cb_memcpy(*(_QWORD *)(v19 + 8) + 204LL * (unsigned int)(*(_DWORD *)v19 - 1), a2, 204LL);
    add_explicit_cmd_set_for_sleep(1, *(_DWORD *)a1);
    add_explicit_cmd_set_for_sleep(0, *(_DWORD *)a1);
    tcs_prepare_sleep_commit(*(_DWORD *)a1);
    goto LABEL_18;
  }
  if ( !v11 || LOBYTE(rpmh[5]) )
  {
    rpmh_core_verify(1LL);
LABEL_18:
    v18 = 0;
    goto LABEL_19;
  }
  v15 = is_tcs_stuck(*(_DWORD *)a1);
  rpmh_core_verify(v15 ^ 1u);
  rpmh_client_command_add(a1);
  while ( a2[1] > 0x10 )
    ;
  v16 = (unsigned int **)qtiseclib_cb_memset;
  v17 = lookup_drv_index(*(_DWORD *)a1);
  v18 = rpmh_cmdq_send_cmd_set(v16[v17], (int *)a1, a2);
  rpmh_core_verify(1LL);
LABEL_19:
  if ( v4 )
    rpmh_unlock();
  rpmh_wait_for_cmd_constprop_5(a1, v18, 1u, v4);
  rpmh_is_processing = 0;
  return v18;
}
// 31611: using guessed type char rpmh_is_processing;
// 31900: using guessed type _QWORD rpmh[6];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000000E064) ----------------------------------------------------
__int64 __fastcall rpmh_issue_command_set(__int64 a1, unsigned int *a2)
{
  return rpmh_issue_command_set_internal(a1, a2, 1u);
}

//----- (000000000000E06C) ----------------------------------------------------
__int64 __fastcall rpmh_issue_command(__int64 a1, int a2, char a3, int a4, int a5)
{
  rpmh_lock();
  set_g_cmd_set_single(a4, a5, a3, a2);
  LODWORD(a1) = rpmh_issue_command_set_internal(a1, (unsigned int *)g_cmd_set, 0);
  rpmh_unlock();
  return (unsigned int)a1;
}
// 318A0: using guessed type int g_cmd_set[51];

//----- (000000000000E0E8) ----------------------------------------------------
__int64 __fastcall rpmh_enter_sleep(int a1)
{
  __int64 v3; // x0
  unsigned int v4; // w22
  __int64 v5; // x0
  __int64 v6; // x22
  __int64 v7; // x0
  int *v8; // x24
  __int64 v9; // x21
  int *v10; // x22

  rpmh_lock();
  if ( !(_BYTE)qtiseclib_cb_memcpy )
  {
    v3 = drv_valid(a1);
    rpmh_core_verify(v3);
    v4 = lookup_drv_index(a1);
    rpmh_core_verify(1LL);
    tcs_clean_sleep_wake(a1);
    if ( *((_DWORD *)&_compound_literal_1_2 + 12 * v4 + 2) )
      rpmh_deregister_isr();
    v5 = *((_QWORD *)qtiseclib_cb_memset + v4);
    v6 = 0LL;
    v7 = cmdq_empty(v5);
    rpmh_core_verify(v7);
    add_explicit_cmd_set_for_sleep(1, a1);
    while ( HIDWORD(qtiseclib_cb_ic_raise_sgi) > (unsigned int)v6 )
    {
      v8 = (int *)((char *)qtiseclib_cb_spin_lock + 24 * v6);
      if ( (unsigned int)rpmh_resource_command_get_priority((__int64)v8, a1) == 1 )
        add_rc_for_sleep(v8, a1);
      ++v6;
    }
    v9 = 0LL;
    add_explicit_cmd_set_for_sleep(0, a1);
    while ( HIDWORD(rpmh[1]) > (unsigned int)v9 )
    {
      v10 = (int *)(rpmh[2] + 24 * v9);
      if ( (unsigned int)rpmh_resource_command_get_priority((__int64)v10, a1) != 1 )
        add_rc_for_sleep(v10, a1);
      ++v9;
    }
    tcs_prepare_sleep_commit(a1);
  }
  rpmh_core_verify(1LL);
  return rpmh_unlock();
}
// EAA0: using guessed type __int64 __fastcall rpmh_clock_toggle(_QWORD, _QWORD);
// EB10: using guessed type __int64 rpmh_deregister_isr(void);
// 31900: using guessed type _QWORD rpmh[6];
// 31908: using guessed type __int64 __fastcall qtiseclib_cb_ic_raise_sgi(_QWORD, _QWORD);
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000000E270) ----------------------------------------------------
__int64 __fastcall rpmh_exit_sleep(int a1)
{
  __int64 v2; // x0
  __int64 v4; // x0
  __int64 v5; // x19
  __int64 i; // x20
  __int64 v7; // x0

  rpmh_lock();
  if ( !(_BYTE)qtiseclib_cb_memcpy )
  {
    v4 = drv_valid(a1);
    rpmh_core_verify(v4);
    v5 = 48LL * (unsigned int)lookup_drv_index(a1);
    for ( i = 0LL; HIDWORD(rpmh[1]) > (unsigned int)i; ++i )
    {
      v7 = rpmh[2] + 24 * i;
      rpmh_resource_command_exit_sleep(v7, a1);
    }
    v2 = *(unsigned int *)((char *)&_compound_literal_1_2 + v5 + 8);
    if ( (_DWORD)v2 )
      rpmh_register_isr(v2, (__int64)rpmh_finish_amc, *(unsigned int *)((char *)&_compound_literal_1_2 + v5), 0);
  }
  rpmh_core_verify(1LL);
  return rpmh_unlock();
}
// EAA0: using guessed type __int64 __fastcall rpmh_clock_toggle(_QWORD, _QWORD);
// 31900: using guessed type _QWORD rpmh[6];
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000000E36C) ----------------------------------------------------
__int64 __fastcall rpmh_get_wake_latency(int a1)
{
  return *((unsigned int *)&_compound_literal_1_2 + 12 * (int)lookup_drv_index(a1) + 4);
}

//----- (000000000000E3A4) ----------------------------------------------------
void rpmh_client_init()
{
  __int64 v0; // x21
  char *v1; // x28
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x24
  char *v5; // x27
  __int64 *v6; // x20
  __int64 v7; // x22

  if ( LODWORD(rpmh[0]) != 1 )
  {
    LODWORD(rpmh[0]) = 1;
    LOBYTE(qtiseclib_cb_memcpy) = RPMH_STANDALONE;
    rpmh_os_init();
    rpmh_core_verify(1LL);
    if ( !(_BYTE)qtiseclib_cb_memcpy )
      tcs_init();
    v0 = 0LL;
    qtiseclib_cb_memset = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))rpmh_malloc(8u);
    while ( !(_DWORD)v0 )
    {
      v1 = (char *)&_compound_literal_1_2 + 48 * v0;
      v2 = *((unsigned int *)v1 + 2);
      if ( (_DWORD)v2 )
        rpmh_register_isr(v2, (__int64)rpmh_finish_amc, *((unsigned int *)&_compound_literal_1_2 + 12 * v0), 0);
      v3 = *((unsigned int *)v1 + 3);
      if ( (_DWORD)v3 )
        rpmh_register_isr(v3, (__int64)rpmh_epcb_timeout, *((unsigned int *)&_compound_literal_1_2 + 12 * v0), 1);
      v4 = 8 * v0++;
      v5 = (char *)qtiseclib_cb_memset;
      *(_QWORD *)&v5[v4] = rpmh_cmdq_create(0);
    }
    rpmh[4] = rpmh_clientq_create();
    rpmh_core_verify(1LL);
    if ( !HIDWORD(rpmh[0]) && !LOBYTE(rpmh[5]) )
    {
      v6 = (__int64 *)(MEMORY[0xC3F0000] + 204472320LL);
      do
      {
        v7 = *v6;
        qtiseclib_cb_udelay(1LL);
        ++LODWORD(rpmh[1]);
      }
      while ( (_DWORD)v7 != -1598026722 );
      HIDWORD(rpmh[0]) = 1;
    }
    rpmh_core_verify(1LL);
    rpmh_core_verify(1LL);
  }
}
// EA9C: using guessed type __int64 rpmh_os_init(void);
// EAA0: using guessed type __int64 __fastcall rpmh_clock_toggle(_QWORD, _QWORD);
// 31610: using guessed type char RPMH_STANDALONE;
// 31900: using guessed type _QWORD rpmh[6];
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);
// 31928: using guessed type __int64 __fastcall qtiseclib_cb_memcpy(_QWORD, _QWORD, _QWORD);
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (000000000000E59C) ----------------------------------------------------
__int64 __fastcall rpmh_clean_cmd(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // x19

  v2 = a1 + 1;
  qtiseclib_cb_memset(*a1, 0LL, 8LL * a2);
  return qtiseclib_cb_memset(v2, 0LL, 40LL);
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000E5D4) ----------------------------------------------------
__int64 __fastcall rpmh_cmdq_create(unsigned int a1)
{
  char *v1; // x20
  __int64 v2; // x19

  v1 = (char *)&_compound_literal_1_2 + 48 * a1;
  v2 = rpmh_malloc(0x20u);
  rpmh_core_verify_ptr(v2);
  qtiseclib_cb_memset(v2, 0LL, 32LL);
  *(_DWORD *)v2 = *((_DWORD *)v1 + 7);
  *(_QWORD *)(v2 + 8) = inq_create(40);
  *(_QWORD *)(v2 + 16) = inq_create(40);
  *(_QWORD *)(v2 + 24) = inq_create(40);
  return v2;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000E650) ----------------------------------------------------
__int64 __fastcall rpmh_cmdq_send_cmd_set(unsigned int *a1, int *a2, _DWORD *a3)
{
  __int64 v6; // x19
  __int64 v7; // x0
  unsigned int v8; // w0
  int v9; // w1
  unsigned int *v10; // x24
  __int64 v11; // x23
  int v12; // w25
  unsigned int v13; // w0
  unsigned int v14; // w26
  unsigned int v15; // w28
  unsigned int *resource_command; // x27
  unsigned int *v17; // x2
  __int64 voter; // x26
  unsigned int v19; // w22

  v6 = inq_pop(*((unsigned int **)a1 + 3));
  if ( !v6 )
  {
    v6 = rpmh_malloc(0x30u);
    rpmh_core_verify_ptr(v6);
    qtiseclib_cb_memset(v6, 0LL, 48LL);
  }
  if ( !*(_QWORD *)v6 )
  {
    v7 = rpmh_malloc(8 * *a1);
    *(_QWORD *)v6 = v7;
    rpmh_core_verify_ptr(v7);
    qtiseclib_cb_memset(*(_QWORD *)v6, 0LL, 8LL * *a1);
  }
  v8 = a3[1];
  v9 = 0;
  *(_QWORD *)(v6 + 16) = a2;
  *(_DWORD *)(v6 + 8) = v8;
  if ( a2 )
    v9 = a2[12];
  *(_DWORD *)(v6 + 24) = v9;
  v10 = a3 + 3;
  v11 = 0LL;
  v12 = 1;
  *(_DWORD *)(v6 + 12) = a3[2];
  *(_DWORD *)(v6 + 28) = *a3;
  *(_BYTE *)(v6 + 32) = 1;
  rpmh_core_verify(v8 <= *a1);
  rpmh_core_verify(a3[1] <= *a1);
  while ( 1 )
  {
    v13 = *(_DWORD *)(v6 + 8);
    if ( v13 <= (unsigned int)v11 )
      break;
    v14 = *v10;
    v15 = *((unsigned __int8 *)v10 + 8);
    resource_command = rpmh_find_resource_command(*v10);
    rpmh_core_verify_ptr((__int64)resource_command);
    v17 = (unsigned int *)(*(_QWORD *)v6 + 8 * v11);
    v17[1] = v15;
    *v17 = v14;
    if ( a2 )
    {
      voter = rpmh_resource_command_get_voter((__int64)resource_command, *a2);
      rpmh_core_verify_ptr(voter);
      if ( *(_DWORD *)(voter + 4) )
        v12 = 0;
    }
    ++v11;
    v10 += 3;
  }
  rpmh_core_verify(*a1 >= v13);
  if ( *a3 )
  {
    v19 = 0;
    rpmh_core_verify(0LL);
  }
  else
  {
    rpmh_core_verify_ptr((__int64)a2);
    v19 = *(_DWORD *)(v6 + 24);
    if ( v12 && (unsigned __int8)is_amc_free(*a2) )
    {
      inq_append(*((unsigned int **)a1 + 1), v6);
      tcs_send(v6, *a2);
    }
    else
    {
      rpmh_core_verify(1LL);
      inq_append(*((unsigned int **)a1 + 2), v6);
    }
  }
  return v19;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000E83C) ----------------------------------------------------
unsigned int *__fastcall cmdq_finish_cmd(__int64 a1, __int64 a2, int a3, __int64 a4, int a5)
{
  __int64 v8; // x0
  __int64 v9; // x0
  __int64 i; // x20
  __int64 v11; // x0
  unsigned int *v13[3]; // [xsp+38h] [xbp+38h] BYREF

  if ( a5 )
  {
    rpmh_core_verify(0LL);
    v8 = 0LL;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 8);
  }
  inq_it_begin(v8, v13);
  while ( 1 )
  {
    v9 = inq_it_deref((__int64)v13);
    if ( !v9 )
      rpmh_err_fatal("Inconsistent cmdq state.");
    if ( a2 == v9 )
      break;
    inq_it_next(v13);
  }
  inq_it_delete(v13);
  for ( i = 0LL; *(_DWORD *)(a2 + 8) > (unsigned int)i; ++i )
  {
    v11 = 8 * i;
    rpmh_resource_command_finish(*(_DWORD *)(*(_QWORD *)a2 + v11), a3);
  }
  rpmh_clean_cmd((_QWORD *)a2, *(_DWORD *)a1);
  return inq_append(*(unsigned int **)(a1 + 24), a2);
}
// EAE4: using guessed type void __fastcall __noreturn rpmh_err_fatal(_QWORD);

//----- (000000000000E904) ----------------------------------------------------
bool __fastcall cmdq_empty(__int64 a1)
{
  return !inq_head(*(_QWORD *)(a1 + 16)) && inq_head(*(_QWORD *)(a1 + 8)) == 0;
}

//----- (000000000000E944) ----------------------------------------------------
__int64 __fastcall cmdq_num_in_flight(__int64 a1)
{
  return inq_size(*(_QWORD *)(a1 + 8));
}

//----- (000000000000E94C) ----------------------------------------------------
__int64 __fastcall rpmh_cmdq_send_cmd_at_head(__int64 a1)
{
  __int64 v2; // x0
  unsigned int v3; // w21
  __int64 v4; // x19
  __int64 v5; // x21
  int v6; // w22
  unsigned int *resource_command; // x23
  __int64 voter; // x23
  unsigned __int8 v9; // w0
  unsigned int *v11[3]; // [xsp+48h] [xbp+48h] BYREF

  inq_it_begin(*(_QWORD *)(a1 + 16), v11);
  v2 = inq_it_deref((__int64)v11);
  if ( !v2 )
    return 0;
  v4 = v2;
  v5 = 0LL;
  v6 = 1;
  rpmh_core_verify(*(_DWORD *)(v2 + 8) <= *(_DWORD *)a1);
  while ( *(_DWORD *)(v4 + 8) > (unsigned int)v5 )
  {
    resource_command = rpmh_find_resource_command(*(_DWORD *)(*(_QWORD *)v4 + 8 * v5));
    rpmh_core_verify_ptr((__int64)resource_command);
    if ( !cmdq_empty(a1) )
    {
      voter = rpmh_resource_command_get_voter((__int64)resource_command, **(_DWORD **)(v4 + 16));
      rpmh_core_verify_ptr(voter);
      if ( *(_DWORD *)(voter + 4) || *(_DWORD *)(*(_QWORD *)v4 + 4LL) == 2 && (unsigned int)cmdq_num_in_flight(a1) )
        v6 = 0;
    }
    ++v5;
  }
  if ( v6 && (v9 = tcs_send(v4, **(_DWORD **)(v4 + 16)), (v3 = v9) != 0) )
  {
    inq_it_delete(v11);
    inq_append(*(unsigned int **)(a1 + 8), v4);
  }
  else
  {
    return 0;
  }
  return v3;
}

//----- (000000000000EA6C) ----------------------------------------------------
__int64 rpmh_create_dal_event()
{
  rpmh_core_verify(0LL);
  return 0LL;
}

//----- (000000000000EA88) ----------------------------------------------------
unsigned int *__fastcall rpmh_destroy_dal_event(__int64 a1)
{
  return inq_append(0LL, a1);
}

//----- (000000000000EAA4) ----------------------------------------------------
__int64 rpmh_lock()
{
  return qtiseclib_cb_spin_lock(&rpmh_os);
}
// 318A8: using guessed type int rpmh_os;
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);

//----- (000000000000EAB0) ----------------------------------------------------
__int64 rpmh_unlock()
{
  return qtiseclib_cb_spin_unlock(&rpmh_os);
}
// 318A8: using guessed type int rpmh_os;
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (000000000000EABC) ----------------------------------------------------
__int64 is_rpmh_busy()
{
  return (unsigned __int8)rpmh_is_processing;
}
// 31611: using guessed type char rpmh_is_processing;

//----- (000000000000EAC8) ----------------------------------------------------
__int64 __fastcall rpmh_core_verify(__int64 result)
{
  if ( !(_BYTE)result )
  {
    while ( 1 )
      ;
  }
  return result;
}

//----- (000000000000EAD8) ----------------------------------------------------
__int64 __fastcall rpmh_core_verify_ptr(__int64 result)
{
  if ( !result )
  {
    while ( 1 )
      ;
  }
  return result;
}

//----- (000000000000EAE8) ----------------------------------------------------
void *__fastcall rpmh_register_isr(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  void *result; // x0

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      result = &unk_31000;
      tz_timeout_cb = a2;
    }
  }
  else
  {
    result = &unk_31000;
    tz_completion_cb = a2;
  }
  return result;
}
// 318C8: using guessed type __int64 tz_completion_cb;
// 318D0: using guessed type __int64 tz_timeout_cb;

//----- (000000000000EB18) ----------------------------------------------------
__int64 __fastcall rpmh_clz(int a1)
{
  __int64 result; // x0

  result = 0LL;
  do
  {
    if ( (a1 & 0x80000000) != 0 )
      break;
    result = (unsigned int)(result + 1);
    a1 *= 2;
  }
  while ( (_DWORD)result != 32 );
  return result;
}

//----- (000000000000EB38) ----------------------------------------------------
unsigned __int64 __fastcall rpmh_malloc(unsigned int a1)
{
  return qtisec_malloc(a1);
}

//----- (000000000000EB44) ----------------------------------------------------
unsigned __int64 __fastcall rpmh_realloc(__int64 a1, unsigned int a2)
{
  return qtisec_realloc(a1, a2);
}

//----- (000000000000EB4C) ----------------------------------------------------
__int64 __fastcall resource_command_dirty_update_isra_0(__int64 result)
{
  int v1; // w3
  __int64 v2; // x1
  __int64 v3; // x2
  int v4; // w1
  int v5; // w3

  if ( result )
  {
    v1 = *(unsigned __int8 *)(result + 28);
    if ( !*(_BYTE *)(result + 28) || *(_BYTE *)(result + 16) && *(_DWORD *)(result + 24) == *(_DWORD *)(result + 12) )
      *(_DWORD *)(result + 32) = 0;
    else
      *(_DWORD *)(result + 32) = 2;
    v2 = result + 36;
    if ( *(_DWORD *)(result + 44) != 1 )
    {
      if ( !*(_BYTE *)(result + 40) || v1 && *(_DWORD *)(result + 24) == *(_DWORD *)(result + 36) )
        *(_DWORD *)(result + 44) = 0;
      else
        *(_DWORD *)(result + 44) = 2;
    }
    v3 = result + 48;
    if ( *(_DWORD *)(result + 56) != 1 )
    {
      if ( *(_BYTE *)(result + 52) )
      {
        if ( v1 && *(_DWORD *)(result + 48) != *(_DWORD *)(result + 24)
          || *(_BYTE *)(result + 40)
          && (v4 = *(_DWORD *)(result + 48), result = *(unsigned int *)(result + 36), v4 != (_DWORD)result) )
        {
          result = 2LL;
LABEL_25:
          *(_DWORD *)(v3 + 8) = result;
          return result;
        }
      }
      else if ( v1 )
      {
        if ( *(_BYTE *)(result + 40) )
        {
          v5 = *(_DWORD *)(result + 24);
          result = *(unsigned int *)(result + 36);
          if ( v5 != (_DWORD)result )
          {
            result = *(unsigned int *)(v2 + 8);
            if ( (_DWORD)result != 1 )
            {
              result = 4LL;
              goto LABEL_25;
            }
          }
        }
      }
      *(_DWORD *)(v3 + 8) = 0;
    }
  }
  return result;
}

//----- (000000000000EC48) ----------------------------------------------------
__int64 __fastcall rpmh_resource_command_init(_DWORD *a1, int a2)
{
  __int64 result; // x0

  result = qtiseclib_cb_memset(a1, 0LL, 24LL);
  *a1 = a2;
  return result;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000EC78) ----------------------------------------------------
unsigned __int64 __fastcall rpmh_resource_command_get_voter(__int64 a1, int a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  unsigned int v6; // w0

  v2 = *(_QWORD *)(a1 + 8);
  v3 = 0LL;
  while ( v2 )
  {
    if ( *(_DWORD *)v2 == a2 )
      return v2;
    v3 = v2;
    v2 = *(_QWORD *)(v2 + 64);
  }
  v2 = rpmh_malloc(0x48u);
  qtiseclib_cb_memset(v2, 0LL, 72LL);
  *(_DWORD *)v2 = a2;
  v6 = lookup_drv_index(a2);
  *(_DWORD *)(v2 + 8) = cmd_db_query_priority(*(_DWORD *)a1, *((_BYTE *)&_compound_literal_1_2 + 48 * v6 + 4));
  if ( *(_QWORD *)(a1 + 8) )
  {
    rpmh_core_verify_ptr(v3);
    *(_QWORD *)(v3 + 64) = v2;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = v2;
  }
  return v2;
}
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000ED2C) ----------------------------------------------------
__int64 __fastcall rpmh_resource_command_get_priority(__int64 a1, int a2)
{
  return *(unsigned int *)(rpmh_resource_command_get_voter(a1, a2) + 8);
}

//----- (000000000000ED44) ----------------------------------------------------
unsigned __int64 __fastcall resource_command_sets_dirty(__int64 a1, int a2)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x2

  result = rpmh_resource_command_get_voter(a1, a2);
  if ( !result )
    return 0LL;
  v3 = result;
  LODWORD(result) = 2 * (*(_DWORD *)(result + 44) >= 2u);
  if ( *(_DWORD *)(v3 + 56) < 2u )
    return (unsigned int)result;
  else
    return (unsigned int)result | 4;
}

//----- (000000000000ED88) ----------------------------------------------------
bool __fastcall rpmh_resource_command_update(__int64 a1, unsigned int a2, int a3, int a4, unsigned __int8 a5)
{
  __int64 v5; // x19
  __int64 voter; // x5
  __int64 v9; // x0
  __int64 v10; // x5

  v5 = a2;
  voter = rpmh_resource_command_get_voter(a1, a4);
  v9 = voter + 12LL * (unsigned int)v5;
  *(_BYTE *)(v9 + 28) = 1;
  *(_DWORD *)(v9 + 24) = a3;
  if ( (a5 & ((_DWORD)v5 != 0)) != 0 )
    *(_DWORD *)(v9 + 32) = 1;
  resource_command_dirty_update_isra_0(voter);
  return *(_DWORD *)(v10 + 12 * v5 + 32) > 1u;
}
// EDF0: variable 'v10' is possibly undefined

//----- (000000000000EE0C) ----------------------------------------------------
__int64 __fastcall rpmh_resource_command_exit_sleep(__int64 a1, int a2)
{
  __int64 voter; // x0
  int v3; // w4
  int v4; // w3

  voter = rpmh_resource_command_get_voter(a1, a2);
  if ( voter && *(_BYTE *)(voter + 52) )
  {
    v3 = *(_DWORD *)(voter + 56);
    v4 = *(_DWORD *)(voter + 48);
    *(_BYTE *)(voter + 28) = 1;
    *(_DWORD *)(voter + 24) = v4;
    if ( v3 != 1 )
    {
      *(_BYTE *)(voter + 52) = 0;
      *(_DWORD *)(voter + 48) = 0;
    }
    *(_BYTE *)(voter + 16) = 1;
    *(_DWORD *)(voter + 12) = v4;
  }
  return resource_command_dirty_update_isra_0(voter);
}

//----- (000000000000EE58) ----------------------------------------------------
__int64 __fastcall rpmh_resource_command_val_at_rpmh(unsigned int a1, int a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v4; // x19
  int v5; // w22
  unsigned int *resource_command; // x21
  __int64 voter; // x20
  unsigned __int64 v9; // x0
  unsigned __int64 v10; // x21
  unsigned __int64 v11; // x19
  unsigned int v12; // w0
  unsigned int v13; // w19
  __int64 v14; // x0

  v4 = a3;
  v5 = a4;
  resource_command = rpmh_find_resource_command(a1);
  rpmh_core_verify_ptr((__int64)resource_command);
  voter = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  rpmh_core_verify_ptr(voter);
  rpmh_core_verify(*(_DWORD *)(voter + 4) == 0);
  v9 = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  if ( v9 )
  {
    v10 = v9;
    v11 = v9 + 12 * v4;
    v12 = *(_DWORD *)(v11 + 32);
    if ( v12 <= 2 )
    {
      rpmh_core_verify(*(unsigned __int8 *)(v11 + 28));
      v13 = *(_DWORD *)(v11 + 24);
      goto LABEL_6;
    }
    if ( v12 == 4 )
    {
      rpmh_core_verify(*(unsigned __int8 *)(v10 + 28));
      v13 = *(_DWORD *)(v10 + 24);
LABEL_6:
      v14 = 1LL;
      goto LABEL_9;
    }
    rpmh_core_verify(0LL);
  }
  v13 = 0;
  v14 = 0LL;
LABEL_9:
  rpmh_core_verify(v14);
  *(_DWORD *)(voter + 12) = v13;
  *(_BYTE *)(voter + 16) = 1;
  if ( v5 )
    *(_DWORD *)(voter + 4) = 1;
  return v13;
}

//----- (000000000000EF40) ----------------------------------------------------
__int64 __fastcall rpmh_resource_command_finish(unsigned int a1, int a2)
{
  unsigned int *resource_command; // x19
  __int64 voter; // x19

  resource_command = rpmh_find_resource_command(a1);
  rpmh_core_verify_ptr((__int64)resource_command);
  voter = rpmh_resource_command_get_voter((__int64)resource_command, a2);
  rpmh_core_verify_ptr(voter);
  *(_DWORD *)(voter + 4) = 0;
  return resource_command_dirty_update_isra_0(voter);
}

//----- (000000000000EF84) ----------------------------------------------------
__int64 __fastcall tcs_update_mode(unsigned int a1, unsigned int a2)
{
  __int64 v2; // x20
  __int64 v4; // x22
  char *v5; // x19
  __int64 v6; // x21
  __int64 i; // x20
  __int64 result; // x0
  __int64 v9; // x27
  unsigned int v10; // w1
  __int64 v11; // x28
  __int64 v12; // x0
  unsigned int v13; // w0
  unsigned int v14; // w0
  int v15; // w0
  unsigned int v16; // w0

  v2 = a1;
  v4 = 8LL * a1;
  v5 = (char *)&_compound_literal_1_2 + 48 * a1;
  rpmh_core_verify(*((_DWORD *)v5 + 8) > a2);
  *(_DWORD *)(tcs_mode + 4 * v2) = a2;
  v6 = 8LL * a2;
  for ( i = 0LL; ; ++i )
  {
    result = *((unsigned int *)v5 + 6);
    if ( (unsigned int)result <= (unsigned int)i )
      break;
    v9 = *(_QWORD *)(rpmh_tcs + v4);
    v10 = (unsigned __int8)(*((_DWORD *)v5 + 5) + i);
    v11 = v9 + 24 * i;
    *(_BYTE *)v11 = v10;
    v12 = (unsigned int)RscHalClearAMCFinishedIRQ(*((_DWORD *)v5 + 1), v10) == 0;
    rpmh_core_verify(v12);
    v13 = **(_DWORD **)(*((_QWORD *)v5 + 5) + v6);
    *(_QWORD *)(v11 + 8) = 0LL;
    if ( (unsigned int)i >= v13 )
    {
      v16 = *((_DWORD *)v5 + 1);
      *(_DWORD *)(v11 + 4) = 3;
      v15 = RscHalConvertAMCtoTCS(v16, *(_BYTE *)(v9 + 24 * i));
    }
    else
    {
      v14 = *((_DWORD *)v5 + 1);
      *(_DWORD *)(v11 + 4) = 0;
      v15 = RscHalConvertTCStoAMC(v14, *(_BYTE *)(v9 + 24 * i));
    }
    rpmh_core_verify(v15 == 0);
  }
  return result;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000F09C) ----------------------------------------------------
__int64 tcs_init()
{
  __int64 v0; // x20
  __int64 result; // x0
  char *v2; // x22
  unsigned int v3; // w23
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // [xsp+70h] [xbp+70h]
  unsigned int v7; // [xsp+88h] [xbp+88h] BYREF
  unsigned int v8; // [xsp+8Ch] [xbp+8Ch] BYREF

  v0 = 0LL;
  v8 = 0;
  v7 = 0;
  rpmh_tcs = rpmh_malloc(8u);
  rpmh_core_verify_ptr(rpmh_tcs);
  qtiseclib_cb_memset(rpmh_tcs, 0LL, 8LL);
  tcs_mode = rpmh_malloc(4u);
  rpmh_core_verify_ptr(tcs_mode);
  qtiseclib_cb_memset(rpmh_tcs, 0LL, 4LL);
  while ( 1 )
  {
    result = 1LL;
    if ( (_DWORD)v0 )
      break;
    v2 = (char *)&_compound_literal_1_2 + 48 * v0;
    *(_DWORD *)(tcs_mode + 4 * v0) = 0;
    v3 = ***((_DWORD ***)v2 + 5);
    if ( *(_DWORD *)v2 <= 0x3FFFFEFFu )
    {
      v4 = (unsigned int)RscHalRegisterDrv(*(_DWORD *)v2) == 0;
      rpmh_core_verify(v4);
      v5 = (unsigned int)RscHalReadConfig(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), &v7, &v8) == 0;
      rpmh_core_verify(v5);
      rpmh_core_verify(*((_DWORD *)v2 + 6) <= v7);
      rpmh_core_verify(*((_DWORD *)v2 + 7) <= v8);
      rpmh_core_verify(v3 <= v7);
      RscHalUpdateePCBTimeOutThreshold(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), 0xFFFFu);
      RscHalToggleePCBTimeOut(*((_DWORD *)&_compound_literal_1_2 + 12 * v0), 1);
    }
    v6 = rpmh_tcs;
    *(_QWORD *)(v6 + 8 * v0) = rpmh_malloc(24 * *((_DWORD *)v2 + 6));
    rpmh_core_verify_ptr(*(_QWORD *)(rpmh_tcs + 8 * v0));
    qtiseclib_cb_memset(*(_QWORD *)(rpmh_tcs + 8 * v0), 0LL, 24LL * *((unsigned int *)v2 + 6));
    rpmh_core_verify(*((_DWORD *)v2 + 7) == 16);
    if ( v3 < v7 )
      rpmh_core_verify(v7 >= v3 + 2);
    ++v0;
    tcs_update_mode(0, 0);
  }
  return result;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000F2A0) ----------------------------------------------------
__int64 __fastcall drv_valid(int a1)
{
  __int64 i; // x1
  int v2; // w4

  for ( i = 0LL; i != 48; i += 48LL )
  {
    v2 = *(_DWORD *)((char *)&_compound_literal_1_2 + i);
    if ( v2 == a1 )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000000F2E4) ----------------------------------------------------
__int64 __fastcall lookup_drv_index(int a1)
{
  __int64 v1; // x1
  unsigned int v2; // w2
  __int64 v3; // x6

  v1 = 0LL;
  while ( 1 )
  {
    v2 = v1;
    if ( v1 == 1 )
      break;
    v3 = 48 * v1++;
    if ( *(_DWORD *)((char *)&_compound_literal_1_2 + v3) == a1 )
      return v2;
  }
  rpmh_core_verify(0LL);
  return 0xFFFFFFFFLL;
}

//----- (000000000000F340) ----------------------------------------------------
__int64 __fastcall get_finished_amc(int a1)
{
  unsigned int v1; // w20
  unsigned int *v2; // x21
  __int64 v3; // x0
  unsigned int v4; // w22
  __int64 v5; // x20
  unsigned int v6; // w19
  __int64 v7; // x19
  int v9; // [xsp+3Ch] [xbp+3Ch] BYREF

  v1 = lookup_drv_index(a1);
  v2 = (unsigned int *)((char *)&_compound_literal_1_2 + 48 * v1);
  v3 = (unsigned int)RscHalCheckAMCFinishedIRQ(v2[1], &v9) == 0;
  rpmh_core_verify(v3);
  if ( !v9 )
    return 0LL;
  v4 = v2[5];
  v5 = 8LL * v1;
  v6 = 31 - v4 - rpmh_clz(v9);
  rpmh_core_verify(v6 <= v2[6]);
  v7 = 24LL * v6;
  rpmh_core_verify(*(_DWORD *)(*(_QWORD *)(rpmh_tcs + v5) + v7 + 4) == 1);
  return *(_QWORD *)(rpmh_tcs + v5) + v7;
}
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000F400) ----------------------------------------------------
__int64 __fastcall tcs_clean_up(__int64 a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned int v8; // w0
  __int64 v9; // x0

  v8 = lookup_drv_index(a3);
  v9 = (unsigned int)RscHalClearAMCFinishedIRQ(*((_DWORD *)&_compound_literal_1_2 + 12 * v8 + 1), *a2) == 0;
  rpmh_core_verify(v9);
  cmdq_finish_cmd(a1, *((_QWORD *)a2 + 2), a3, *a2, a4);
  *((_DWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0LL;
  return rpmh_core_verify(1LL);
}

//----- (000000000000F488) ----------------------------------------------------
__int64 __fastcall tcs_send_internal(__int64 a1, int a2, unsigned int a3)
{
  unsigned int v6; // w24
  char *v7; // x22
  __int64 v8; // x24
  __int64 v9; // x1
  int v10; // w3
  __int64 v11; // x23
  unsigned int v12; // w0
  __int64 v13; // x0
  _BYTE *v14; // x4
  char *v15; // x20
  __int64 v16; // x27
  int v17; // w28
  unsigned int v18; // w21
  int v19; // w5
  int v20; // w6
  _DWORD *v21; // x1
  int v22; // w0
  __int64 v23; // x20
  __int64 v24; // x0
  __int64 v25; // x0
  __int64 v26; // x0
  __int64 result; // x0
  __int64 v28; // x0
  __int64 v29; // x0
  __int64 v30; // x0
  __int64 v31; // x19
  int v32; // [xsp+60h] [xbp+60h]
  int v33; // [xsp+64h] [xbp+64h]
  _BYTE *v34; // [xsp+68h] [xbp+68h]
  unsigned __int8 v35; // [xsp+7Fh] [xbp+7Fh] BYREF

  v6 = lookup_drv_index(a2);
  v7 = (char *)&_compound_literal_1_2 + 48 * v6;
  rpmh_core_verify(1LL);
  if ( *(_QWORD *)(a1 + 16) && *(_BYTE *)(a1 + 32) )
    rpmh_core_verify(1LL);
  v8 = 8LL * v6;
  rpmh_core_verify(*(_DWORD *)(a1 + 8) <= *((_DWORD *)v7 + 7));
  v9 = rpmh_tcs;
  v10 = *(_DWORD *)(a1 + 8);
  v11 = 24LL * a3;
  *(_QWORD *)(*(_QWORD *)(rpmh_tcs + v8) + v11 + 16) = a1;
  LOBYTE(g_msg[1]) = *(_BYTE *)(*(_QWORD *)(v9 + v8) + v11);
  v12 = *((_DWORD *)v7 + 1);
  rsc_hal_read_back_val = v10;
  rpmh_tcs = (__int64)g_msg_body;
  g_msg[0] = v12;
  v35 = 0;
  v13 = (unsigned int)RscHalIsTCSIdle(v12, g_msg[1], &v35) == 0;
  rpmh_core_verify(v13);
  rpmh_core_verify(v35);
  qtiseclib_cb_memset(g_msg_body, 0LL, 256LL);
  v14 = &unk_31000;
  while ( *(_DWORD *)(a1 + 8) > 0x10u )
    ;
  v15 = g_msg_body;
  v16 = 0LL;
  v17 = 0;
  v18 = 0;
  v19 = 8;
  v20 = 1;
  while ( *(_DWORD *)(a1 + 8) > v18 )
  {
    *v15 = v18;
    v15[1] = BYTE2(*(_DWORD *)(*(_QWORD *)a1 + v16));
    v21 = (_DWORD *)(*(_QWORD *)a1 + v16);
    *((_WORD *)v15 + 1) = *v21;
    v22 = v21[1];
    v15[8] = v19;
    *((_DWORD *)v15 + 1) = v22;
    v17 |= v20 << v18;
    if ( *(_DWORD *)(*(_QWORD *)a1 + v16 + 4) != 2 )
    {
      v32 = v20;
      v33 = v19;
      v34 = v14;
      *((_DWORD *)v15 + 3) = rpmh_resource_command_val_at_rpmh(
                               *(_DWORD *)(*(_QWORD *)a1 + v16),
                               a2,
                               *(_DWORD *)(a1 + 28),
                               *(_BYTE *)(a1 + 32));
      v20 = v32;
      v19 = v33;
      v14 = v34;
    }
    ++v18;
    v15 += 16;
    v16 += 8LL;
  }
  v23 = (__int64)(v14 + 2272);
  v24 = (unsigned int)RscHalConfigureCmdCompletion(*((_DWORD *)v7 + 1), v14[2276], *(_DWORD *)(a1 + 12)) == 0;
  rpmh_core_verify(v24);
  v25 = (unsigned int)RscHalToggleTCSCmd(*((_DWORD *)v7 + 1), *(_BYTE *)(v23 + 4), v17) == 0;
  rpmh_core_verify(v25);
  v26 = (unsigned int)RscHalSetupTCS(v23) == 0;
  rpmh_core_verify(v26);
  result = *(unsigned __int8 *)(a1 + 32);
  if ( *(_BYTE *)(a1 + 32) )
  {
    v28 = (unsigned int)RscHalClearAMCFinishedIRQ(*((_DWORD *)v7 + 1), *(unsigned __int8 *)(v23 + 4)) == 0;
    rpmh_core_verify(v28);
    v29 = (unsigned int)RscHalEnableAMCFinishedIRQ(*((_DWORD *)v7 + 1), *(unsigned __int8 *)(v23 + 4)) == 0;
    rpmh_core_verify(v29);
    v30 = (unsigned int)RscHalTriggerTCS(*((_DWORD *)v7 + 1), *(_BYTE *)(v23 + 4)) == 0;
    rpmh_core_verify(v30);
    v31 = *(_QWORD *)(rpmh_tcs + v8);
    *(_QWORD *)(v31 + v11 + 8) = rpmh_get_timestamp();
    return rpmh_core_verify(1LL);
  }
  return result;
}
// EB14: using guessed type __int64 rpmh_get_timestamp(void);
// 318E0: using guessed type int g_msg[6];
// 318E8: using guessed type int rsc_hal_read_back_val;
// 318F0: using guessed type __int64 rpmh_tcs;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000F714) ----------------------------------------------------
__int64 __fastcall is_tcs_stuck(int a1)
{
  __int64 v1; // x19
  unsigned int v2; // w22
  unsigned int v3; // w0
  char *v4; // x20
  __int64 v5; // x23
  __int64 v6; // x21
  __int64 v7; // x0
  char v9; // [xsp+6Fh] [xbp+6Fh] BYREF

  v1 = 0LL;
  v2 = 0;
  v3 = lookup_drv_index(a1);
  v4 = (char *)&_compound_literal_1_2 + 48 * v3;
  v5 = 4LL * v3;
  v6 = 8LL * v3;
  while ( **(_DWORD **)(*((_QWORD *)v4 + 5) + 8LL * *(unsigned int *)(tcs_mode + v5)) > (unsigned int)v1 )
  {
    v7 = (unsigned int)RscHalIsTCSIdle(*((_DWORD *)v4 + 1), v4[20] + (unsigned __int8)v1, &v9) == 0;
    rpmh_core_verify(v7);
    if ( !v9
      && rpmh_get_timestamp() > (unsigned __int64)(*(_QWORD *)(*(_QWORD *)(rpmh_tcs + v6) + 24 * v1 + 8) + 192000LL) )
    {
      v2 = 1;
      rpmh_core_verify(1LL);
    }
    ++v1;
  }
  return v2;
}
// EB14: using guessed type __int64 rpmh_get_timestamp(void);
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000F808) ----------------------------------------------------
__int64 __fastcall tcs_size(int a1)
{
  return *((unsigned int *)&_compound_literal_1_2 + 12 * (unsigned int)lookup_drv_index(a1) + 7);
}

//----- (000000000000F834) ----------------------------------------------------
__int64 __fastcall tcs_slots_available(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // w20
  char *v6; // x19
  unsigned int v7; // w2
  __int64 result; // x0
  __int64 v9; // x1
  _QWORD *v10; // x20
  __int64 v11; // x1
  __int64 v12; // x4

  v5 = lookup_drv_index(a1);
  v6 = (char *)&_compound_literal_1_2 + 48 * v5;
  rpmh_core_verify(*((_DWORD *)v6 + 7) >= a3);
  if ( a2 == 1 )
  {
    v9 = *(_QWORD *)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v5));
    v7 = *(_DWORD *)(v9 + 4);
    result = *(unsigned int *)(v9 + 8);
  }
  else if ( a2 == 2 )
  {
    v7 = *((_DWORD *)v6 + 6);
    result = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v5)) + 4LL);
  }
  else
  {
    rpmh_core_verify(0LL);
    v7 = 0;
    result = 0LL;
  }
  v10 = (_QWORD *)(rpmh_tcs + 8LL * v5);
  v11 = 24LL * (int)result;
  while ( v7 > (unsigned int)result )
  {
    v12 = *(_QWORD *)(*v10 + v11 + 16);
    if ( !v12 )
      return result;
    v11 += 24LL;
    if ( a3 <= *((_DWORD *)v6 + 7) - *(_DWORD *)(v12 + 8) )
      return result;
    result = (unsigned int)(result + 1);
  }
  return 0xFFFFFFFFLL;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000F934) ----------------------------------------------------
__int64 __fastcall tcs_prepare_sleep_add_cmd_set(int *a1, int a2)
{
  unsigned int v4; // w19
  int v5; // w0
  char *v6; // x21
  __int64 v7; // x19
  __int64 v8; // x0
  unsigned __int64 *v9; // x22
  unsigned __int64 v10; // x0
  __int64 v11; // x2
  int v12; // w5
  int v13; // w2
  __int64 v14; // x1
  int v15; // w0
  __int64 v16; // x0
  int *v17; // x3
  _DWORD *v18; // x7
  unsigned int v19; // w0
  int v20; // w3
  int v21; // w2

  v4 = lookup_drv_index(a2);
  v5 = tcs_slots_available(a2, *a1, a1[1]);
  if ( v5 == -1 )
    return 0LL;
  v6 = (char *)&_compound_literal_1_2 + 48 * v4;
  v7 = *(_QWORD *)(rpmh_tcs + 8LL * v4) + 24LL * v5;
  rpmh_core_verify_ptr(v7);
  rpmh_core_verify(*(_DWORD *)(v7 + 4) == 3);
  if ( !*(_QWORD *)(v7 + 16) )
  {
    v8 = rpmh_malloc(0x30u);
    *(_QWORD *)(v7 + 16) = v8;
    rpmh_core_verify_ptr(v8);
    qtiseclib_cb_memset(*(_QWORD *)(v7 + 16), 0LL, 48LL);
    v9 = *(unsigned __int64 **)(v7 + 16);
    v10 = rpmh_malloc(8 * *((_DWORD *)v6 + 7));
    v11 = *((unsigned int *)v6 + 7);
    *v9 = v10;
    qtiseclib_cb_memset(**(_QWORD **)(v7 + 16), 0LL, 8 * v11);
  }
  v12 = a1[1];
  v13 = 0;
  v14 = *(_QWORD *)(v7 + 16);
  while ( 1 )
  {
    v15 = *(_DWORD *)(v14 + 8);
    if ( v13 == v12 )
      break;
    v16 = (unsigned int)(v13 + v15);
    v17 = &a1[3 * v13++];
    v18 = (_DWORD *)(*(_QWORD *)v14 + 8 * v16);
    *v18 = v17[3];
    v18[1] = *((unsigned __int8 *)v17 + 20);
  }
  v19 = v13 + v15;
  v20 = *a1;
  v21 = a1[2];
  *(_BYTE *)(v14 + 32) = 0;
  *(_DWORD *)(v14 + 8) = v19;
  *(_DWORD *)(v14 + 12) = v21;
  *(_DWORD *)(v14 + 28) = v20;
  rpmh_core_verify(v19 <= *((_DWORD *)v6 + 7));
  return 1LL;
}
// 318F0: using guessed type __int64 rpmh_tcs;
// 31918: using guessed type __int64 __fastcall qtiseclib_cb_memset(_QWORD, _QWORD, _QWORD);

//----- (000000000000FA8C) ----------------------------------------------------
__int64 __fastcall is_amc_free(int a1)
{
  __int64 v1; // x19
  __int64 v2; // x21
  char *v3; // x20
  _QWORD *v4; // x19
  __int64 i; // x0
  __int64 v6; // x2

  v1 = (unsigned int)lookup_drv_index(a1);
  v2 = 4 * v1;
  v3 = (char *)&_compound_literal_1_2 + 48 * v1;
  rpmh_core_verify(**(_DWORD **)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4 * v1)) != 0);
  v4 = (_QWORD *)(rpmh_tcs + 8 * v1);
  for ( i = 0LL; i != 24LL * **(unsigned int **)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + v2)); i += 24LL )
  {
    v6 = *v4 + i;
    if ( !*(_DWORD *)(v6 + 4) )
      return 1LL;
  }
  return 0LL;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000FB44) ----------------------------------------------------
bool __fastcall is_amc_finished(int a1)
{
  unsigned int v1; // w0
  __int64 v2; // x0
  int v4; // [xsp+1Ch] [xbp+1Ch] BYREF

  v1 = lookup_drv_index(a1);
  v2 = (unsigned int)RscHalCheckAMCFinishedIRQ(*((_DWORD *)&_compound_literal_1_2 + 12 * v1 + 1), &v4) == 0;
  rpmh_core_verify(v2);
  return v4 != 0;
}

//----- (000000000000FB90) ----------------------------------------------------
__int64 __fastcall get_finished_drv(int a1)
{
  unsigned int v2; // w19
  __int64 v3; // x0
  int v5; // w0
  __int64 v6; // x2
  unsigned int *v7; // x19
  _QWORD *v8; // x1
  int v9; // w3
  bool v10; // cc
  int v11; // [xsp+3Ch] [xbp+3Ch] BYREF

  v2 = lookup_drv_index(a1);
  v3 = (unsigned int)RscHalCheckAMCFinishedIRQ(*((_DWORD *)&_compound_literal_1_2 + 12 * v2 + 1), &v11) == 0;
  rpmh_core_verify(v3);
  if ( v11 )
  {
    v5 = 31 - rpmh_clz(v11);
    v6 = 0LL;
    v7 = (unsigned int *)(tcs_mode + 4LL * v2);
    while ( v6 != 48 )
    {
      v8 = (_QWORD *)((char *)&_compound_literal_1_2 + v6);
      v9 = v5 - *(_DWORD *)((char *)&_compound_literal_1_2 + v6 + 20);
      v10 = *(_DWORD *)((char *)&_compound_literal_1_2 + v6 + 4) != a1 || v9 < 0;
      if ( !v10 && (unsigned int)v9 < **(_DWORD **)(v8[5] + 8LL * *v7) )
        return *(unsigned int *)v8;
      v6 += 48LL;
    }
  }
  return 0x3FFFFFFFLL;
}
// 318D8: using guessed type __int64 tcs_mode;

//----- (000000000000FC6C) ----------------------------------------------------
__int64 __fastcall tcs_finish_amc(__int64 a1, int a2, int a3)
{
  __int64 result; // x0
  unsigned __int8 *v7; // x19

  result = get_finished_amc(a2);
  if ( result )
  {
    v7 = (unsigned __int8 *)result;
    rpmh_core_verify_ptr(*(_QWORD *)(result + 16));
    return tcs_clean_up(a1, v7, a2, a3);
  }
  return result;
}

//----- (000000000000FCD0) ----------------------------------------------------
__int64 __fastcall tcs_finish_active_amc(_QWORD *a1, __int64 a2, int a3)
{
  __int64 finished_amc; // x0
  __int64 v7; // x19
  unsigned __int8 *v8; // x20
  __int64 v9; // x0

  finished_amc = get_finished_amc(a3);
  if ( !finished_amc )
    return 0LL;
  v7 = *(_QWORD *)(finished_amc + 16);
  v8 = (unsigned __int8 *)finished_amc;
  rpmh_core_verify_ptr(v7);
  v9 = *(_QWORD *)(v7 + 16);
  LODWORD(v7) = *(_DWORD *)(v7 + 24);
  *a1 = v9;
  tcs_clean_up(a2, v8, a3, 0);
  return (unsigned int)v7;
}

//----- (000000000000FD4C) ----------------------------------------------------
__int64 __fastcall tcs_send(__int64 a1, int a2)
{
  __int64 v4; // x19
  __int64 v5; // x22
  char *v6; // x20
  _QWORD *v7; // x19
  __int64 v8; // x0
  unsigned int v9; // w2
  __int64 v10; // x3

  v4 = (unsigned int)lookup_drv_index(a2);
  v5 = 4 * v4;
  v6 = (char *)&_compound_literal_1_2 + 48 * v4;
  rpmh_core_verify(**(_DWORD **)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4 * v4)) != 0);
  v7 = (_QWORD *)(rpmh_tcs + 8 * v4);
  v8 = 0LL;
  while ( 1 )
  {
    v9 = v8;
    if ( **(_DWORD **)(*((_QWORD *)v6 + 5) + 8LL * *(unsigned int *)(tcs_mode + v5)) == v8 )
      break;
    v10 = *v7 + 24 * v8++;
    if ( !*(_DWORD *)(v10 + 4) )
    {
      *(_DWORD *)(v10 + 4) = 1;
      tcs_send_internal(a1, a2, v9);
      return 1LL;
    }
  }
  return 0LL;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000FE2C) ----------------------------------------------------
__int64 __fastcall tcs_clean_sleep_wake(int a1)
{
  unsigned int v1; // w0
  char *v2; // x19
  __int64 v3; // x22
  unsigned int v4; // w20
  __int64 i; // x21
  __int64 result; // x0
  __int64 v7; // x23
  __int64 v8; // x0
  unsigned __int8 v9; // w1
  __int64 v10; // x0

  v1 = lookup_drv_index(a1);
  v2 = (char *)&_compound_literal_1_2 + 48 * v1;
  v3 = 8LL * v1;
  v4 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v1)) + 8LL);
  for ( i = 24LL * (int)v4; ; i += 24LL )
  {
    result = *((unsigned int *)v2 + 6);
    if ( (unsigned int)result <= v4 )
      break;
    v7 = *(_QWORD *)(rpmh_tcs + v3) + i;
    v8 = *(_QWORD *)(v7 + 16);
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 8) )
      {
        rpmh_core_verify((unsigned int)(*(_DWORD *)(v8 + 28) - 1) <= 1);
        rpmh_clean_cmd(*(_QWORD **)(v7 + 16), *((_DWORD *)v2 + 7));
      }
    }
    v9 = v4++;
    v10 = (unsigned int)RscHalToggleTCSCmd(*((_DWORD *)v2 + 1), v9, 0) == 0;
    rpmh_core_verify(v10);
  }
  return result;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000FF08) ----------------------------------------------------
__int64 __fastcall tcs_prepare_sleep_commit(int a1)
{
  unsigned int v2; // w0
  char *v3; // x22
  __int64 v4; // x19
  unsigned int v5; // w20
  __int64 i; // x21
  __int64 result; // x0
  __int64 v8; // x0

  v2 = lookup_drv_index(a1);
  v3 = (char *)&_compound_literal_1_2 + 48 * v2;
  v4 = 8LL * v2;
  v5 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 8LL * *(unsigned int *)(tcs_mode + 4LL * v2)) + 8LL);
  for ( i = 24LL * (int)v5; ; i += 24LL )
  {
    result = *((unsigned int *)v3 + 6);
    if ( (unsigned int)result <= v5 )
      break;
    v8 = *(_QWORD *)(*(_QWORD *)(rpmh_tcs + v4) + i + 16);
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 8) )
        tcs_send_internal(v8, a1, v5);
    }
    ++v5;
  }
  return result;
}
// 318D8: using guessed type __int64 tcs_mode;
// 318F0: using guessed type __int64 rpmh_tcs;

//----- (000000000000FFBC) ----------------------------------------------------
__int64 __fastcall isContextInitialized(_BYTE *a1, unsigned int a2)
{
  __int64 result; // x0

  if ( a2 <= 2 )
  {
    if ( a1 )
    {
      result = 4294967290LL;
      if ( *a1 )
      {
        if ( a1[32 * a2 + 28] )
          return 0LL;
        else
          return 4294967290LL;
      }
    }
    else
    {
      return 4294967290LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000001001C) ----------------------------------------------------
char *rscHalGetContext()
{
  return GlobalRscHalCtxt;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010028) ----------------------------------------------------
__int64 __fastcall rscHalGetNumTcs(unsigned __int64 a1, char a2, _DWORD *a3)
{
  bool v3; // zf

  if ( a1 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  if ( !a2 )
  {
    LODWORD(a1) = *(_DWORD *)(a1 + 12) & 0x3F;
    goto LABEL_11;
  }
  if ( a2 == 2 )
  {
    a1 = ((unsigned __int64)*(unsigned int *)(a1 + 131084) >> 12) & 0x3F;
LABEL_11:
    *a3 = a1;
    return 0LL;
  }
  rpmh_core_verify(1LL);
  return 4294967288LL;
}

//----- (0000000000010098) ----------------------------------------------------
__int64 __fastcall rscHalGetNumCmdsPerTcs(__int64 a1, unsigned __int8 a2, _DWORD *a3)
{
  bool v3; // zf

  if ( a1 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  else if ( a2 > 2u )
  {
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
  else
  {
    *a3 = *(_DWORD *)(((unsigned __int64)a2 << 16) + a1 + 12) >> 27;
    return 0LL;
  }
}

//----- (00000000000100F8) ----------------------------------------------------
__int64 __fastcall rscHalGetDrvInfo(__int64 a1)
{
  unsigned int i; // w21
  unsigned int *v4; // x23
  __int64 v5; // x22
  char *v6; // x20
  __int64 v7; // x1
  unsigned __int64 v8; // x0
  int v9; // [xsp+58h] [xbp+58h] BYREF
  int v10; // [xsp+5Ch] [xbp+5Ch] BYREF

  v9 = 0;
  v10 = 0;
  if ( a1 && *(_DWORD *)(a1 + 4) )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= *(_DWORD *)(a1 + 4) )
        return 0LL;
      v4 = (unsigned int *)off_1D268;
      v5 = 12LL * i;
      v6 = (char *)off_1D268 + v5;
      v7 = a1 + 32LL * *(unsigned int *)((char *)off_1D268 + v5);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)((char *)off_1D268 + v5);
      v8 = *((unsigned int *)v6 + 1);
      *(_QWORD *)(v7 + 16) = v8;
      *(_DWORD *)(v7 + 24) = (unsigned __int8)v6[8];
      if ( (unsigned int)rscHalGetNumTcs(v8, v6[8], &v9) )
        break;
      *(_DWORD *)(a1 + 32LL * v4[3 * i] + 32) = v9;
      if ( (unsigned int)rscHalGetNumCmdsPerTcs(*((unsigned int *)v6 + 1), v6[8], &v10) )
        break;
      *(_DWORD *)(a1 + 32LL * v4[(unsigned __int64)v5 / 4] + 36) = v10;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
}
// 1D268: using guessed type void *off_1D268;

//----- (00000000000101F8) ----------------------------------------------------
__int64 __fastcall rscHalGetChipsetMappingTable(__int64 a1)
{
  if ( a1 )
  {
    *(_DWORD *)(a1 + 4) = DrvBaseAddressMappingTable_subsystem;
    return 0LL;
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}
// 1D260: using guessed type int DrvBaseAddressMappingTable_subsystem;

//----- (000000000001022C) ----------------------------------------------------
__int64 __fastcall RscHalRegisterDrv(unsigned int a1)
{
  __int64 result; // x0
  unsigned int v3; // w2
  _BYTE *v4; // x1

  if ( a1 > 2 )
    goto LABEL_2;
  v3 = 0;
  if ( !GlobalRscHalCtxt[0] )
  {
    *(_DWORD *)&GlobalRscHalCtxt[4] = DrvBaseAddressMappingTable_subsystem;
    result = rscHalGetDrvInfo((__int64)GlobalRscHalCtxt);
    v3 = result;
    if ( (result & 0x80000000) != 0 )
      return result;
    GlobalRscHalCtxt[0] = 1;
  }
  v4 = &GlobalRscHalCtxt[32 * a1];
  if ( !*((_QWORD *)v4 + 2) )
  {
LABEL_2:
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  v4[28] = 1;
  return v3;
}
// 1D260: using guessed type int DrvBaseAddressMappingTable_subsystem;
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000102B8) ----------------------------------------------------
__int64 __fastcall RscHalVersionID(unsigned int a1, int *a2)
{
  unsigned int v5; // w20

  if ( a2 )
  {
    v5 = isContextInitialized(GlobalRscHalCtxt, a1);
    if ( v5 )
    {
      rpmh_core_verify(1LL);
      return v5;
    }
    else
    {
      *a2 = *(_DWORD *)(((unsigned __int64)(unsigned __int16)*(_DWORD *)&GlobalRscHalCtxt[32 * a1 + 24] << 16)
                      + *(_QWORD *)&GlobalRscHalCtxt[32 * a1 + 16]) & 0xFFFFFF;
      return 0LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010344) ----------------------------------------------------
__int64 __fastcall RscHalReadConfig(unsigned int a1, _DWORD *a2, _DWORD *a3)
{
  bool v3; // zf
  unsigned int v8; // w0
  unsigned int v9; // w20
  _BYTE *v10; // x19

  if ( a2 )
    v3 = a3 == 0LL;
  else
    v3 = 1;
  if ( v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  else
  {
    v8 = isContextInitialized(GlobalRscHalCtxt, a1);
    v9 = v8;
    if ( v8 )
    {
      rpmh_core_verify(1LL);
      return v9;
    }
    else
    {
      v10 = &GlobalRscHalCtxt[32 * a1];
      *a2 = *((_DWORD *)v10 + 8);
      *a3 = *((_DWORD *)v10 + 9);
      return 0LL;
    }
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000103DC) ----------------------------------------------------
__int64 __fastcall RscHalIsePCBTimedOut(unsigned int a1, _BYTE *a2)
{
  unsigned int v4; // w21
  _BYTE *v5; // x19
  __int64 v6; // x1
  int v7; // w0

  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else if ( a2 )
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    v6 = *((_QWORD *)v5 + 2);
    if ( *((_DWORD *)v5 + 6) )
      v7 = *(_DWORD *)(v6 + 208 + ((unsigned __int64)(unsigned __int16)*((_DWORD *)v5 + 6) << 16));
    else
      v7 = *(_DWORD *)(v6 + 208);
    *a2 = v7 & 1;
  }
  else
  {
    v4 = -5;
    rpmh_core_verify(1LL);
  }
  return v4;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010474) ----------------------------------------------------
__int64 __fastcall RscHalClearePCBTimedOut(unsigned int a1)
{
  unsigned int v2; // w21
  _BYTE *v3; // x19

  v2 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v2 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v3 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v3 + 6) )
    {
      v2 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v3 + 2) + 212LL) = 1;
    }
  }
  return v2;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000104F0) ----------------------------------------------------
__int64 __fastcall RscHalToggleePCBTimeOut(unsigned int a1, char a2)
{
  unsigned int v4; // w21
  _BYTE *v5; // x19

  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v5 + 6) )
    {
      v4 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) = ((a2 & 1) << 20) | (unsigned __int16)*(_DWORD *)(*((_QWORD *)v5 + 2)
                                                                                                + 216LL);
    }
  }
  return v4;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (000000000001057C) ----------------------------------------------------
__int64 __fastcall RscHalUpdateePCBTimeOutThreshold(unsigned int a1, unsigned __int16 a2)
{
  int v3; // w22
  unsigned int v4; // w21
  _BYTE *v5; // x19

  v3 = a2;
  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    if ( *((_DWORD *)v5 + 6) )
    {
      v4 = -7;
      rpmh_core_verify(1LL);
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) = *(_DWORD *)(*((_QWORD *)v5 + 2) + 216LL) & 0x100000 | v3;
    }
  }
  return v4;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010604) ----------------------------------------------------
__int64 __fastcall RscHalIsTCSIdle(unsigned int a1, unsigned __int8 a2, _BYTE *a3)
{
  unsigned int v3; // w19
  char *v4; // x21
  unsigned int v5; // w1
  unsigned int v6; // w1
  unsigned int v8; // w20
  int v9; // w1
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x19

  v3 = a2;
  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = *((_DWORD *)v4 + 8);
  if ( v5 && v5 > v3 )
  {
    v6 = -5;
    if ( a3 )
    {
      v8 = isContextInitialized(GlobalRscHalCtxt, a1);
      if ( v8 )
      {
        rpmh_core_verify(1LL);
        return v8;
      }
      v9 = *((_DWORD *)v4 + 6);
      v10 = *((_QWORD *)v4 + 2);
      if ( v9 )
      {
        if ( v9 != 2 )
        {
          rpmh_core_verify(1LL);
          return (unsigned int)-8;
        }
        v11 = v10 + 134424;
        v12 = (int)(672 * v3);
      }
      else
      {
        v11 = v10 + 3352;
        v12 = (int)(672 * v3);
      }
      v6 = 0;
      *a3 = *(_BYTE *)(v12 + v11) & 1;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v6;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000106E8) ----------------------------------------------------
__int64 __fastcall RscHalTriggerTCS(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) &= 0x10000u;
      *(_DWORD *)(v11 + v10) = *(_DWORD *)(v11 + v10) & 0x10000 | 0x1000000;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010808) ----------------------------------------------------
__int64 __fastcall RscHalConvertTCStoAMC(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) = *(_DWORD *)(v11 + v10) & 0x1000000 | 0x10000;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (000000000001091C) ----------------------------------------------------
__int64 __fastcall RscHalConvertAMCtoTCS(unsigned int a1, unsigned __int8 a2)
{
  _BYTE *v3; // x21
  unsigned int v4; // w19
  unsigned int v5; // w1
  unsigned int IsTCSIdle; // w20
  int v8; // w1
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x19
  char v12; // [xsp+4Fh] [xbp+4Fh] BYREF

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = a2;
  v12 = 0;
  v5 = *((_DWORD *)v3 + 8);
  if ( !v5 || v5 <= v4 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v4, &v12);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v12 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      v10 = v9 + 3348;
      v11 = (int)(672 * v4);
      goto LABEL_12;
    }
    if ( v8 == 2 )
    {
      v10 = v9 + 134420;
      v11 = (int)(672 * v4);
LABEL_12:
      *(_DWORD *)(v11 + v10) &= 0x1000000u;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010A2C) ----------------------------------------------------
__int64 __fastcall RscHalToggleTCSCmd(unsigned int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  _BYTE *v4; // x22
  unsigned int v5; // w19
  unsigned int v6; // w1
  unsigned int IsTCSIdle; // w20
  int v10; // w1
  __int64 v11; // x0
  __int64 v12; // x0
  __int64 v13; // x19
  char v14; // [xsp+4Fh] [xbp+4Fh] BYREF

  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = a2;
  v14 = 0;
  v6 = *((_DWORD *)v4 + 8);
  if ( !v6 || v6 <= v5 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(a1, v5, &v14);
  if ( IsTCSIdle )
    goto LABEL_14;
  if ( !v14 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  IsTCSIdle = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( IsTCSIdle )
  {
LABEL_14:
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  else
  {
    v10 = *((_DWORD *)v4 + 6);
    v11 = *((_QWORD *)v4 + 2);
    if ( !v10 )
    {
      v12 = v11 + 3356;
      v13 = (int)(672 * v5);
      goto LABEL_12;
    }
    if ( v10 == 2 )
    {
      v12 = v11 + 134428;
      v13 = (int)(672 * v5);
LABEL_12:
      *(_DWORD *)(v13 + v12) = a3;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010B40) ----------------------------------------------------
__int64 __fastcall RscHalEnableAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v3; // x20
  unsigned int v4; // w1
  unsigned int v7; // w0
  unsigned int v8; // w19
  int v9; // w0
  __int64 v10; // x2

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 <= a2 || v4 == 0 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  v7 = isContextInitialized(GlobalRscHalCtxt, a1);
  v8 = v7;
  if ( v7 )
  {
    rpmh_core_verify(1LL);
    return v8;
  }
  else
  {
    v9 = *((_DWORD *)v3 + 6);
    v10 = *((_QWORD *)v3 + 2);
    if ( !v9 )
    {
      *(_DWORD *)(v10 + 3328) = *(_DWORD *)(v10 + 3328) & 0xF & ~(1 << a2) | (1 << a2);
      return 0LL;
    }
    if ( v9 == 2 )
    {
      *(_DWORD *)(v10 + 134400) = (unsigned __int8)*(_DWORD *)(v10 + 134400) & ~(1 << a2) | (1 << a2);
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010C24) ----------------------------------------------------
__int64 __fastcall RscHalDisableAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v2; // x21
  unsigned int v3; // w3
  char v5; // w20
  unsigned int v6; // w19
  int v7; // w1
  __int64 v8; // x0

  v2 = &GlobalRscHalCtxt[32 * a1];
  v3 = *((_DWORD *)v2 + 8);
  if ( v3 <= a2 || v3 == 0 )
    return 4294967294LL;
  v5 = a2;
  v6 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v6 )
  {
    rpmh_core_verify(1LL);
    return v6;
  }
  else
  {
    v7 = *((_DWORD *)v2 + 6);
    v8 = *((_QWORD *)v2 + 2);
    if ( !v7 )
    {
      *(_DWORD *)(v8 + 3328) &= 0xF & ~(1 << v5);
      return 0LL;
    }
    if ( v7 == 2 )
    {
      *(_DWORD *)(v8 + 134400) = (unsigned __int8)*(_DWORD *)(v8 + 134400) & ~(1 << v5);
      return 0LL;
    }
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010CF0) ----------------------------------------------------
__int64 __fastcall RscHalCheckAMCFinishedIRQ(unsigned int a1, int *a2)
{
  unsigned int v4; // w20
  _BYTE *v5; // x19
  int v6; // w1
  __int64 v7; // x0
  int v8; // w0

  if ( !a2 )
    return 4294967291LL;
  v4 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v4 )
  {
    rpmh_core_verify(1LL);
    return v4;
  }
  else
  {
    v5 = &GlobalRscHalCtxt[32 * a1];
    v6 = *((_DWORD *)v5 + 6);
    v7 = *((_QWORD *)v5 + 2);
    if ( !v6 )
    {
      v8 = *(_DWORD *)(v7 + 3332) & 0xF;
      goto LABEL_7;
    }
    if ( v6 == 2 )
    {
      v8 = (unsigned __int8)*(_DWORD *)(v7 + 134404);
LABEL_7:
      *a2 = v8;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010DA4) ----------------------------------------------------
__int64 __fastcall RscHalClearAMCFinishedIRQ(unsigned int a1, unsigned int a2)
{
  _BYTE *v3; // x20
  unsigned int v4; // w1
  bool v5; // cc
  unsigned int v7; // w19
  int v8; // w1
  __int64 v9; // x0

  v3 = &GlobalRscHalCtxt[32 * a1];
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 )
    v5 = v4 > a2;
  else
    v5 = 0;
  if ( !v5 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  v7 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v7 )
  {
    rpmh_core_verify(1LL);
    return v7;
  }
  else
  {
    v8 = *((_DWORD *)v3 + 6);
    v9 = *((_QWORD *)v3 + 2);
    if ( !v8 )
    {
      *(_DWORD *)(v9 + 3336) = 1 << a2;
      return 0LL;
    }
    if ( v8 == 2 )
    {
      *(_DWORD *)(v9 + 134408) = 1 << a2;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010E68) ----------------------------------------------------
__int64 __fastcall RscHalCheckTCSCmdTriggerStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4)
{
  unsigned int v4; // w20
  _BYTE *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  int v9; // w19
  unsigned int v11; // w21
  int v12; // w1
  __int64 v13; // x0
  __int64 v14; // x3
  __int64 v15; // x0
  int v16; // w0

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = *((_DWORD *)v5 + 8);
  if ( v6 && v6 > v4 )
  {
    v8 = *((_DWORD *)v5 + 9);
    if ( v8 && (v9 = a3, v8 > a3) )
    {
      v7 = -5;
      if ( a4 )
      {
        v11 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v11 )
        {
          rpmh_core_verify(1LL);
          return v11;
        }
        v12 = *((_DWORD *)v5 + 6);
        v13 = *((_QWORD *)v5 + 2);
        v14 = v13 + 3388;
        v15 = v13 + 134460;
        if ( v12 )
        {
          if ( v12 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          v16 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v15);
        }
        else
        {
          v16 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v14);
        }
        v7 = 0;
        *a4 = v16 & 1;
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000010F9C) ----------------------------------------------------
__int64 __fastcall RscHalCheckTCSCmdIssueStatus(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _BYTE *a4)
{
  unsigned int v4; // w20
  _DWORD *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  unsigned int v10; // w21
  int v11; // w1

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = v5[8];
  if ( v6 && v6 > v4 )
  {
    v8 = v5[9];
    if ( v8 && v8 > a3 )
    {
      v7 = -5;
      if ( a4 )
      {
        v10 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v10 )
        {
          rpmh_core_verify(1LL);
          return v10;
        }
        else
        {
          v11 = v5[6];
          if ( v11 && v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          else
          {
            *a4 = 0;
            return 0;
          }
        }
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000110CC) ----------------------------------------------------
__int64 __fastcall RscHalCheckTCSCmdCompletionStatus(
        unsigned int a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        _BYTE *a4)
{
  unsigned int v4; // w20
  _DWORD *v5; // x22
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  unsigned int v10; // w21
  int v11; // w1

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = v5[8];
  if ( v6 && v6 > v4 )
  {
    v8 = v5[9];
    if ( v8 && v8 > a3 )
    {
      v7 = -5;
      if ( a4 )
      {
        v10 = isContextInitialized(GlobalRscHalCtxt, a1);
        if ( v10 )
        {
          rpmh_core_verify(1LL);
          return v10;
        }
        else
        {
          v11 = v5[6];
          if ( v11 && v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          else
          {
            *a4 = 0;
            return 0;
          }
        }
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000111FC) ----------------------------------------------------
__int64 __fastcall RscHalReadResponseData(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, _DWORD *a4)
{
  unsigned int v4; // w20
  _BYTE *v5; // x21
  unsigned int v6; // w1
  unsigned int v7; // w1
  unsigned int v8; // w1
  int v9; // w19
  int v11; // w1
  __int64 v12; // x0
  __int64 v13; // x3
  __int64 v14; // x0
  int v15; // w0

  v4 = a2;
  v5 = &GlobalRscHalCtxt[32 * a1];
  v6 = *((_DWORD *)v5 + 8);
  if ( v6 && v6 > v4 )
  {
    v8 = *((_DWORD *)v5 + 9);
    if ( v8 && (v9 = a3, v8 > a3) )
    {
      v7 = -5;
      if ( a4 )
      {
        if ( (unsigned int)isContextInitialized(GlobalRscHalCtxt, a1) )
        {
          rpmh_core_verify(1LL);
          return (unsigned int)-6;
        }
        v11 = *((_DWORD *)v5 + 6);
        v12 = *((_QWORD *)v5 + 2);
        v13 = v12 + 3392;
        v14 = v12 + 134464;
        if ( v11 )
        {
          if ( v11 != 2 )
          {
            rpmh_core_verify(1LL);
            return (unsigned int)-8;
          }
          v15 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v14);
        }
        else
        {
          v15 = *(_DWORD *)((int)(672 * v4) + (__int64)(20 * v9) + v13);
        }
        v7 = 0;
        *a4 = v15;
      }
    }
    else
    {
      rpmh_core_verify(1LL);
      return (unsigned int)-3;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return (unsigned int)-2;
  }
  return v7;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (0000000000011320) ----------------------------------------------------
__int64 __fastcall RscHalConfigureCmdCompletion(unsigned int a1, unsigned __int8 a2, __int16 a3)
{
  unsigned int v3; // w19
  _BYTE *v4; // x22
  unsigned int v5; // w1
  int v7; // w21
  unsigned int v8; // w20
  int v9; // w1
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x19

  v3 = a2;
  v4 = &GlobalRscHalCtxt[32 * a1];
  v5 = *((_DWORD *)v4 + 8);
  if ( !v5 || v5 <= v3 )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  LOWORD(v7) = a3;
  v8 = isContextInitialized(GlobalRscHalCtxt, a1);
  if ( v8 )
  {
    rpmh_core_verify(1LL);
    return v8;
  }
  else
  {
    v9 = *((_DWORD *)v4 + 6);
    v10 = *((_QWORD *)v4 + 2);
    if ( !v9 )
    {
      v7 = (unsigned __int16)v7;
      v11 = v10 + 3344;
      v12 = (int)(672 * v3);
      goto LABEL_9;
    }
    if ( v9 == 2 )
    {
      v7 = (unsigned __int16)v7;
      v11 = v10 + 134416;
      v12 = (int)(672 * v3);
LABEL_9:
      *(_DWORD *)(v12 + v11) = v7;
      return 0LL;
    }
    rpmh_core_verify(1LL);
    return 4294967288LL;
  }
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000113F8) ----------------------------------------------------
__int64 __fastcall rscHalSetupDrv0Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  unsigned int v4; // w7
  __int64 v5; // x0

  if ( a1 )
  {
    if ( a3 )
    {
      v4 = *((_DWORD *)a3 + 1);
      v5 = 672 * a2 + a1;
      *(_DWORD *)(20LL * *a3 + 3380 + v5) = ((a3[1] & 7) << 16) | (unsigned __int16)*(_DWORD *)(20LL * *a3 + 3380 + v5);
      *(_DWORD *)(20LL * *a3 + 3380 + v5) = *(_DWORD *)(20LL * *a3 + 3380 + v5) & 0x70000 | *((unsigned __int16 *)a3 + 1);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x10F | ((v4 < 2) << 16);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x1000F | ((v4 != 0) << 8);
      *(_DWORD *)(20LL * *a3 + 3376 + v5) = a3[8] & 0xF | *(_DWORD *)(20LL * *a3 + 3376 + v5) & 0x10100;
      *(_DWORD *)(20LL * *a3 + 3384 + v5) = *((_DWORD *)a3 + 3);
      return 0LL;
    }
    else
    {
      rpmh_core_verify(1LL);
      return 4294967291LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}

//----- (0000000000011520) ----------------------------------------------------
__int64 __fastcall rscHalSetupDrv2Tcs(__int64 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  unsigned int v4; // w7
  __int64 v5; // x0

  if ( a1 )
  {
    if ( a3 )
    {
      v4 = *((_DWORD *)a3 + 1);
      v5 = 672 * a2 + a1;
      *(_DWORD *)(20LL * *a3 + 134452 + v5) = ((a3[1] & 7) << 16) | (unsigned __int16)*(_DWORD *)(20LL * *a3
                                                                                                + 134452
                                                                                                + v5);
      *(_DWORD *)(20LL * *a3 + 134452 + v5) = *(_DWORD *)(20LL * *a3 + 134452 + v5) & 0x70000 | *((unsigned __int16 *)a3
                                                                                                + 1);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x10F | ((v4 < 2) << 16);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x1000F | ((v4 != 0) << 8);
      *(_DWORD *)(20LL * *a3 + 134448 + v5) = a3[8] & 0xF | *(_DWORD *)(20LL * *a3 + 134448 + v5) & 0x10100;
      *(_DWORD *)(20LL * *a3 + 134456 + v5) = *((_DWORD *)a3 + 3);
      return 0LL;
    }
    else
    {
      rpmh_core_verify(1LL);
      return 4294967291LL;
    }
  }
  else
  {
    rpmh_core_verify(1LL);
    return 4294967290LL;
  }
}

//----- (0000000000011654) ----------------------------------------------------
__int64 __fastcall RscHalSetupTCS(__int64 a1)
{
  __int64 result; // x0
  unsigned int v3; // w0
  _BYTE *v4; // x21
  unsigned int v5; // w2
  unsigned int v6; // w1
  unsigned int IsTCSIdle; // w19
  unsigned __int8 *v8; // x19
  __int64 v9; // x22
  int v10; // w0
  unsigned int v11; // w21
  unsigned int i; // w21
  char v13; // [xsp+3Fh] [xbp+3Fh] BYREF

  v13 = 0;
  if ( !a1 )
  {
    rpmh_core_verify(1LL);
    return 4294967291LL;
  }
  v3 = *(_DWORD *)a1;
  if ( v3 > 2 )
  {
    rpmh_core_verify(1LL);
    return 0xFFFFFFFFLL;
  }
  v4 = &GlobalRscHalCtxt[32 * v3];
  v5 = *((_DWORD *)v4 + 8);
  if ( !v5 || (v6 = *(unsigned __int8 *)(a1 + 4), v5 <= v6) )
  {
    rpmh_core_verify(1LL);
    return 4294967294LL;
  }
  IsTCSIdle = RscHalIsTCSIdle(v3, v6, &v13);
  if ( IsTCSIdle )
  {
    rpmh_core_verify(1LL);
    return IsTCSIdle;
  }
  if ( !v13 )
  {
    rpmh_core_verify(1LL);
    return 4294967287LL;
  }
  v8 = *(unsigned __int8 **)(a1 + 16);
  result = 4294967291LL;
  v9 = *((_QWORD *)v4 + 2);
  if ( v8 && *(_DWORD *)(a1 + 8) )
  {
    v10 = *((_DWORD *)v4 + 6);
    if ( v10 )
    {
      v11 = 0;
      if ( v10 != 2 )
      {
        rpmh_core_verify(1LL);
        return 4294967288LL;
      }
      while ( v11 < *(_DWORD *)(a1 + 8) )
      {
        result = rscHalSetupDrv2Tcs(v9, *(_BYTE *)(a1 + 4), v8);
        if ( (_DWORD)result )
          return result;
        v8 += 16;
        ++v11;
      }
    }
    else
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
      {
        result = rscHalSetupDrv0Tcs(v9, *(_BYTE *)(a1 + 4), v8);
        if ( (_DWORD)result )
          return result;
        v8 += 16;
      }
    }
    return 0LL;
  }
  return result;
}
// 31880: using guessed type _BYTE GlobalRscHalCtxt[104];

//----- (00000000000117B4) ----------------------------------------------------
__int64 __fastcall RscHalCheckTCSIdle_HLOS(unsigned int a1)
{
  unsigned int v1; // w19
  unsigned int i; // w0
  unsigned int j; // w0
  unsigned int k; // w0

  v1 = a1;
  if ( !numTcsPerHLOSDrv )
  {
    if ( (unsigned int)rscHalGetNumTcs(0x18200000uLL, a1, &numTcsPerHLOSDrv) )
    {
      rpmh_core_verify(1LL);
      rpmh_core_verify(0LL);
    }
    rpmh_core_verify(1LL);
    rpmh_core_verify(numTcsPerHLOSDrv != 0);
  }
  if ( v1 == 1 )
    goto LABEL_13;
  if ( !v1 )
  {
    v1 = 1;
    for ( i = 0; i < numTcsPerHLOSDrv; i = (unsigned __int8)(i + 1) )
    {
      v1 = *(_BYTE *)(int)(672 * i + 404753688) & 1;
      if ( (*(_DWORD *)(int)(672 * i + 404753688) & 1) == 0 )
        break;
    }
LABEL_13:
    for ( j = 0; j < numTcsPerHLOSDrv; j = (unsigned __int8)(j + 1) )
    {
      v1 = *(_BYTE *)(int)(672 * j + 404819224) & 1;
      if ( (*(_DWORD *)(int)(672 * j + 404819224) & 1) == 0 )
        break;
    }
    goto LABEL_17;
  }
  if ( v1 != 2 )
  {
    v1 = 1;
    goto LABEL_22;
  }
  v1 = 1;
LABEL_17:
  for ( k = 0; k < numTcsPerHLOSDrv; k = (unsigned __int8)(k + 1) )
  {
    v1 = *(_BYTE *)(int)(672 * k + 404884760) & 1;
    if ( (*(_DWORD *)(int)(672 * k + 404884760) & 1) == 0 )
      break;
  }
LABEL_22:
  rpmh_core_verify(1LL);
  rpmh_core_verify(1LL);
  return v1;
}
// 31614: using guessed type int numTcsPerHLOSDrv;

//----- (0000000000011910) ----------------------------------------------------
__int64 __fastcall rsc_init_base_address(__int64 a1)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 1LL;
  if ( !g_rsc_ss_base )
    g_rsc_ss_base = 394264576LL;
  v2 = *(_QWORD *)(a1 + 24);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    result = 0LL;
    *(_QWORD *)(a1 + 40) = g_rsc_ss_base + v2;
  }
  return result;
}
// 31618: using guessed type __int64 g_rsc_ss_base;

//----- (0000000000011954) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_major_ver(_DWORD *a1)
{
  return (unsigned __int8)BYTE2(*a1);
}

//----- (0000000000011960) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_minor_ver(_DWORD *a1)
{
  return (unsigned __int8)BYTE1(*a1);
}

//----- (000000000001196C) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_step_ver(_DWORD *a1)
{
  return (unsigned __int8)*a1;
}

//----- (0000000000011978) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_solver_cfg(__int64 a1)
{
  return *(_DWORD *)(a1 + 4) & 0x71F1F1F;
}

//----- (000000000001198C) ----------------------------------------------------
unsigned __int64 __fastcall rsc_hal_get_num_drvs(__int64 a1)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 8) >> 24) & 7;
}

//----- (0000000000011998) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_num_seq_cmd_words(__int64 a1)
{
  return (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
}

//----- (00000000000119A4) ----------------------------------------------------
unsigned __int64 __fastcall rsc_hal_get_num_ts_events(__int64 a1)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 8) >> 8) & 0xF;
}

//----- (00000000000119B0) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_delay_cntr_bitwidth(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) & 0x1F;
}

//----- (00000000000119BC) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_parentchild_cfg(__int64 a1)
{
  return *(_DWORD *)(a1 + 12) & 0xF8FFFFFF;
}

//----- (00000000000119C8) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_status0(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) & 0x101FFFF;
}

//----- (00000000000119D8) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_status1(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}

//----- (00000000000119E0) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_status2(__int64 a1)
{
  return *(_DWORD *)(a1 + 24) & 0xFFFFFF;
}

//----- (00000000000119EC) ----------------------------------------------------
__int64 __fastcall rsc_hal_set_ts_unit_owner(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 512) = a2;
  return result;
}

//----- (00000000000119F8) ----------------------------------------------------
__int64 __fastcall rsc_hal_enable_ts_unit(__int64 result, unsigned __int8 a2, char a3)
{
  *(_DWORD *)(result + 32LL * a2 + 516) = a3 & 1;
  return result;
}

//----- (0000000000011A10) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_ts_unit_l(__int64 a1, unsigned __int8 a2)
{
  return *(unsigned int *)(a1 + 32LL * a2 + 520);
}

//----- (0000000000011A20) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_ts_unit_h(__int64 a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 32LL * a2 + 524) & 0xFFFFFF;
}

//----- (0000000000011A34) ----------------------------------------------------
unsigned __int64 __fastcall rsc_hal_get_ts_overflow(__int64 a1, unsigned __int8 a2)
{
  return ((unsigned __int64)*(unsigned int *)(a1 + 32LL * a2 + 528) >> 8) & 1;
}

//----- (0000000000011A48) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_ts_valid(__int64 a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 32LL * a2 + 528) & 1;
}

//----- (0000000000011A5C) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_seq_override_start_addr_valid(__int64 a1)
{
  return *(_DWORD *)(a1 + 1024) >> 31;
}

//----- (0000000000011A68) ----------------------------------------------------
__int64 __fastcall rsc_hal_set_seq_override_start_addr_valid(__int64 result, int a2)
{
  *(_DWORD *)(result + 1024) = *(_DWORD *)(result + 1024) & 0x3FF | (a2 << 31);
  return result;
}

//----- (0000000000011A7C) ----------------------------------------------------
__int64 __fastcall rsc_hal_set_seq_override_start_addr(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 1024) = *(_DWORD *)(result + 1024) & 0x80000000 | a2;
  return result;
}

//----- (0000000000011A94) ----------------------------------------------------
__int64 __fastcall rsc_hal_set_trigger_seq(__int64 result, unsigned __int8 a2)
{
  *(_DWORD *)(result + 1120) = a2;
  return result;
}

//----- (0000000000011AA0) ----------------------------------------------------
__int64 __fastcall rsc_hal_set_trigger_start_address(__int64 result, unsigned __int16 a2)
{
  *(_DWORD *)(result + 1124) = a2;
  return result;
}

//----- (0000000000011AAC) ----------------------------------------------------
__int64 __fastcall rsc_hal_seq_busy(__int64 a1)
{
  return *(_DWORD *)(a1 + 1028) & 1;
}

//----- (0000000000011AB8) ----------------------------------------------------
__int64 __fastcall rsc_hal_get_seq_program_counter(__int64 a1)
{
  return *(_DWORD *)(a1 + 1032) & 0x3FF;
}

//----- (0000000000011AC4) ----------------------------------------------------
__int64 __fastcall rsc_hal_config_br_addr(__int64 result, int a2, unsigned __int16 a3)
{
  *(_DWORD *)(result + 4LL * (a2 & 0x3FFFFFFF) + 1280) = a3;
  return result;
}

//----- (0000000000011AD8) ----------------------------------------------------
__int64 __fastcall rsc_hal_copy_simple_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  int v4; // w5
  int v5; // w4
  __int64 v6; // x7
  int v7; // w6
  int v8; // w10
  int v9; // w8
  __int64 v10; // x5
  int v11; // w8
  int v12; // w6
  int v13; // w8
  char v14; // w5
  int v15; // w8
  int v16; // w9
  __int64 v17; // x1

  a4 = (unsigned __int16)a4;
  v4 = 4 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
  if ( a2 >= (unsigned int)v4 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v5 > v4 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)v6 )
    {
      v9 = ((_BYTE)a2 + (_BYTE)v6) & 3;
      switch ( v9 )
      {
        case 2:
          v14 = 16;
          v15 = 16711680;
          break;
        case 3:
          v14 = 24;
          v15 = -16777216;
          break;
        case 1:
          v14 = 8;
          v15 = 65280;
          break;
        default:
          if ( (_WORD)v6 )
          {
            v10 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 4) + 1536LL;
            v11 = *(_DWORD *)(a1 + v10);
            v12 = (v7 ^ v11) & v8;
            v8 = 0;
            v13 = v12 ^ v11;
            v7 = 0;
            *(_DWORD *)(a1 + v10) = v13;
          }
          v14 = 0;
          v15 = 255;
          break;
      }
      v16 = *(unsigned __int16 *)(a3 + 2 * v6);
      v8 |= v15;
      ++v6;
      v7 |= v16 << v14;
    }
    v17 = 4 * (((unsigned __int16)v5 - 1) / 4) + 1536LL;
    *(_DWORD *)(a1 + v17) ^= (v7 ^ *(_DWORD *)(a1 + v17)) & v8;
  }
  return a4;
}

//----- (0000000000011C08) ----------------------------------------------------
__int64 __fastcall rsc_hal_copy_extended_cmd_seq(__int64 a1, unsigned __int16 a2, __int64 a3, unsigned int a4)
{
  int v4; // w5
  int v5; // w4
  __int64 v6; // x8
  int v7; // w6
  int v8; // w7
  __int64 v9; // x5
  int v10; // w9
  int v11; // w6
  int v12; // w6
  char v13; // w9
  int v14; // w5
  int v15; // w5
  __int64 v16; // x1

  a4 = (unsigned __int16)a4;
  v4 = 2 * (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 8));
  if ( a2 >= (unsigned int)v4 )
    return 0;
  v5 = a2 + (unsigned __int16)a4;
  if ( v5 > v4 )
  {
    return 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v8 = 0;
    while ( (unsigned __int16)a4 > (unsigned int)v6 )
    {
      if ( (((_BYTE)a2 + (_BYTE)v6) & 1) != 0 )
      {
        v13 = 16;
        v14 = -65536;
      }
      else if ( (_WORD)v6 )
      {
        v9 = 4 * (((unsigned __int16)(a2 + v6) - 1) / 2) + 1536LL;
        v10 = *(_DWORD *)(a1 + v9);
        v11 = (v7 ^ v10) & v8;
        v8 = 0;
        v12 = v11 ^ v10;
        v13 = 0;
        *(_DWORD *)(a1 + v9) = v12;
        v14 = 0xFFFF;
        v7 = 0;
      }
      else
      {
        v13 = 0;
        v14 = 0xFFFF;
      }
      v8 |= v14;
      v15 = *(unsigned __int16 *)(a3 + 2 * v6++);
      v7 |= v15 << v13;
    }
    v16 = 4 * (((unsigned __int16)v5 - 1) / 2) + 1536LL;
    *(_DWORD *)(a1 + v16) ^= (v7 ^ *(_DWORD *)(a1 + v16)) & v8;
  }
  return a4;
}

//----- (0000000000011D04) ----------------------------------------------------
__int64 __fastcall rsc_hal_conf_hidden_tcs_owner(__int64 result, char a2)
{
  *(_DWORD *)(result + 28) = *(_DWORD *)(result + 28) & 0x10000 | a2 & 3;
  return result;
}

//----- (0000000000011D1C) ----------------------------------------------------
__int64 __fastcall rsc_get_count(unsigned __int8 a1)
{
  int v1; // w4
  unsigned int v2; // w1
  __int64 result; // x0
  __int64 v4; // x6

  v1 = a1;
  v2 = 0;
  result = 0LL;
  while ( g_rsc_count > (unsigned __int64)v2 )
  {
    v4 = 96LL * v2++;
    if ( *(unsigned __int8 *)(g_rscs + v4) == v1 )
      result = (unsigned int)(result + 1);
    else
      result = (unsigned int)result;
  }
  return result;
}
// 1D558: using guessed type __int64 g_rsc_count;
// 31628: using guessed type __int64 g_rscs;

//----- (0000000000011D60) ----------------------------------------------------
__int64 __fastcall rsc_get_handles(char a1, int a2, __int64 a3)
{
  bool v3; // zf
  unsigned int v5; // w1
  unsigned __int64 v6; // x5
  _BYTE *v7; // x8
  __int64 result; // x0

  if ( a2 )
    v3 = a3 == 0;
  else
    v3 = 1;
  if ( v3 || a1 != 0 )
    return 0LL;
  v5 = 0;
  v6 = g_rsc_count;
  result = 0LL;
  while ( v6 > v5 )
  {
    v7 = (_BYTE *)(g_rscs + 96LL * v5);
    if ( !*v7 )
    {
      *(_QWORD *)(a3 + 8LL * (unsigned int)result) = v7;
      result = (unsigned int)(result + 1);
    }
    ++v5;
  }
  return result;
}
// 1D558: using guessed type __int64 g_rsc_count;
// 31628: using guessed type __int64 g_rscs;

//----- (0000000000011DC4) ----------------------------------------------------
__int64 __fastcall rsc_read_id_info(__int64 a1)
{
  _BYTE *v2; // x20
  __int64 result; // x0

  v2 = *(_BYTE **)(a1 + 80);
  *v2 = rsc_hal_get_step_ver(*(_DWORD **)(a1 + 40));
  v2[1] = rsc_hal_get_minor_ver(*(_DWORD **)(a1 + 40));
  result = rsc_hal_get_major_ver(*(_DWORD **)(a1 + 40));
  v2[2] = result;
  return result;
}

//----- (0000000000011E08) ----------------------------------------------------
__int64 __fastcall rsc_read_internal_config(__int64 result)
{
  unsigned __int16 v1; // w1
  __int64 v2; // x20
  __int64 v3; // x19

  v1 = rsc_params_count;
  if ( (unsigned __int16)rsc_params_count > 3u )
  {
    *(_QWORD *)(result + 80) = 0LL;
  }
  else
  {
    ++rsc_params_count;
    *(_QWORD *)(result + 80) = &rsc_params[16 * v1];
  }
  v2 = *(_QWORD *)(result + 80);
  if ( v2 )
  {
    v3 = result;
    *(_DWORD *)(v2 + 4) = rsc_hal_get_solver_cfg(*(_QWORD *)(result + 40));
    *(_DWORD *)(v2 + 12) = rsc_hal_get_parentchild_cfg(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 8) = rsc_hal_get_num_drvs(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 9) = rsc_hal_get_num_seq_cmd_words(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 10) = rsc_hal_get_num_ts_events(*(_QWORD *)(v3 + 40));
    result = rsc_hal_get_delay_cntr_bitwidth(*(_QWORD *)(v3 + 40));
    *(_BYTE *)(v2 + 11) = result;
  }
  return result;
}
// 31620: using guessed type __int16 rsc_params_count;

//----- (0000000000011EB0) ----------------------------------------------------
__int64 __fastcall rsc_mode_index(__int64 a1, unsigned __int8 a2)
{
  int v2; // w5
  __int64 v3; // x3
  unsigned int v4; // w2
  __int64 v5; // x4
  __int64 result; // x0
  __int64 v7; // x2
  int v8; // w3

  v2 = *(_DWORD *)(a1 + 16);
  v3 = 0LL;
  while ( 1 )
  {
    v4 = v3;
    if ( v3 == v2 )
      break;
    v5 = *(_QWORD *)(a1 + 8) + 240 * v3++;
    if ( *(_WORD *)(v5 + 16) == a2 )
      return v4;
  }
  v7 = *(_QWORD *)(a1 + 64);
  if ( v7 || (v8 = *(_DWORD *)(a1 + 72), result = 4LL, v8) )
  {
    result = 0LL;
    while ( (_DWORD)result != v2 )
    {
      if ( v7 && *(_WORD *)(v7 + 16) == a2 )
        return result;
      result = (unsigned int)(result + 1);
      v7 += 240LL;
    }
    return 4LL;
  }
  return result;
}

//----- (0000000000011F40) ----------------------------------------------------
__int64 __fastcall rsc_copy_cmd_seqs(__int64 a1)
{
  __int64 v2; // x23
  __int64 (__fastcall *v3)(__int64, unsigned __int16, __int64, unsigned int); // x20
  unsigned int i; // w21
  __int64 v5; // x1
  __int64 v6; // x22
  __int16 v7; // w0
  __int16 v8; // w1
  unsigned int v9; // w13
  __int64 v10; // x9
  __int64 v11; // x12
  __int64 v12; // x11
  unsigned __int16 v13; // w0
  unsigned int v14; // w10
  __int64 v15; // x15
  __int16 v16; // w14
  __int64 v17; // x11

  v2 = *(_QWORD *)(a1 + 40);
  if ( *(_BYTE *)(a1 + 1) == 8 )
    v3 = rsc_hal_copy_simple_cmd_seq;
  else
    v3 = rsc_hal_copy_extended_cmd_seq;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_DWORD *)(a1 + 16) )
    {
      v9 = 0;
      goto LABEL_15;
    }
    v5 = *(_QWORD *)(a1 + 8);
    v6 = v5 + 240LL * i;
    if ( *(_WORD *)(v6 + 8) )
      break;
LABEL_12:
    ;
  }
  v7 = ((__int64 (__fastcall *)(__int64, _QWORD, _QWORD))v3)(
         v2,
         *(unsigned __int16 *)(a1 + 56),
         *(_QWORD *)(v5 + 240LL * i));
  if ( v7 )
  {
    v8 = *(_WORD *)(a1 + 56);
    if ( *(_BYTE *)(a1 + 1) == 8 )
      *(_WORD *)(v6 + 18) = v8;
    else
      *(_WORD *)(v6 + 18) = 2 * (v8 & 0x7FFF);
    *(_WORD *)(a1 + 56) = v7 + v8;
    goto LABEL_12;
  }
  v9 = 3;
LABEL_15:
  v10 = 0LL;
  v11 = 240LL * *(unsigned int *)(a1 + 16);
  while ( v11 != v10 )
  {
    v12 = *(_QWORD *)(a1 + 8) + v10;
    if ( *(_BYTE *)(v12 + 20) || !*(_WORD *)(v12 + 8) )
    {
      v13 = rsc_mode_index(a1, *(_BYTE *)(v12 + 21));
      *(_WORD *)(v17 + 18) = v16 + *(_WORD *)(v15 + v13 * (unsigned __int64)v14 + 18);
    }
    v10 += 240LL;
  }
  return v9;
}
// 12010: variable 'v11' is possibly undefined
// 12044: variable 'v16' is possibly undefined
// 1203C: variable 'v15' is possibly undefined
// 1203C: variable 'v14' is possibly undefined
// 12048: variable 'v17' is possibly undefined
// 1204C: variable 'v10' is possibly undefined
// 12054: variable 'v9' is possibly undefined

//----- (000000000001206C) ----------------------------------------------------
__int64 __fastcall rsc_enable_ts_events(__int64 a1, char a2)
{
  int i; // w19

  for ( i = 0; i != 4; ++i )
  {
    rsc_hal_enable_ts_unit(*(_QWORD *)(a1 + 40), i, a2);
    if ( !*(_BYTE *)(a1 + 88) )
      rsc_hal_get_ts_unit_h(*(_QWORD *)(a1 + 40), i);
  }
  return 0LL;
}

//----- (00000000000120D4) ----------------------------------------------------
__int64 __fastcall rsc_ts_init(__int64 a1)
{
  unsigned int v2; // w2

  if ( !a1 || !*(_QWORD *)(a1 + 40) )
    return 1LL;
  v2 = rsc_enable_ts_events(a1, 1);
  if ( v2 )
  {
    *(_BYTE *)(a1 + 88) = 0;
    return (unsigned int)-1;
  }
  else
  {
    *(_BYTE *)(a1 + 88) = 1;
  }
  return v2;
}

//----- (0000000000012138) ----------------------------------------------------
__int64 __fastcall rsc_set_low_power_mode(__int64 a1, unsigned __int8 a2)
{
  unsigned int v2; // w2
  unsigned int v4; // w0
  unsigned int v5; // w21
  __int64 v6; // x20
  unsigned __int16 v7; // w2

  if ( !a1 )
    return 1LL;
  v2 = 1;
  if ( *(_QWORD *)(a1 + 40) )
  {
    v4 = rsc_mode_index(a1, a2);
    v2 = 2;
    if ( v4 != 4 )
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 8) + 240LL * v4;
      if ( *(_QWORD *)(v6 + 24) )
      {
        while ( v5 < *(unsigned __int16 *)(v6 + 32) )
        {
          v7 = *(_WORD *)(*(_QWORD *)(v6 + 24) + 2LL * v5);
          if ( v7 )
            rsc_hal_config_br_addr(*(_QWORD *)(a1 + 40), v5, v7);
          ++v5;
        }
      }
      rsc_hal_set_seq_override_start_addr_valid(*(_QWORD *)(a1 + 40), 1);
      rsc_hal_set_seq_override_start_addr(*(_QWORD *)(a1 + 40), *(_BYTE *)(v6 + 18));
      return 0;
    }
  }
  return v2;
}

//----- (00000000000121F4) ----------------------------------------------------
__int64 __fastcall rsc_program_dyn_cmd_seq(__int64 a1, __int64 a2, __int16 a3, _DWORD *a4)
{
  unsigned int v4; // w4
  __int64 (*v7)(void); // x4
  __int16 v10; // w24
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x2
  int v13; // w0
  __int16 v14; // w0

  if ( !a1 )
    return 1LL;
  v4 = 1;
  if ( *(_QWORD *)(a1 + 40) )
  {
    if ( *(_BYTE *)(a1 + 1) == 8 )
      v7 = (__int64 (*)(void))rsc_hal_copy_simple_cmd_seq;
    else
      v7 = (__int64 (*)(void))rsc_hal_copy_extended_cmd_seq;
    if ( (unsigned int)initial_dynmode_id_1266 <= 0xFF )
    {
      v10 = v7();
      v4 = 3;
      if ( v10 )
      {
        v11 = qtisec_realloc(*(_QWORD *)(a1 + 64), 240LL * (unsigned int)(*(_DWORD *)(a1 + 72) + 1));
        *(_QWORD *)(a1 + 64) = v11;
        v4 = -1;
        if ( v11 )
        {
          v12 = v11 + 240LL * *(unsigned int *)(a1 + 72);
          *(_QWORD *)v12 = a2;
          v13 = initial_dynmode_id_1266;
          *(_WORD *)(v12 + 8) = a3;
          *(_WORD *)(v12 + 16) = v13;
          initial_dynmode_id_1266 = v13 + 1;
          *a4 = (unsigned __int16)v13;
          *(_WORD *)(v12 + 232) = 0;
          v14 = *(_WORD *)(a1 + 56);
          if ( *(_BYTE *)(a1 + 1) == 8 )
            *(_WORD *)(v12 + 18) = v14;
          else
            *(_WORD *)(v12 + 18) = 2 * (v14 & 0x7FFF);
          v4 = 0;
          *(_WORD *)(a1 + 56) = v10 + v14;
          ++*(_DWORD *)(a1 + 72);
        }
      }
    }
    else
    {
      v4 = -1;
      *a4 = 255;
    }
  }
  return v4;
}
// 1D688: using guessed type int initial_dynmode_id_1266;

//----- (0000000000012340) ----------------------------------------------------
__int64 __fastcall rsc_trigger_seq(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // x0
  __int64 v4; // x5
  __int64 v5; // x2
  unsigned int v6; // w4
  __int64 v7; // x4
  __int64 v8; // x19

  if ( !a1 )
    return 2LL;
  result = 2LL;
  v4 = *(_QWORD *)(a1 + 40);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 64);
    v6 = *(_DWORD *)(a1 + 72);
    if ( v5 || v6 )
    {
      v7 = v5 + 240LL * v6;
      while ( v7 != v5 )
      {
        if ( v5 && *(_WORD *)(v5 + 16) == a2 )
        {
          v8 = a1;
          rsc_hal_set_trigger_start_address(v4, *(_WORD *)(v5 + 18));
          rsc_hal_set_trigger_seq(*(_QWORD *)(v8 + 40), 0);
          rsc_hal_set_trigger_seq(*(_QWORD *)(v8 + 40), 1u);
          do
            result = rsc_hal_seq_busy(*(_QWORD *)(v8 + 40));
          while ( (_DWORD)result );
          return result;
        }
        v5 += 240LL;
      }
      return 2LL;
    }
  }
  return result;
}

//----- (00000000000123E8) ----------------------------------------------------
__int64 __fastcall rsc_get_time_stamp(__int64 a1, unsigned __int8 a2)
{
  unsigned int v3; // w0
  unsigned int v4; // w3
  __int64 v5; // x0

  if ( !a1 || !*(_QWORD *)(a1 + 40) || !*(_BYTE *)(a1 + 88) )
    return 2LL;
  v3 = rsc_mode_index(a1, a2);
  v4 = 4;
  if ( v3 != 4 )
  {
    v4 = -1;
    v5 = *(_QWORD *)(a1 + 8) + 240LL * v3;
    ++*(_WORD *)(v5 + 232);
  }
  return v4;
}

//----- (0000000000012460) ----------------------------------------------------
__int64 __fastcall rsc_conf_hidden_tcs_ownership(__int64 a1, char a2)
{
  __int64 v2; // x2
  __int64 result; // x0

  if ( !a1 )
    return 2LL;
  v2 = *(_QWORD *)(a1 + 40);
  result = 2LL;
  if ( v2 )
  {
    rsc_hal_conf_hidden_tcs_owner(v2, a2);
    return 0LL;
  }
  return result;
}

//----- (000000000001249C) ----------------------------------------------------
__int64 __fastcall rsc_instance_init(__int64 a1)
{
  unsigned int v2; // w20

  if ( (unsigned int)rsc_init_base_address(a1) )
    return 0xFFFFFFFFLL;
  rsc_read_internal_config(a1);
  rsc_read_id_info(a1);
  v2 = rsc_copy_cmd_seqs(a1);
  rsc_conf_hidden_tcs_ownership(a1, *(_BYTE *)(a1 + 32));
  return v2;
}

//----- (00000000000124F4) ----------------------------------------------------
void **rsc_target_init()
{
  void **result; // x0

  result = &g_rsc_instances;
  g_rscs = (__int64)&g_rsc_instances;
  return result;
}
// 1D5D8: using guessed type void *g_rsc_instances;
// 31628: using guessed type __int64 g_rscs;

//----- (0000000000012508) ----------------------------------------------------
unsigned int *__fastcall HAL_avs_Enable(unsigned int a1, int a2)
{
  unsigned int *result; // x0
  unsigned int v3; // w1

  result = (unsigned int *)asAVSRegs[7 * a1 + 4];
  if ( a2 )
  {
    *result |= 1u;
    v3 = *result | 0x10;
  }
  else
  {
    *result &= ~1u;
    v3 = *result & 0xFFFFFFEF;
  }
  *result = v3;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (0000000000012558) ----------------------------------------------------
__int64 __fastcall HAL_avs_Ramp_En(unsigned int a1, char a2)
{
  unsigned int *v2; // x2
  __int64 result; // x0

  v2 = (unsigned int *)asAVSRegs[7 * a1 + 4];
  *v2 = ((a2 & 1) << 15) | *v2 & 0xFFFF7FFF;
  result = *v2;
  *v2 = ((a2 & 1) << 14) | result & 0xFFFFBFFF;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (000000000001259C) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetDelay(unsigned int a1, __int16 a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 6];
  result = *v2 & 0xFFFFFC00;
  *v2 = result | a2 & 0x3FF;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (00000000000125CC) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetClockDivider(unsigned int a1, char a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 4];
  result = ((a2 & 0x1F) << 8) | *v2 & 0xFFFFE0FF;
  *v2 = result;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (00000000000125FC) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetVoltageStepSize(unsigned int a1, int a2, unsigned __int8 a3)
{
  int *v3; // x3
  __int64 result; // x0

  v3 = (int *)asAVSRegs[7 * a1 + 4];
  *v3 = *v3 & 0xFFFFFF | (a2 << 24);
  result = (a3 << 16) | *v3 & 0xFF00FFFF;
  *v3 = result;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (000000000001263C) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetVoltageWidth(unsigned int a1, char a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 4];
  result = (32 * (a2 & 1)) | *v2 & 0xFFFFFFDF;
  *v2 = result;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (000000000001266C) ----------------------------------------------------
__int64 __fastcall HAL_avs_GetVddSettleTimeUS(int a1, int a2)
{
  if ( a2 )
    return 120 * ((unsigned int)(1000 * a2) / gHALAVSContext[4 * a1 + 3]) / 0x64;
  else
    return 0LL;
}
// 1D690: using guessed type _DWORD gHALAVSContext[8];

//----- (00000000000126B0) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetVoltage(unsigned int a1, unsigned int a2)
{
  int v4; // w24
  unsigned int v5; // w2
  int v6; // w1
  int v7; // w23
  __int64 *v8; // x22
  _DWORD *v9; // x0
  unsigned int v10; // w24
  __int64 VddSettleTimeUS; // x0
  __int64 result; // x0

  v4 = 201;
  v5 = gHALAVSContext[4 * a1 + 2];
  v6 = a2 - v5;
  v7 = v5 - a2;
  if ( v5 < a2 )
    v7 = v6;
  v8 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v8 = (unsigned __int16)a2 | 0x100000;
  while ( 1 )
  {
    if ( !--v4 )
    {
      v10 = 0;
      goto LABEL_10;
    }
    v9 = (_DWORD *)v8[1];
    if ( (*v9 & 0x30000) == 0 && a2 == (unsigned __int16)*v9 )
      break;
    qtiseclib_cb_udelay(2LL);
  }
  v10 = 1;
LABEL_10:
  if ( !bIsInit_1181 && a2 > gHALAVSContext[4 * a1 + 2] )
  {
    VddSettleTimeUS = HAL_avs_GetVddSettleTimeUS(a1, v7);
    qtiseclib_cb_udelay(VddSettleTimeUS);
  }
  result = v10;
  bIsInit_1181 = 0;
  gHALAVSContext[4 * a1 + 2] = a2;
  return result;
}
// 1D68C: using guessed type char bIsInit_1181;
// 1D690: using guessed type _DWORD gHALAVSContext[8];
// 31630: using guessed type __int64 asAVSRegs[];
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (00000000000127B8) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetPowerMode(unsigned int a1, int a2)
{
  int v2; // w2
  int v4; // w20
  __int64 *v5; // x19

  if ( a2 == 1 )
  {
    v2 = 7;
  }
  else
  {
    v2 = 6;
    if ( a2 )
      return 0LL;
  }
  v4 = 201;
  v5 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v5 = v2 | 0x20000;
  while ( --v4 )
  {
    if ( (*(_DWORD *)v5[1] & 0x30000) == 0 )
      return 1LL;
    qtiseclib_cb_udelay(2LL);
  }
  return 0LL;
}
// 31630: using guessed type __int64 asAVSRegs[];
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (000000000001283C) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetMaxVoltage(unsigned int a1, int a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 5];
  result = (unsigned __int16)*v2;
  *v2 = result | (a2 << 16);
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (0000000000012868) ----------------------------------------------------
__int64 __fastcall HAL_avs_SetMinVoltage(unsigned int a1, unsigned __int16 a2)
{
  _DWORD *v2; // x2
  __int64 result; // x0

  v2 = (_DWORD *)asAVSRegs[7 * a1 + 5];
  result = *v2 & 0xFFFF0000;
  *v2 = result | a2;
  return result;
}
// 31630: using guessed type __int64 asAVSRegs[];

//----- (0000000000012898) ----------------------------------------------------
__int64 __fastcall HAL_avs_EnableCtl(unsigned int a1, unsigned __int8 a2)
{
  int v2; // w22
  int v4; // w21
  __int64 *v5; // x19
  unsigned int v6; // w19
  int VddSettleTimeUS; // w0

  v2 = a2;
  v4 = 201;
  v5 = &asAVSRegs[7 * a1];
  *(_DWORD *)*v5 = ((a2 != 0) << 7) | 0x30000;
  while ( 1 )
  {
    if ( !--v4 )
    {
      v6 = 0;
      goto LABEL_7;
    }
    if ( (*(_DWORD *)v5[1] & 0x30000) == 0 )
      break;
    qtiseclib_cb_udelay(2LL);
  }
  v6 = 1;
LABEL_7:
  if ( v2 )
  {
    VddSettleTimeUS = HAL_avs_GetVddSettleTimeUS(a1, gHALAVSContext[4 * a1 + 2]);
    qtiseclib_cb_udelay((unsigned int)(VddSettleTimeUS + 36));
  }
  return v6;
}
// 1D690: using guessed type _DWORD gHALAVSContext[8];
// 31630: using guessed type __int64 asAVSRegs[];
// 31988: using guessed type __int64 __fastcall qtiseclib_cb_udelay(_QWORD);

//----- (0000000000012950) ----------------------------------------------------
__int64 __fastcall HAL_avs_RestoreBootVoltage(unsigned int a1)
{
  return HAL_avs_SetVoltage(a1, gHALAVSContext[4 * a1 + 1]);
}
// 1D690: using guessed type _DWORD gHALAVSContext[8];

//----- (0000000000012968) ----------------------------------------------------
__int64 HAL_avs_SecondaryRailInit()
{
  HAL_avs_Enable(1u, 1);
  HAL_avs_EnableCtl(1u, 1u);
  return HAL_avs_RestoreBootVoltage(1u);
}

//----- (0000000000012994) ----------------------------------------------------
__int64 *HAL_avs_Init()
{
  __int64 *result; // x0
  __int64 v1; // x2
  int v2; // w1

  result = asAVSRegs;
  v1 = 0LL;
  do
  {
    v2 = gHALAVSContext[v1];
    v1 += 4LL;
    *result = (unsigned int)(v2 + 2304);
    result[4] = (unsigned int)(v2 + 2308);
    result[5] = (unsigned int)(v2 + 2312);
    result[6] = (unsigned int)(v2 + 2316);
    result[1] = (unsigned int)(v2 + 3096);
    result[2] = (unsigned int)(v2 + 3092);
    result += 7;
  }
  while ( v1 != 8 );
  return result;
}
// 1D690: using guessed type _DWORD gHALAVSContext[8];
// 31630: using guessed type __int64 asAVSRegs[];

//----- (00000000000129EC) ----------------------------------------------------
__int64 __fastcall handle_scmi_base_protocol_msg(__int64 a1)
{
  int v2; // w1
  __int64 v3; // x20
  int v4; // w0
  int v5; // w1
  __int64 v6; // x20
  int v7; // w0
  int v8; // w1
  __int64 input_payload_char_at_offset; // x0
  int v10; // w20
  unsigned int v12; // [xsp+3Ch] [xbp+3Ch] BYREF
  int v13[4]; // [xsp+40h] [xbp+40h] BYREF

  scmi_packet_init_payload(a1);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      write_output_payload_word(a1, 0);
      v2 = 0x20000;
      goto LABEL_4;
    case 1:
      write_output_payload_word(a1, 0);
      v2 = 257;
      goto LABEL_4;
    case 2:
      write_output_payload_word(a1, 0);
      v2 = 0;
      goto LABEL_4;
    case 3:
      v3 = 0LL;
      write_output_payload_word(a1, 0);
      scmi_plat_ops(v13, &v12, 16LL);
      v4 = v12;
      if ( v12 > 0x10 )
        v4 = 16;
      v12 = v4;
      while ( (unsigned int)v3 < (v12 + 3) >> 2 )
      {
        v5 = v13[v3++];
        write_output_payload_word(a1, v5);
      }
      return 0LL;
    case 4:
      v6 = 0LL;
      write_output_payload_word(a1, 0);
      handle_scmi_vendor_protocol_msg(v13, &v12, 16LL);
      v7 = v12;
      if ( v12 > 0x10 )
        v7 = 16;
      v12 = v7;
      while ( (unsigned int)v6 < (v12 + 3) >> 2 )
      {
        v8 = v13[v6++];
        write_output_payload_word(a1, v8);
      }
      return 0LL;
    case 5:
      write_output_payload_word(a1, 0);
      v2 = 0x10000;
      goto LABEL_4;
    case 6:
      input_payload_char_at_offset = get_input_payload_char_at_offset(a1, 0);
      v10 = MEMORY[0x319B8](input_payload_char_at_offset, v13);
      write_output_payload_word(a1, 0);
      write_output_payload_word(a1, v10);
      v2 = v13[0];
      if ( v10 )
LABEL_4:
        write_output_payload_word(a1, v2);
      break;
    default:
      write_output_payload_word_at_offset(a1, -1, 0);
      break;
  }
  return 0LL;
}
// 31930: using guessed type __int64 (__fastcall *scmi_plat_ops)(_QWORD, _QWORD, _QWORD);
// 31948: using guessed type __int64 __fastcall handle_scmi_vendor_protocol_msg(_QWORD, _QWORD, _QWORD);
// 319B8: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD);
// 129EC: using guessed type int var_10[4];

//----- (0000000000012BB0) ----------------------------------------------------
__int64 __fastcall handle_scmi_clk_mgmt_protocol_msg(__int64 a1)
{
  int v2; // w1
  unsigned int input_payload_word_at_offset; // w20

  scmi_packet_init_payload(a1);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      write_output_payload_word(a1, 0);
      v2 = 0x10000;
      break;
    case 1:
      write_output_payload_word(a1, 0);
      v2 = scmi_num_clk_doms;
      break;
    case 2:
      write_output_payload_word(a1, 0);
      goto LABEL_9;
    case 3:
    case 4:
    case 5:
    case 6:
      v2 = -3;
      break;
    case 7:
      input_payload_word_at_offset = get_input_payload_word_at_offset(a1, 0);
      if ( (unsigned int)get_input_payload_word_at_offset(a1, 1) != 1 || !MEMORY[0x319B0] )
        goto LABEL_10;
      MEMORY[0x319B0](input_payload_word_at_offset);
LABEL_9:
      v2 = 0;
      break;
    default:
LABEL_10:
      v2 = -1;
      break;
  }
  write_output_payload_word(a1, v2);
  return 0LL;
}
// 319B0: using guessed type __int64 (__fastcall *)(_QWORD);

//----- (0000000000012C88) ----------------------------------------------------
__int64 __fastcall cpucp_scmi_send(
        unsigned __int8 a1,
        unsigned __int8 a2,
        __int64 a3,
        unsigned int a4,
        _DWORD *a5,
        __int64 a6,
        unsigned int *a7)
{
  bool v7; // zf
  unsigned int v8; // w19
  unsigned __int64 v16; // x23
  unsigned __int64 StatusReg; // x0
  unsigned __int64 v18; // x2
  unsigned int v20; // w19
  unsigned int v21; // w24
  int v23; // w1
  unsigned __int64 v24; // x1
  unsigned __int64 v25; // x23
  unsigned int v27; // w0
  __int64 v28; // x3
  unsigned int v29; // w0
  __int64 v30; // x2
  __int64 i; // x1
  int v32; // t1
  __int64 v33; // x0
  __int64 v34; // x4
  __int64 v35; // x0
  __int64 v36; // x1
  __int64 v37; // x3

  if ( a3 )
    v7 = 1;
  else
    v7 = a4 == 0;
  v8 = -1;
  if ( v7 )
  {
    v8 = -2;
    if ( a4 <= 0x64 )
    {
      qtiseclib_cb_spin_lock(&scmi_host_spinlock);
      v16 = 500 * _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 0)) / 0x3E8;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      v18 = v16 + StatusReg;
      while ( StatusReg < v18 && MEMORY[0x18509004] != 1 )
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      if ( MEMORY[0x18509004] != 1 )
        goto LABEL_14;
      __dsb(0xFu);
      MEMORY[0x18509018] = scmi_construct_msg_hdr(a2, 0, a1, 0);
      MEMORY[0x18509004] = 0;
      MEMORY[0x18509010] = 0;
      v20 = (a4 + 3) >> 2;
      v21 = 0;
      scmi_packet_init_payload(407932928LL);
      while ( v21 < v20 && a3 != 0 )
      {
        v23 = *(_DWORD *)(a3 + 4LL * v21++);
        write_output_payload_word(407932928LL, v23);
      }
      get_input_payload_word_at_offset(407932928LL, 1);
      MEMORY[0x17C00008] = 0x10000000;
      v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      v25 = v16 + v24;
      while ( MEMORY[0x18509004] != 1 && v24 < v25 )
        v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 1));
      if ( MEMORY[0x18509004] == 1 )
      {
        __dsb(0xFu);
        if ( MEMORY[0x18509014] <= 7u )
        {
LABEL_31:
          v8 = 0;
          if ( a7 )
          {
            if ( *a7 )
            {
              if ( MEMORY[0x18509014] > 8u )
              {
                v8 = -3;
                if ( a6 )
                {
                  v27 = MEMORY[0x18509014] - 8;
                  if ( *a7 >= MEMORY[0x18509014] - 8 )
                  {
                    v28 = v27 >> 2;
                    v29 = v27 >> 2;
                    v30 = 407932960LL;
                    for ( i = 0LL; i != v28; ++i )
                    {
                      v32 = *(_DWORD *)v30;
                      v30 += 4LL;
                      *(_DWORD *)(a6 + 4 * i) = v32;
                    }
                    v33 = 4LL * (v29 & 0x3FFFFFFF);
                    v34 = v33 + 407932960;
                    v35 = a6 + v33;
                    v36 = 0LL;
                    v37 = MEMORY[0x18509014] & 3;
                    while ( v37 != v36 )
                    {
                      *(_BYTE *)(v35 + v36) = *(_BYTE *)(v34 + v36);
                      ++v36;
                    }
                    v8 = 0;
                    *a7 = MEMORY[0x18509014] - 8;
                  }
                  else
                  {
                    v8 = -4;
                    *a7 = v27;
                  }
                }
              }
            }
          }
          goto LABEL_44;
        }
        v8 = -5;
        if ( a5 )
        {
          *a5 = MEMORY[0x1850901C];
          goto LABEL_31;
        }
      }
      else
      {
LABEL_14:
        v8 = -6;
      }
LABEL_44:
      qtiseclib_cb_spin_unlock(&scmi_host_spinlock);
    }
  }
  return v8;
}
// 31910: using guessed type __int64 __fastcall qtiseclib_cb_spin_lock(_QWORD);
// 31958: using guessed type __int64 __fastcall qtiseclib_cb_spin_unlock(_QWORD);

//----- (0000000000012F00) ----------------------------------------------------
unsigned __int64 __fastcall scmi_construct_msg_hdr(unsigned __int8 a1, char a2, unsigned __int8 a3, __int16 a4)
{
  int v5; // [xsp+8h] [xbp-8h]

  LOBYTE(v5) = a1;
  BYTE1(v5) = BYTE1(v5) & 0xFC | a2 & 3;
  return a1 | (unsigned __int64)(unsigned __int16)((unsigned __int8)((unsigned __int16)(v5 & 0x3FF | (a3 << 10)) >> 8) << 8) | ((((v5 & 0xFFFC03FF | (a3 << 10)) >> 16) & 3 | (unsigned __int8)(4 * a4)) << 16) & 0xFFFFFF | ((unsigned __int64)(unsigned __int8)((unsigned __int16)(((v5 & 0xFFFC03FF | (a3 << 10)) >> 16) & 0xF003 | (4 * (a4 & 0x3FF))) >> 8) << 24);
}
// 12F0C: variable 'v5' is possibly undefined

//----- (0000000000012F48) ----------------------------------------------------
__int64 __fastcall write_output_payload_word_at_offset(__int64 result, int a2, int a3)
{
  *(_DWORD *)(result + 4LL * a3 + 28) = a2;
  *(_DWORD *)(result + 20) += 4;
  return result;
}

//----- (0000000000012F60) ----------------------------------------------------
__int64 __fastcall write_output_payload_word(__int64 result, int a2)
{
  *(_DWORD *)(result + ((*(_DWORD *)(result + 20) - 1) & 0xFFFFFFFC) + 28) = a2;
  *(_DWORD *)(result + 20) += 4;
  return result;
}

//----- (0000000000012F84) ----------------------------------------------------
__int64 __fastcall get_input_payload_char_at_offset(__int64 a1, int a2)
{
  return *(unsigned int *)(a1 + a2 + 28);
}

//----- (0000000000012F90) ----------------------------------------------------
__int64 __fastcall get_input_payload_word_at_offset(__int64 a1, int a2)
{
  return *(unsigned int *)(a1 + 4LL * a2 + 28);
}

//----- (0000000000012F9C) ----------------------------------------------------
__int64 __fastcall scmi_packet_init_payload(__int64 result)
{
  *(_DWORD *)(result + 20) = 4;
  return result;
}

//----- (0000000000012FA8) ----------------------------------------------------
__int64 __fastcall scmi_process_packet(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v4; // w1
  __int64 result; // x0
  __int64 v6; // x1

  v4 = (unsigned __int8)((unsigned __int64)*(unsigned int *)(a1 + 24) >> 10);
  if ( v4 == 20 )
  {
    result = handle_scmi_clk_mgmt_protocol_msg(a1);
    goto LABEL_11;
  }
  if ( v4 > 0x14 )
  {
    v6 = v4 - 128;
    if ( (unsigned int)v6 <= 2 )
    {
      result = handle_scmi_vendor_protocol_msg(a1, v6, a3);
      goto LABEL_11;
    }
LABEL_10:
    result = handle_scmi_unknown_protocol(a1);
    goto LABEL_11;
  }
  if ( v4 == 16 )
  {
    result = handle_scmi_base_protocol_msg(a1);
    goto LABEL_11;
  }
  if ( v4 != 19 )
    goto LABEL_10;
  result = handle_scmi_perf_dom_mgmt_protocol_msg();
LABEL_11:
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}
// 31948: using guessed type __int64 __fastcall handle_scmi_vendor_protocol_msg(_QWORD, _QWORD, _QWORD);
// 31960: using guessed type __int64 handle_scmi_perf_dom_mgmt_protocol_msg(void);
// 31980: using guessed type __int64 __fastcall handle_scmi_unknown_protocol(_QWORD);

//----- (0000000000013024) ----------------------------------------------------
__int64 __fastcall scmi_read_packet(__int64 a1, __int64 a2, __int64 a3)
{
  if ( qtiseclib_cb_set_spi_routing )
    qtiseclib_cb_set_spi_routing(a1, qtiseclib_cb_set_spi_routing, a3);
  return 0LL;
}
// 31938: using guessed type __int64 __fastcall qtiseclib_cb_set_spi_routing(_QWORD, _QWORD, _QWORD);

//----- (0000000000013050) ----------------------------------------------------
__int64 __fastcall scmi_write_packet(__int64 a1)
{
  if ( (*(_DWORD *)(a1 + 16) & 1) == 0 || !qtiseclib_cb_strcmp )
    return 0LL;
  qtiseclib_cb_strcmp(0LL);
  return 0LL;
}
// 31940: using guessed type __int64 __fastcall qtiseclib_cb_strcmp(_QWORD);

//----- (0000000000013088) ----------------------------------------------------
unsigned __int64 __fastcall set_boot_remap(unsigned __int64 a1)
{
  unsigned __int64 v1; // x2
  unsigned __int64 result; // x0

  v1 = a1 >> 2;
  result = a1 >> 34;
  MEMORY[0x17E0001C] = v1;
  MEMORY[0x17E00020] = result;
  return result;
}

//----- (00000000000130A8) ----------------------------------------------------
__int64 sec_core()
{
  __int64 result; // x0

  result = 1LL;
  MEMORY[0x17C10000] = 1;
  MEMORY[0x18000000] = 1;
  MEMORY[0x18010000] = 1;
  MEMORY[0x18020000] = 1;
  MEMORY[0x18030000] = 1;
  MEMORY[0x18040000] = 1;
  MEMORY[0x18050000] = 1;
  MEMORY[0x18060000] = 1;
  MEMORY[0x18070000] = 1;
  MEMORY[0x18080000] = 1;
  MEMORY[0x17800000] = 1;
  MEMORY[0x17E00004] = 0;
  MEMORY[0x18101C00] = 7;
  MEMORY[0x18100C00] = 7;
  MEMORY[0x18300024] = 3;
  MEMORY[0x18300028] = 15;
  MEMORY[0x18282040] = 3;
  MEMORY[0x18280040] = 3;
  MEMORY[0x18284040] = 3;
  MEMORY[0x182A0004] = 1;
  return result;
}

//----- (0000000000013174) ----------------------------------------------------
void *smmu_init()
{
  int *v0; // x1
  void *result; // x0
  int *v2; // x2
  int v3; // t1

  v0 = &dword_1D6B8;
  result = &unk_1DA08;
  while ( v0 != (int *)&unk_1DA08 )
  {
    v2 = (int *)*((_QWORD *)v0 - 1);
    v3 = *v0;
    v0 += 4;
    *v2 = v3;
  }
  return result;
}
// 1D6B8: using guessed type int dword_1D6B8;

//----- (00000000000131A0) ----------------------------------------------------
__int64 __fastcall debugExecute_part_3(int a1, int a2, char a3, int a4, char *a5, unsigned int a6, __int64 *a7)
{
  unsigned int v7; // w23
  __int64 *v9; // x20
  int v10; // w2
  bool v11; // zf
  unsigned __int8 *v12; // x5
  __int64 *v13; // x0
  int v14; // w7
  __int64 v15; // x19
  __int64 v16; // x9
  int v17; // w2
  __int64 result; // x0
  unsigned __int8 v19; // w2
  int v20; // w9
  int v21; // w8
  __int64 v22; // x10
  unsigned __int64 v23; // x2
  int v24; // w21
  _DWORD *v25; // x25
  _DWORD *v26; // x26
  int *v27; // x6
  int v28; // w1
  int *v29; // x5
  int *v30; // x27
  int *v31; // x28
  _DWORD *v32; // x7
  _DWORD *v33; // x10
  int v34; // w11
  unsigned int v35; // w24
  __int64 v36; // x2
  unsigned int v37; // w0
  char *i; // x2
  unsigned int v39; // w13
  __int64 v41; // x12
  char *v42; // x13
  unsigned int v43; // w0
  char *v45; // x14
  char *v46; // x12
  unsigned int v47; // w0
  int v48; // w2
  int v49; // w2
  int v50; // w2
  int v51; // w0
  char *v52; // x1
  char *v53; // x2
  unsigned int j; // w0
  unsigned int v55; // w13
  __int64 v57; // x12
  char *v58; // x13
  unsigned int k; // w0
  char *v61; // x14
  char *v62; // x12
  char v63[3920]; // [xsp+0h] [xbp-F50h] BYREF
  char *v64; // [xsp+FB0h] [xbp+60h]
  int v65; // [xsp+FB8h] [xbp+68h]
  int v66; // [xsp+FBCh] [xbp+6Ch]
  _DWORD *v67; // [xsp+FC0h] [xbp+70h]
  _DWORD *v68; // [xsp+FC8h] [xbp+78h]
  int *v69; // [xsp+FD0h] [xbp+80h]
  int *v70; // [xsp+FD8h] [xbp+88h]
  int v71; // [xsp+FE0h] [xbp+90h]
  int v72; // [xsp+FE4h] [xbp+94h]
  int v73; // [xsp+FE8h] [xbp+98h]
  int v74; // [xsp+FECh] [xbp+9Ch]
  __int64 v75; // [xsp+FF8h] [xbp+A8h] BYREF

  a4 = (unsigned __int16)a4;
  v7 = a6;
  v9 = a7;
  byte_316C0 = a6;
  byte_316B0 = a3;
  v10 = (a3 & 0xF) << 16;
  byte_316AC = 0;
  dword_316BC = a1;
  if ( a5 )
    v11 = a6 == 0;
  else
    v11 = 1;
  word_316B2 = a4;
  v12 = (unsigned __int8 *)qword_316C8;
  v13 = *(__int64 **)(qword_316C8 + 24);
  v14 = *((unsigned __int16 *)v13 + 5);
  v15 = *v13;
  v16 = 4LL * *((unsigned __int16 *)v13 + 5);
  *(_DWORD *)(v15 + v16 + 21014272) = *(_BYTE *)qword_316C8 & 0xF;
  *(_DWORD *)(v15 + v16 + 21235968) = a4 & 0xFF00 | v10;
  v17 = v11;
  result = 15LL;
  if ( !v17 )
  {
    if ( !a7 )
      v9 = &v75;
    v19 = *v12;
    *(_DWORD *)v9 = 0;
    if ( a1 )
    {
      if ( a1 != 1 )
      {
        result = 3LL;
        goto LABEL_53;
      }
      v20 = 0;
      v21 = 1;
    }
    else
    {
      v20 = 1;
      v21 = 0;
    }
    v22 = v14 << 16;
    v23 = ((unsigned __int64)v19 << 16) + ((unsigned __int64)(unsigned __int16)v14 << 7);
    v24 = a1 << 27;
    v25 = (_DWORD *)(v15 + v22 + 23068688);
    v26 = (_DWORD *)(v15 + v22 + 23068692);
    v27 = (int *)(v15 + v22 + 23068672);
    v28 = v24 | (a2 << 26);
    v29 = (int *)(v15 + v23 + 56623104);
    v30 = (int *)(v15 + v23 + 56623112);
    v31 = (int *)(v15 + v22 + 23068680);
    v32 = (_DWORD *)(v15 + v23 + 56623128);
    v33 = (_DWORD *)(v15 + v23 + 56623132);
    v34 = 8;
    while ( 1 )
    {
      if ( v7 > 8 )
        v35 = v34;
      else
        v35 = v7;
      if ( v20 )
      {
        v36 = *(unsigned int *)v9;
        v37 = 0;
        HIDWORD(v75) = 0;
        for ( i = &a5[v36]; ; v42[4092] = i[v41] )
        {
          v39 = v35 - v37;
          if ( v37 > 3 || v35 == v37 )
            break;
          v41 = v37;
          v42 = &v63[v37++];
        }
        *v25 = HIDWORD(v75);
        if ( v39 )
        {
          v43 = 0;
          HIDWORD(v75) = 0;
          while ( v43 <= 3 && v39 != v43 )
          {
            v45 = &v63[v43];
            v46 = &i[v43++];
            v45[4092] = v46[4];
          }
          *v26 = HIDWORD(v75);
        }
      }
      v47 = v35 - 1;
      v48 = 16 * (unsigned __int8)(*(_DWORD *)v9 + a4);
      if ( v21 )
        *v29 = v48 | v24 | v47;
      else
        *v27 = v48 | v28 | v47;
      v49 = 401;
      while ( 1 )
      {
        v50 = v49 - 1;
        if ( !v50 )
          break;
        v64 = a5;
        v65 = v34;
        v66 = a4;
        v67 = v33;
        v68 = v32;
        v69 = v27;
        v70 = v29;
        v71 = v50;
        v72 = v20;
        v73 = v21;
        v74 = v28;
        SpmiOs_Wait(1LL);
        v21 = v73;
        v28 = v74;
        v34 = v65;
        a4 = v66;
        v49 = v71;
        v20 = v72;
        a5 = v64;
        v33 = v67;
        v32 = v68;
        v27 = v69;
        v29 = v70;
        if ( v73 )
          v51 = *v30;
        else
          v51 = *v31;
        if ( v51 )
          goto LABEL_44;
      }
      LOBYTE(v51) = 0;
LABEL_44:
      if ( (v51 & 8) != 0 )
      {
        result = 7LL;
        goto LABEL_53;
      }
      if ( (v51 & 1) == 0 )
        break;
      if ( (v51 & 2) != 0 )
      {
        result = 5LL;
        goto LABEL_53;
      }
      if ( (v51 & 4) != 0 )
      {
        result = 6LL;
        goto LABEL_53;
      }
      if ( v21 )
      {
        v53 = &a5[*(unsigned int *)v9];
        HIDWORD(v75) = *v32;
        for ( j = 0; ; ++j )
        {
          v55 = v35 - j;
          if ( j > 3 || v35 == j )
            break;
          v57 = j;
          v58 = &v63[j];
          v53[v57] = v58[4092];
        }
        if ( v55 )
        {
          HIDWORD(v75) = *v33;
          for ( k = 0; k <= 3 && v55 != k; ++k )
          {
            v61 = &v53[k];
            v62 = &v63[k];
            v61[4] = v62[4092];
          }
        }
      }
      v7 -= v35;
      *(_DWORD *)v9 += v35;
      if ( !v7 )
      {
        result = 0LL;
        goto LABEL_53;
      }
    }
    if ( (*(_DWORD *)(v15 + 21012520) & 1) != 0 )
      result = 2LL;
    else
      result = 8LL;
  }
LABEL_53:
  v52 = &spmiDrv[20 * (unsigned __int8)byte_316AC];
  *((_DWORD *)v52 + 4) = result;
  if ( a5 )
    v52[12] = *a5;
  if ( (_DWORD)result )
    ++dword_316C4;
  return result;
}
// 13794: using guessed type __int64 __fastcall SpmiOs_Wait(_QWORD);
// 316AC: using guessed type char byte_316AC;
// 316B0: using guessed type char byte_316B0;
// 316B2: using guessed type __int16 word_316B2;
// 316BC: using guessed type int dword_316BC;
// 316C0: using guessed type char byte_316C0;
// 316C4: using guessed type int dword_316C4;
// 316C8: using guessed type __int64 qword_316C8;

//----- (0000000000013574) ----------------------------------------------------
__int64 SpmiBus_Init()
{
  __int64 result; // x0
  __int64 v1; // x0
  unsigned __int16 **v2; // x0
  unsigned __int16 *v3; // x1
  unsigned int v4; // w3
  unsigned int i; // w0
  unsigned __int64 v6; // x2
  __int64 v7; // x2

  result = 0LL;
  if ( !spmiDrv[0] )
  {
    result = SpmiOs_Init(&qword_316C8);
    if ( !(_DWORD)result )
    {
      v1 = qword_316C8;
      *(_BYTE *)(qword_316C8 + 1) = 0;
      v2 = *(unsigned __int16 ***)(v1 + 24);
      v3 = *v2;
      if ( (*((_DWORD *)*v2 + 5259264) & 0x400) == 0 )
      {
        v4 = *v2[5];
        for ( i = 0; i < v4; ++i )
        {
          v6 = (unsigned __int64)(unsigned __int16)i << 16;
          *(_DWORD *)((char *)v3 + v6 + 23068936) = 255;
          *(_DWORD *)((char *)v3 + v6 + 23068928) = 0;
          v7 = 2LL * (i & 0x3FFFFFFF);
          *(_DWORD *)&v3[v7 + 10507136] = 0;
          *(_DWORD *)&v3[v7 + 10617984] = 0;
        }
        *((_DWORD *)v3 + 5253120) &= ~1u;
        *((_DWORD *)v3 + 5253124) |= 1u;
        *((_DWORD *)v3 + 5253120) |= 1u;
        *((_DWORD *)v3 + 5254082) |= 1u;
        *((_DWORD *)v3 + 5253125) |= 3u;
        *((_DWORD *)v3 + 5254080) &= 0xFFFFFFFC;
        *((_DWORD *)v3 + 5254081) |= 0x800u;
        *((_DWORD *)v3 + 5254081) |= 0x200u;
        *((_DWORD *)v3 + 5254081) |= 0x100u;
        *((_DWORD *)v3 + 5254081) |= 0x80u;
        *((_DWORD *)v3 + 5254081) |= 0x20u;
        *((_DWORD *)v3 + 5254081) |= 8u;
        *((_DWORD *)v3 + 5254081) |= 1u;
        *((_DWORD *)v3 + 5308420) |= 1u;
        *((_DWORD *)v3 + 5254081) &= ~2u;
      }
      spmiDrv[0] = 1;
      return 0LL;
    }
  }
  return result;
}
// 316C8: using guessed type __int64 qword_316C8;

//----- (0000000000013704) ----------------------------------------------------
__int64 SpmiBus_DeInit()
{
  spmiDrv[0] = 0;
  return 0LL;
}

//----- (0000000000013714) ----------------------------------------------------
__int64 __fastcall SpmiBus_ReadLong(char a1, int a2, int a3, char *a4, unsigned int a5, __int64 *a6)
{
  if ( spmiDrv[0] )
    return debugExecute_part_3(1, a2, a1, a3, a4, a5, a6);
  else
    return 14LL;
}

//----- (0000000000013744) ----------------------------------------------------
__int64 __fastcall SpmiBus_WriteLong(char a1, int a2, int a3, char *a4, unsigned int a5)
{
  if ( spmiDrv[0] )
    return debugExecute_part_3(0, a2, a1, a3, a4, a5, 0LL);
  else
    return 14LL;
}

//----- (0000000000013774) ----------------------------------------------------
__int64 __fastcall SpmiOs_Init(_QWORD *a1)
{
  if ( !pSpmiBlockInfo )
    return 13LL;
  *a1 = pSpmiBlockInfo;
  return 0LL;
}
// 1DA50: using guessed type void *pSpmiBlockInfo;

//----- (0000000000013798) ----------------------------------------------------
_QWORD *__fastcall timer_qtimer_get_frames_list(_QWORD *result, _DWORD *a2)
{
  bool v2; // zf

  if ( result )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( !v2 )
  {
    *result = &qtimer_frames;
    result = (_QWORD *)(&loc_8 + 1);
    *a2 = 9;
  }
  return result;
}

//----- (00000000000137BC) ----------------------------------------------------
__int64 timer_qtimer_security_config()
{
  __int64 result; // x0

  MEMORY[0x17C20004] = 127;
  MEMORY[0x17C20040] = 63;
  MEMORY[0x17C20080] = 0;
  MEMORY[0x17C20084] = 0;
  MEMORY[0x17C20044] = 63;
  MEMORY[0x17C20088] = 0;
  MEMORY[0x17C2008C] = 0;
  MEMORY[0x17C20048] = 63;
  MEMORY[0x17C20090] = 0;
  MEMORY[0x17C20094] = 0;
  MEMORY[0x17C2004C] = 63;
  MEMORY[0x17C20098] = 0;
  MEMORY[0x17C2009C] = 0;
  MEMORY[0x17C20050] = 63;
  MEMORY[0x17C200A0] = 0;
  MEMORY[0x17C200A4] = 0;
  MEMORY[0x17C20054] = 63;
  MEMORY[0x17C200A8] = 0;
  MEMORY[0x17C200AC] = 0;
  MEMORY[0x17C20058] = 63;
  result = 398590128LL;
  MEMORY[0x17C200B0] = 0;
  MEMORY[0x17C200B4] = 0;
  return result;
}

//----- (0000000000013868) ----------------------------------------------------
__int64 timer_qtimer_read_time_raw()
{
  return MEMORY[0x17C25000];
}

//----- (0000000000013878) ----------------------------------------------------
unsigned __int64 timer_qtimer_read_time_us()
{
  return 10LL * MEMORY[0x17C25000] / 0xC0uLL;
}

//----- (0000000000013898) ----------------------------------------------------
void __fastcall timer_sec_wdog_start(int a1, int a2)
{
  unsigned int v2; // w0
  unsigned int v3; // w1

  if ( !a1 )
    a1 = 1;
  if ( !a2 )
    a2 = 1;
  v2 = 32 * a1;
  v3 = 32 * a2;
  MEMORY[0xC230004] &= ~1u;
  if ( v3 > 0xFFFFF )
    v3 = 0xFFFFF;
  if ( v2 > 0xFFFFF )
    v2 = 0xFFFFF;
  MEMORY[0xC23000C] = v2 | MEMORY[0xC23000C] & 0xFFF00000;
  while ( (MEMORY[0xC23000C] & 0x80000000) == 0 )
    ;
  MEMORY[0xC230010] = MEMORY[0xC230010] & 0xFFF00000 | v3;
  while ( (MEMORY[0xC230010] & 0x80000000) == 0 )
    ;
  MEMORY[0xC230004] |= 1u;
  MEMORY[0xC230004] |= 0x80000000;
  MEMORY[0xC230000] = 1;
  cpuss_dsb();
}

//----- (000000000001394C) ----------------------------------------------------
void timer_sec_wdog_stop()
{
  MEMORY[0xC230000] = 1;
  MEMORY[0xC230004] &= ~1u;
  cpuss_dsb();
}

//----- (0000000000013970) ----------------------------------------------------
__int64 timer_sec_wdog_pet()
{
  __int64 result; // x0

  MEMORY[0xC230000] = 1;
  cpuss_dsb();
  result = timer_qtimer_read_time_raw();
  g_sec_wdog_last_pet_time = result;
  return result;
}
// 1DC38: using guessed type __int64 g_sec_wdog_last_pet_time;

//----- (000000000001399C) ----------------------------------------------------
__int64 __fastcall timer_sec_wdt_bark_handler(int a1, __int64 a2, __int64 a3)
{
  if ( a1 != 516 )
    qtisec_assert("noship_src/drivers/timers/timer_sec_wdog.c", 0x53u, "QTISECLIB_INT_ID_SEC_WDOG_BARK == intnum");
  timer_sec_wdog_pet();
  return a3;
}

//----- (00000000000139E0) ----------------------------------------------------
void timer_sec_wdog_init()
{
  MEMORY[0xC230004] = 6;
  int_svc_register_isr(516, (__int64)"SEC_WDOG_BARK", 0xEuLL, (__int64)timer_sec_wdt_bark_handler, 0LL);
  timer_sec_wdog_start(6000, 22000);
}

//----- (0000000000013A2C) ----------------------------------------------------
__int64 Tlmm_PlatformInit()
{
  __int64 result; // x0

  result = 0xFFFFFFFFLL;
  MEMORY[0xF1AF00C] = -1;
  MEMORY[0xF1AF010] = -1;
  MEMORY[0xF1AF014] = -1;
  MEMORY[0xF1AF018] = -1;
  MEMORY[0xF1AF000] = -1;
  MEMORY[0xF1AF004] = -1;
  MEMORY[0xF1AF008] = -1;
  return result;
}

//----- (0000000000013A68) ----------------------------------------------------
__int64 __fastcall XpuEnableDomains(int **a1)
{
  int *v1; // x0
  int v2; // w1

  v1 = *a1;
  if ( !*v1 )
  {
    v2 = 1;
    if ( HIWORD(v1[255]) > 0x3002u )
    {
      v1[256] = 1;
      v2 = 3;
    }
    *v1 = v2;
    v1[4] = 271;
    v1[36] = 271;
    v1[32] = v2;
    v1[68] = 271;
    v1[64] = v2;
  }
  return 0LL;
}

//----- (0000000000013AB4) ----------------------------------------------------
__int64 __fastcall XpuProgramMPUPartitionsPerm(_QWORD *a1, int a2)
{
  __int64 v2; // x4
  __int64 i; // x2
  _DWORD *v4; // x5
  _DWORD *v5; // x3
  _DWORD *v6; // x1
  _DWORD *v7; // x0

  v2 = a1[3];
  for ( i = 0LL; v2 != i; ++i )
  {
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(a1[4] + 24 * i) )
    {
      v4 = (_DWORD *)(a1[2] + 16 * i);
      if ( *v4 != 16777214 )
      {
        if ( *((_QWORD *)v4 + 1) )
        {
          v5 = (_DWORD *)(((unsigned __int64)(*(_DWORD *)(a1[4] + 24 * i) & 0x1FFFFFF) << 7) + *a1);
          v5[1029] = v4[2];
          v5[1031] = v4[3];
          if ( (v4[2] & 0x101) != 0 )
            v5[1028] = 1;
          if ( (v4[3] & 0x101) != 0 )
            v5[1030] = 1;
        }
      }
    }
  }
  v6 = (_DWORD *)(a1[2] + 16 * v2);
  if ( *v6 == 16777214 && *((_QWORD *)v6 + 1) )
  {
    v7 = (_DWORD *)*a1;
    v7[197] = v6[2];
    v7[199] = v6[3];
    if ( (v6[2] & 0x101) != 0 )
      v7[196] = 1;
    if ( (v6[3] & 0x101) != 0 )
      v7[198] = 1;
  }
  return 0LL;
}

//----- (0000000000013BE0) ----------------------------------------------------
__int64 __fastcall XpuProgramMPUPartitionsDynamicPerm(_QWORD *a1, int a2, int a3, int a4)
{
  __int64 v4; // x6
  __int64 i; // x4
  __int64 v6; // x5
  unsigned __int64 v7; // x5

  v4 = 24LL * a1[3];
  for ( i = 0LL; i != v4; i += 24LL )
  {
    v6 = a1[4];
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(v6 + i) )
    {
      v7 = ((unsigned __int64)(*(_DWORD *)(v6 + i) & 0x1FFFFFF) << 7) + *a1;
      *(_DWORD *)(v7 + 4116) = a3;
      *(_DWORD *)(v7 + 4124) = a4;
    }
  }
  return 0LL;
}

//----- (0000000000013C44) ----------------------------------------------------
__int64 __fastcall XpuProgramMPUPartitions(_QWORD *a1, int a2)
{
  __int64 v2; // x5
  __int64 i; // x2
  __int64 v4; // x3
  __int64 v5; // x6
  unsigned __int64 v6; // x3

  v2 = 24LL * a1[3];
  for ( i = 0LL; i != v2; i += 24LL )
  {
    v4 = a1[4];
    if ( a2 == 0xFFFFFF || a2 == *(_DWORD *)(v4 + i) )
    {
      v5 = v4 + i;
      v6 = ((unsigned __int64)(*(_DWORD *)(v4 + i) & 0x1FFFFFF) << 7) + *a1;
      *(_QWORD *)(v6 + 4144) = *(_QWORD *)(v5 + 8);
      *(_QWORD *)(v6 + 4152) = *(_QWORD *)(v5 + 16);
    }
  }
  return 0LL;
}

//----- (0000000000013CCC) ----------------------------------------------------
__int64 __fastcall XpuSetRGOwnership(_QWORD *a1, int a2)
{
  __int64 v2; // x6
  __int64 i; // x3
  int *v4; // x5
  int v5; // w2

  v2 = a1[1];
  for ( i = 0LL; v2 != i; ++i )
  {
    v4 = (int *)(a1[2] + 16 * i);
    v5 = *v4;
    if ( *v4 == 16777214 )
    {
      *(_DWORD *)(*a1 + 768LL) = v4[1];
    }
    else if ( v5 == a2 || a2 == 0xFFFFFF )
    {
      *(_DWORD *)(*a1 + 4096LL + ((unsigned __int64)(v5 & 0x1FFFFFF) << 7)) = v4[1];
    }
  }
  return 0LL;
}

//----- (0000000000013D3C) ----------------------------------------------------
__int64 __fastcall ACQCGetxPUType(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 1016LL) & 3;
}

//----- (0000000000013D4C) ----------------------------------------------------
__int64 __fastcall XpuLockDownAssets(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 result; // x0

  v2 = a1;
  v3 = a1 + 48LL * a2;
  while ( v2 != v3 )
  {
    if ( (*(_DWORD *)(v2 + 44) & 1) != 0 )
    {
      result = XpuEnableDomains((int **)v2);
      if ( (_DWORD)result )
        return result;
      cpuss_dmb();
      cpuss_isb();
      *(_DWORD *)(v2 + 44) |= 2u;
      if ( (unsigned __int8)ACQCGetxPUType(v2) == 2 )
      {
        result = XpuProgramMPUPartitions((_QWORD *)v2, 0xFFFFFF);
        if ( (_DWORD)result )
          return result;
      }
      cpuss_dmb();
      cpuss_isb();
      result = XpuSetRGOwnership((_QWORD *)v2, 0xFFFFFF);
      if ( (_DWORD)result )
        return result;
      if ( (unsigned __int8)ACQCGetxPUType(v2) == 2 )
      {
        result = XpuProgramMPUPartitionsPerm((_QWORD *)v2, 0xFFFFFF);
        if ( (_DWORD)result )
          return result;
      }
    }
    v2 += 48LL;
  }
  cpuss_dsb();
  cpuss_isb();
  return 0LL;
}

//----- (0000000000013E24) ----------------------------------------------------
__int64 __fastcall XpuMasterMPuInit(__int64 a1, unsigned int a2)
{
  unsigned __int8 *v2; // x4
  unsigned __int8 *v3; // x6
  unsigned int v4; // w12
  __int64 v5; // x10
  unsigned int v6; // w7
  unsigned int v7; // w11
  int v8; // w3
  int **v9; // x0
  unsigned __int64 v10; // x9
  unsigned int v11; // w8
  int v12; // w2
  unsigned int v13; // w13
  __int64 v14; // x1
  unsigned __int64 v15; // x8
  unsigned int v16; // w1
  int i; // w3
  unsigned int v18; // w9
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x15
  __int64 result; // x0
  __int64 v22; // x5

  v2 = (unsigned __int8 *)(a1 + 4);
  v3 = (unsigned __int8 *)(a1 + 16LL * a2 + 4);
  v4 = 24;
  v5 = 0xFFFFFFFFLL;
  while ( v2 != v3 )
  {
    v6 = 0;
    v7 = 48;
    while ( v6 < *v2 )
    {
      v8 = *((unsigned __int16 *)v2 + 1);
      v9 = (int **)(*(_QWORD *)(v2 + 4) + v6 * (unsigned __int64)v7);
      v10 = (unsigned __int64)v9[1];
      v11 = v10 - v8;
      v12 = (HIWORD((*v9)[254]) & 0x3FF) - v8 + 1;
      while ( 1 )
      {
        v13 = v11 + v12;
        if ( v10 <= v11 )
          break;
        v14 = 4LL * v11++;
        *(_QWORD *)&v9[2][v14] = v8 - (_DWORD)v10 + v13;
      }
      v15 = (unsigned __int64)v9[3];
      v16 = v15 - v8;
      for ( i = v8 - v15; ; *(_DWORD *)v20 = i + v18 )
      {
        v18 = v16 + v12;
        if ( v15 <= v16 )
          break;
        v19 = v16++ * (unsigned __int64)v4;
        v20 = (unsigned __int64)v9[4] + v19;
        *(_QWORD *)(v20 + 8) = v5;
        *(_QWORD *)(v20 + 16) = v5;
      }
      if ( (*((_DWORD *)v9 + 11) & 2) == 0 )
      {
        result = XpuEnableDomains(v9);
        if ( (_DWORD)result )
          return result;
        *(_DWORD *)(*(_QWORD *)(v2 + 4) + v22 + 44) |= 2u;
      }
      ++v6;
    }
    v2 += 16;
  }
  return 0LL;
}
// 13E48: variable 'v3' is possibly undefined
// 13E54: variable 'v2' is possibly undefined
// 13E64: variable 'v7' is possibly undefined
// 13ED8: variable 'v4' is possibly undefined
// 13EEC: variable 'v5' is possibly undefined
// 13F0C: variable 'v22' is possibly undefined
// 13F1C: variable 'v6' is possibly undefined

//----- (0000000000013F38) ----------------------------------------------------
__int64 __fastcall XpuLockDownAssetDynamically(__int64 a1, unsigned __int8 a2, int a3, int a4, int a5, int a6)
{
  __int64 v9; // x1
  __int64 v10; // x19
  __int64 result; // x0
  char v12; // w0

  v9 = a1 + 48LL * a2;
  do
  {
    if ( a1 == v9 )
      return 0xFFFFFFFFLL;
    v10 = a1;
    a1 += 48LL;
  }
  while ( *(_DWORD *)(a1 - 8) != a3 );
  if ( (*(_DWORD *)(v10 + 44) & 2) == 0 )
  {
    result = XpuEnableDomains((int **)v10);
    if ( (_DWORD)result )
      return result;
    *(_DWORD *)(v10 + 44) |= 2u;
  }
  cpuss_dmb();
  cpuss_isb();
  if ( (unsigned __int8)ACQCGetxPUType(v10) != 2
    || (result = XpuProgramMPUPartitions((_QWORD *)v10, a4), !(_DWORD)result) )
  {
    cpuss_dmb();
    cpuss_isb();
    result = XpuSetRGOwnership((_QWORD *)v10, a4);
    if ( !(_DWORD)result )
    {
      v12 = ACQCGetxPUType(v10);
      if ( v12 != 2 || (result = XpuProgramMPUPartitionsDynamicPerm((_QWORD *)v10, a4, a5, a6), !(_DWORD)result) )
      {
        cpuss_dmb();
        cpuss_isb();
        return 0LL;
      }
    }
  }
  return result;
}

//----- (0000000000014040) ----------------------------------------------------
__int64 __fastcall msm_xpu_print_log(int *a1)
{
  void **v2; // x1
  __int64 v3; // x0
  __int64 v4; // x25
  __int64 result; // x0
  int v6; // w28
  char *v7; // x19
  int v8; // w4
  int v9; // w0
  unsigned int v10; // w21
  unsigned int v11; // w20
  __int64 v12; // x5
  char *v13; // x1
  unsigned int *v14; // x24
  unsigned int v15; // t1
  __int64 v16; // [xsp+60h] [xbp+60h]
  int v17; // [xsp+6Ch] [xbp+6Ch]
  __int16 v18; // [xsp+70h] [xbp+70h] BYREF
  __int64 v19; // [xsp+78h] [xbp+78h] BYREF

  v19 = 0LL;
  if ( (unsigned __int8)dbg_is_sdi_enable() )
    qtiseclib_cb_switch_console_to_crash_state();
  qtiseclib_cb_log(40LL, "xpu: ISR begin");
  if ( *a1 )
  {
    if ( *a1 != 1 )
    {
      qtiseclib_cb_log(10LL, "XPU ERROR: Invalid!!");
      goto LABEL_9;
    }
    qtiseclib_cb_log(10LL, "XPU ERROR: Non Sec!!");
    v2 = &xpu_non_sec_intr_status_reg;
    v3 = 33300480LL;
  }
  else
  {
    qtiseclib_cb_log(10LL, "XPU ERROR: Sec!!");
    v2 = &xpu_sec_intr_status_reg;
    v3 = 33308672LL;
  }
  LODWORD(v19) = *(_DWORD *)v3 & (unsigned int)v2[1];
  HIDWORD(v19) = *(_DWORD *)v2[2] & (unsigned int)v2[3];
LABEL_9:
  v4 = 0LL;
  result = qtiseclib_cb_log(10LL, "XPU INTR 0:1 >> %08x:%08x", (unsigned int)v19, HIDWORD(v19));
  do
  {
    v6 = *(_DWORD *)((char *)&v19 + v4);
    if ( v6 )
    {
      v7 = (char *)&xpu_err_pos_to_hal_map + 64 * v4;
      do
      {
        if ( (v6 & *(_DWORD *)v7) != 0 )
        {
          v8 = (unsigned __int8)v7[4];
          if ( (unsigned int)(v8 - 1) <= 0x16 )
          {
            v9 = *a1;
            v18 = 32;
            if ( v9 )
            {
              if ( v9 == 1 )
                v10 = 2176;
              else
                v10 = 0;
            }
            else
            {
              v10 = 2048;
              LOBYTE(v18) = 83;
            }
            v11 = 0;
            v12 = 24LL;
            while ( v11 < g_xpu_base_addr_array_count )
            {
              v13 = (char *)&g_xpu_base_addr_array + (int)v11 * v12;
              if ( v8 == *(_DWORD *)v13 )
              {
                v16 = v12;
                v14 = (unsigned int *)(v10 + *((_QWORD *)v13 + 1));
                v17 = v8;
                qtiseclib_cb_log(10LL, "%sEAR0 0x%x", (const char *)&v18, *v14);
                qtiseclib_cb_log(10LL, "%sEAR1 0x%x", (const char *)&v18, v14[1]);
                qtiseclib_cb_log(10LL, "%sESR 0x%x", (const char *)&v18, v14[2]);
                qtiseclib_cb_log(10LL, "%sESYNR0 0x%x", (const char *)&v18, v14[4]);
                qtiseclib_cb_log(10LL, "%sESYNR1 0x%x", (const char *)&v18, v14[5]);
                qtiseclib_cb_log(10LL, "%sESYNR2 0x%x", (const char *)&v18, v14[6]);
                qtiseclib_cb_log(10LL, "%sESYNR3 0x%x", (const char *)&v18, v14[7]);
                qtiseclib_cb_log(10LL, "%sESYNR4 0x%x", (const char *)&v18, v14[8]);
                v14[3] = 0;
                v8 = v17;
                v12 = v16;
              }
              ++v11;
            }
          }
        }
        v15 = *((_DWORD *)v7 + 2);
        v7 += 8;
        result = v15;
      }
      while ( v15 );
    }
    v4 += 4LL;
  }
  while ( v4 != 8 );
  return result;
}
// 16888: using guessed type void *xpu_non_sec_intr_status_reg;
// 168A8: using guessed type void *xpu_sec_intr_status_reg;
// 18968: using guessed type int g_xpu_base_addr_array_count;
// 31978: using guessed type __int64 qtiseclib_cb_switch_console_to_crash_state(void);
// 319A8: using guessed type __int64 qtiseclib_cb_log(_QWORD, const char *, ...);

// nfuncs=584 queued=522 decompiled=522 lumina nreq=0 worse=0 better=0
// ALL OK, 522 function(s) have been successfully decompiled

